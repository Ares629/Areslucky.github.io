<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Ubuntu | Areslucky</title><meta name="author" content="Areslucky"><meta name="copyright" content="Areslucky"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="安装ubuntu时，安装界面不全：ctrl+alt+t &#x2F;&#x2F;打开终端: xrandr  &#x2F;&#x2F;查看分辨率: xrandr -s 1920x1080_59.96 &#x2F;&#x2F;选择分辨率  换源#添加阿里源deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.al">
<meta property="og:type" content="article">
<meta property="og:title" content="Ubuntu">
<meta property="og:url" content="http://example.com/2024/04/24/Ubuntu/index.html">
<meta property="og:site_name" content="Areslucky">
<meta property="og:description" content="安装ubuntu时，安装界面不全：ctrl+alt+t &#x2F;&#x2F;打开终端: xrandr  &#x2F;&#x2F;查看分辨率: xrandr -s 1920x1080_59.96 &#x2F;&#x2F;选择分辨率  换源#添加阿里源deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.al">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/blog004.jpg">
<meta property="article:published_time" content="2024-04-24T13:15:59.054Z">
<meta property="article:modified_time" content="2024-05-28T12:33:31.981Z">
<meta property="article:author" content="Areslucky">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/blog004.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/04/24/Ubuntu/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: ,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ubuntu',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-05-28 20:33:31'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Areslucky" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/lazyload.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/lazyload.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 视音</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/blog004.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Areslucky"><span class="site-name">Areslucky</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 视音</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Ubuntu</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-24T13:15:59.054Z" title="发表于 2024-04-24 21:15:59">2024-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-28T12:33:31.981Z" title="更新于 2024-05-28 20:33:31">2024-05-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Ubuntu"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h5 id="安装ubuntu时，安装界面不全："><a href="#安装ubuntu时，安装界面不全：" class="headerlink" title="安装ubuntu时，安装界面不全："></a>安装ubuntu时，安装界面不全：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctrl+alt+t <span class="comment">//打开终端</span></span><br><span class="line">: xrandr  <span class="comment">//查看分辨率</span></span><br><span class="line">: xrandr -s <span class="number">1920</span>x1080_59<span class="number">.96</span> <span class="comment">//选择分辨率</span></span><br></pre></td></tr></table></figure>

<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加阿里源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>



<h2 id="linux基础命令"><a href="#linux基础命令" class="headerlink" title="linux基础命令"></a>linux基础命令</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*安装c的时候，c依赖b，b又依赖a，这个时候会自动安装a和b</span></span><br><span class="line"><span class="comment">但是，如果c利用了b默认隐含a包的条件，直接调用了a中的api，而下次更新b包的时候，假如b不再依赖a，这个时候autoremove会删掉a包，使c包不可用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">于是当你sudo apt-get remove c 后，autoremove会删除a,b.</span><br><span class="line">sudo apt-get autoremove <span class="comment">//卸载所有自动安装且不再使用的软件包</span></span><br></pre></td></tr></table></figure>

<h2 id="vim-文本文档命令"><a href="#vim-文本文档命令" class="headerlink" title="vim &amp; 文本文档命令"></a>vim &amp; 文本文档命令</h2><h5 id="一般模式下的"><a href="#一般模式下的" class="headerlink" title="一般模式下的"></a>一般模式下的</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + f //向下一页</span><br><span class="line">ctrl + d //向下半页</span><br><span class="line">+ //光标移动到非空格符的下一行，此时需要按住shift 和 =  输出 +</span><br><span class="line">ctrl + b //向上一页</span><br><span class="line">ctrl + u //向上半页</span><br><span class="line">- //光标移动到非空格符的上一行，只需要按住-</span><br><span class="line">n&lt;space&gt; //光标会向右移动这一行的 n 个字符，如果超出这一行的长度会停留在最后一个字符</span><br><span class="line">0 //光标移动到这一行的第一个字符</span><br><span class="line">$ //光标移动到这一行的最后一个字符</span><br><span class="line">H //光标移动到这个屏幕的一个字符</span><br><span class="line">L //光标移动到这个屏幕的最后一个字符</span><br><span class="line">G //光标移动到这个档案的最后</span><br><span class="line">nG //n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</span><br><span class="line">gg //移动到这个档案的第一行</span><br><span class="line">n&lt;Enter&gt; //n 为数字。光标向下移动 n 行</span><br><span class="line">r //替换当前光标所处位置的一个字符</span><br><span class="line">R //从光标处开始替换直到ESC退出替换模式</span><br><span class="line">x //删除当前光标位置的一个字符</span><br><span class="line">X //删除光标前的一个字符</span><br><span class="line"></span><br><span class="line">//替换当前行第一个匹配的字符串</span><br><span class="line">:s/old_string/new_string/</span><br><span class="line">//替换当前行所有匹配的字符串：</span><br><span class="line">:s/old_string/new_string/g</span><br><span class="line">//替换当前文件中所有匹配的字符串</span><br><span class="line">:%s/old_string/new_string/g</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="gcc命令"><a href="#gcc命令" class="headerlink" title="gcc命令"></a>gcc命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc demo.c -E //对文件进行预处理  </span><br></pre></td></tr></table></figure>



<h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除空目录，可以使用 rmdir 命令,如果目录不为空，rmdir 将会报错</span><br><span class="line">rmdir directory_name</span><br><span class="line">//删除非空目录,要删除一个包含文件的非空目录，可以使用 rm 命令与 -r 选项（递归删除）</span><br><span class="line">rm -r directory_name</span><br></pre></td></tr></table></figure>

<h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//更改文件名</span><br><span class="line">mv process_001 process_001.c</span><br></pre></td></tr></table></figure>



<h2 id="chmod权限设置"><a href="#chmod权限设置" class="headerlink" title="chmod权限设置"></a>chmod权限设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r（读取）：4</span><br><span class="line">w（写入）：2</span><br><span class="line">x（执行）：1</span><br><span class="line">用户权限：rwx -&gt; 4 + 2 + 1 = 7</span><br><span class="line">组权限：r-x -&gt; 4 + 0 + 1 = 5</span><br><span class="line">其他用户权限：r-x -&gt; 4 + 0 + 1 = 5</span><br><span class="line">755的权限模式表示文件所有者具有读、写、执行权限（7），而组和其他用户只有读和执行权限（5）。</span><br><span class="line">chmod +x hello.sh //为该文件的所有者添加执行权限</span><br><span class="line">chmod g+x hello.sh //为该文件的所属组添加执行权限</span><br><span class="line">chmod o+x hello.sh //为该文件的其他用户添加执行权限</span><br></pre></td></tr></table></figure>

<h2 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h2><ul>
<li><p>**<code>$0</code>**：显示脚本的名称（包含路径）。</p>
</li>
<li><p>**<code>$1</code> 和 <code>$2</code>**：显示传递给脚本的第一个和第二个参数。</p>
</li>
<li><p>**<code>$#</code>**：显示传递给脚本的参数数量。</p>
</li>
<li><p><code>$@</code> 和 <code>$*</code></p>
<p>：显示传递给脚本的所有参数。注意，它们的表现有所不同：</p>
<ul>
<li><code>&quot;$@&quot;</code> 将每个参数作为独立的字符串处理。</li>
<li><code>&quot;$*&quot;</code> 将所有参数作为一个单一的字符串处理。</li>
</ul>
</li>
<li><p>**<code>$?</code>**：显示上一个命令（<code>ls /nonexistent</code>）的退出状态，因为该目录不存在，所以退出状态为 2。</p>
</li>
<li><p>**<code>$$</code>**：显示当前脚本的进程 ID。</p>
</li>
<li><p>**<code>$!</code>**：显示最后一个后台进程的进程 ID（<code>sleep 5 &amp;</code>）</p>
</li>
</ul>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//grep的基本语法 grep [选项] 模式 文件名</span><br><span class="line">grep hello example.txt</span><br><span class="line"></span><br><span class="line">//搜索文件夹下的文件 grep -r pattern folder_name</span><br><span class="line">//搜索文件夹/home/user/documents下所有文件中包含单词&quot;world&quot;的行</span><br><span class="line">grep -r world /home/user/documents</span><br><span class="line"></span><br><span class="line">//搜索的内容不区分大小写 grep -i pattern file</span><br><span class="line">grep -i hello example.txt</span><br><span class="line"></span><br><span class="line">//输出匹配行数  grep -c pattern file</span><br><span class="line">grep -c hello example.txt</span><br><span class="line"></span><br><span class="line">//使用正则表达式进行更复杂的匹配 grep -E &quot;pattern&quot; file</span><br><span class="line">grep -E &quot;[a-zA-Z0-9]+&quot; example.txt</span><br><span class="line"></span><br><span class="line">//将grep输出结果导出到文件</span><br><span class="line">grep &quot;hello&quot; example.txt &gt; output.txt</span><br><span class="line"></span><br><span class="line">//使用grep进行递归搜索 通过使用-r选项，我们可以实现递归搜索。例如，以下命令将在文件夹documents中递归搜索包含字符串&quot;hello&quot;的行：</span><br><span class="line">grep -r &quot;hello&quot; documents</span><br><span class="line"></span><br><span class="line">//使用grep进行多关键词搜索 以下命令在文件example.txt中搜索同时包含&quot;hello&quot;和&quot;world&quot;的行：</span><br><span class="line">grep &quot;hello&quot; example.txt | grep &quot;world&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="管道操作符"><a href="#管道操作符" class="headerlink" title="| 管道操作符"></a>| 管道操作符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令 ./process_001 | wc -l 由两部分组成：一个可执行文件 process_001 和管道操作符 |，以及 wc -l。这个命令的作用是运行 process_001 并统计其输出的行数。</span><br><span class="line">|：管道操作符，用于将前一个命令的输出作为下一个命令的输入。</span><br></pre></td></tr></table></figure>



<h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//sed &#x27;s/原字符串/新字符串/&#x27; 文件名   </span><br><span class="line">sed &#x27;s/hello/world/&#x27; file.txt   //只替换每一行的一个符合的字符串</span><br><span class="line">sed &#x27;s/hello/world/g&#x27; file.txt  //替换每行的所有匹配项</span><br><span class="line"></span><br><span class="line">//使用-i选项可以直接修改文件内容</span><br><span class="line">sed -i &#x27;s/hello/world/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//打印文件file.txt中的第二列</span><br><span class="line">awk &#x27;&#123;print $2&#125;&#x27; file.txt</span><br><span class="line"></span><br><span class="line">//如果文件以逗号分隔，可以使用-F选项指定分隔符</span><br><span class="line">awk -F &#x27;,&#x27; &#x27;&#123;print $2&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean #来声明伪目标,伪目标是一种不与文件系统中的实际文件相关联的目标，它们通常用来执行某些命令，而不是生成某个文件。它的作用1.避免文件名冲突 2.提高执行效率</span></span><br><span class="line"></span><br><span class="line">GCC=gcc <span class="comment">#定义变量</span></span><br><span class="line">EXE=main</span><br><span class="line"><span class="comment">#OBJS=text.o input.o calcu.o</span></span><br><span class="line">RM=rm</span><br><span class="line"><span class="comment">#CFLAGS+=-D_FILE_OFFSET_BITS=64  //预处理器宏定义的正确格式是 -D宏名=值，中间没有空格。CFLAGS 是编译器标志变量，使用 += 可以将新标志追加到现有的 CFLAGS 中</span></span><br><span class="line">SRCS=$&#123;wildcard *.c&#125;  <span class="comment">#*：通配符  wildcard</span></span><br><span class="line">OBJS=$&#123;patsubst %.c, %.o, $&#123;SRCS&#125;&#125; <span class="comment">#%：模式匹配符</span></span><br><span class="line"><span class="section">$&#123;EXE&#125;: $&#123;OBJS&#125;</span></span><br><span class="line">	$&#123;GCC&#125; -o $&#123;EXE&#125; $&#123;OBJS&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	$&#123;GCC&#125; -c <span class="variable">$^</span></span><br><span class="line"><span class="comment">#text.o: text.c</span></span><br><span class="line"><span class="comment">#	$&#123;GCC&#125; -c $^</span></span><br><span class="line"><span class="comment">#input.o: input.c</span></span><br><span class="line"><span class="comment">#	$&#123;GCC&#125; -c $^</span></span><br><span class="line"><span class="comment">#calcu.o: calcu.c</span></span><br><span class="line"><span class="comment">#	$&#123;GCC&#125; -c $^</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	$&#123;RM&#125; $&#123;OBJS&#125;</span><br><span class="line">	$&#123;RM&#125; $&#123;EXE&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">I/O:stdio标准IO  <span class="comment">//FILE类型贯穿始终</span></span><br><span class="line">	sysio系统调用IO(文件IO)</span><br><span class="line">	<span class="comment">//在两种都能用的环境下，优先使用标准IO</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//demo_stdio.c  实现打开关闭文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;demo_file&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen() failed! :%s\n&quot;</span>, strerror(errno));<span class="comment">//[2]</span></span><br><span class="line">        <span class="comment">//perror(&quot;fopen() failed!&quot;); //[3]与上面error相同 但无法使用格式化输出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    fclose(fp);<span class="comment">//[4]谁打开谁关闭</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen() failed! :%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	FILE *fopen(const char *pathname, const char *mode); //const只读，不会改变参数数据。 FILE类型存储在堆上</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">      r      Open text file for reading.  The stream（数据流） is positioned at the be‐</span></span><br><span class="line"><span class="comment">              ginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       r+     Open  for  reading and writing.  The stream is positioned at the</span></span><br><span class="line"><span class="comment">              beginning of the file.</span></span><br><span class="line"><span class="comment">				使用r/r+打开不存在的文件会报错</span></span><br><span class="line"><span class="comment">       w      Truncate（截断） file to zero length or create text  file  for  writing.</span></span><br><span class="line"><span class="comment">              The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       w+     Open  for  reading  and writing.  The file is created if it does</span></span><br><span class="line"><span class="comment">              not exist, otherwise it is truncated.  The stream is  positioned</span></span><br><span class="line"><span class="comment">              at the beginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       a      Open  for  appending (writing at end of file).  The file is cre‐</span></span><br><span class="line"><span class="comment">              ated if it does not exist.  The stream is positioned at the  end</span></span><br><span class="line"><span class="comment">              of the file.</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">[2]#include &lt;stdio,h&gt;</span></span><br><span class="line"><span class="comment">	   extern FILE *stdin;</span></span><br><span class="line"><span class="comment">       extern FILE *stdout;</span></span><br><span class="line"><span class="comment">       extern FILE *stderr;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">	Under  normal circumstances（正常情况） every UNIX program has three streams opened</span></span><br><span class="line"><span class="comment">for it when it starts up, one for input, one for output,  and  one  for</span></span><br><span class="line"><span class="comment">printing diagnostic（诊断提示） or error messages.</span></span><br><span class="line"><span class="comment">	The input stream is referred to as &quot;standard input（标准输入）&quot;; the output  stream</span></span><br><span class="line"><span class="comment">is  referred  to as &quot;standard output&quot;; and the error stream is referred</span></span><br><span class="line"><span class="comment">to as &quot;standard error&quot;.  These terms（术语） are abbreviated（缩写为） to form  the  sym‐</span></span><br><span class="line"><span class="comment">bols used to refer to these files, namely stdin, stdout, and stderr.</span></span><br><span class="line"><span class="comment">	Each  of these symbols is a stdio(3) macro（宏） of type pointer to FILE, and</span></span><br><span class="line"><span class="comment">can be used with functions like fprintf(3) or fread(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	 void perror(const char *s);</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">	 The  perror()  function produces a message on standard error describing</span></span><br><span class="line"><span class="comment">the last error encountered（在...中遇到的） during a call to a system or  library  func‐</span></span><br><span class="line"><span class="comment">tion.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	int fclose(FILE *stream);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">DESCRIPTION:	</span></span><br><span class="line"><span class="comment">	Upon（在...之上）  successful completion（完成）, 0 is returned.  Otherwise（否则）, EOF is returned</span></span><br><span class="line"><span class="comment">and errno is set to indicate the error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo_cp.c 实现文件的cp， </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">	<span class="comment">//判断参数数量</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s open filed! :%s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fclose(fps);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s open filed! :%s\n&quot;</span>, argv[<span class="number">2</span>], strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用fgetc(),fputc()一个一个字符cp</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ch = fgetc(fps);<span class="comment">//[1] ch 如果是char类型 ，可能导致有些字符无法显示</span></span><br><span class="line">        <span class="keyword">if</span>(ch == EOF)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fputc(ch, fpd);<span class="comment">//[2]</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*使用fgets(), fputs()进行BUFFSIZE大小的读写的操作</span></span><br><span class="line"><span class="comment">	#define BUFFSIZE 1024</span></span><br><span class="line"><span class="comment">	char buff[BUFFSIZE];</span></span><br><span class="line"><span class="comment">    while(fgets(buff, BUFFSIZE, fps) != NULL)&#123;    [3]</span></span><br><span class="line"><span class="comment">        fputs(buff, fpd);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*使用fread(),fwrite()进行BUFFSIZE大小的读写操作</span></span><br><span class="line"><span class="comment">	while(fread(buff,1,BUFFSIZE,fps) == BUFFSIZE)&#123; [4]</span></span><br><span class="line"><span class="comment">        fwrite(buff,1,BUFFSIZE,fpd);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fseek(fps, 0, SEEK_END);[5]</span></span><br><span class="line"><span class="comment">    fprintf(stdout, &quot;size:%ld&quot;, ftell(fps));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	int fgetc(FILE *stream);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">	fgetc()  reads  the next character(字符) from stream and returns it as an un‐</span></span><br><span class="line"><span class="comment">signed char cast to an int, or EOF on end of file or error.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">	fgetc(),  getc() and getchar() return the character read as an unsigned char cast to an int or EOF on end of file or error.</span></span><br><span class="line"><span class="comment">[2]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fputc(int c, FILE *stream);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">    fputc() writes the character c, cast to an unsigned char, to stream.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">    fputc(),  putc()  and  putchar() return the character written as an unsigned char cast to(转换类型) an int or EOF on error.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	char *fgets(char *s, int size, FILE *stream);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">	fgets()  reads in at most one less than size characters（最多读入一个小于size大小的字符串） from stream and stores them into the buffer pointed to by s.  Reading  stops  after  anEOF  or a newline.  If a newline is read, it is stored into the buffer.A terminating null byte (&#x27;\0&#x27;) is stored after the  last  character  inthe buffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">	fgets() returns s on success, and NULL on error or when end of file occurs while no characters have been read.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span></span><br><span class="line"><span class="comment">       size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">	The  function  fread() reads nmemb items(项数) of data, each size bytes long,from the stream pointed to by stream,  storing（存储）  them  at  the  location given by ptr.</span></span><br><span class="line"><span class="comment">    The function fwrite() writes nmemb items of data, each size bytes long,to the stream pointed to by stream, obtaining them  from  the  location given by ptr.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">	On  success,  fread()  and  fwrite() return the number of items read or written.  This number equals the number of bytes transferred only  when size  is 1.  If an error occurs, or the end of the file is reached, the return value is a short item count (or zero).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[5]include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment">       long ftell(FILE *stream);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  fseek()  function  sets the file position indicator(标志) for the stream pointed to by stream.  The new position, measured（测量） in bytes, is obtained（得到）by  adding offset（偏移量） bytes to the position specified（规定的） by whence（到原来的地方）.  If whence is set to SEEK_SET, SEEK_CUR, or SEEK_END, the offset  is  relative  to the  start of the file, the current position indicator, or end-of-file,respectively.  A successful call to the  fseek()  function  clears  the end-of-file  indicator  for  the  stream  and undoes any effects of the ungetc(3) function on the same stream.      </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       The ftell() function obtains the current value of the file position indicator for the stream pointed to by stream.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="标准IO与系统调用IO的区别"><a href="#标准IO与系统调用IO的区别" class="headerlink" title="标准IO与系统调用IO的区别"></a>标准IO与系统调用IO的区别</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">//标准IO [1] </span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>); <span class="comment">//系统调用IO [2]</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">//标准错误流  无缓冲</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;d&quot;</span>); <span class="comment">//标准输出流  行缓冲</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;e\n&quot;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//[3] </span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strace ./main  <span class="comment">//可以查看程序执行过程</span></span><br><span class="line"></span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0x5600efca1000</span></span><br><span class="line">brk(<span class="number">0x5600efcc2000</span>)                     = <span class="number">0x5600efcc2000</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>c)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;ade\n&quot;</span>, <span class="number">4</span>ade</span><br><span class="line">)                    = <span class="number">4</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>a)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>a)                        = <span class="number">1</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双引号用来表示字符串字面量（string literal）。</span></span><br><span class="line"><span class="comment">在大多数编程语言中，双引号内的内容被视为字符串，编译器或解释器会将其解析为字符串类型的数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">单引号用来表示字符字面量（character literal）。</span></span><br><span class="line"><span class="comment">在C语言中，字符值（Character value）的确是用整数类型来表示的，具体来说是使用 int 类型。</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int putchar(int c);</span></span><br><span class="line"><span class="comment">    从函数原型可以看到，参数要求int类型,需要输入&#x27;a&#x27;  而不是&quot;a&quot;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">[2]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">	ssize_t write(int __fd, const void *__buf, size_t __n)</span></span><br><span class="line"><span class="comment">	从函数原型可以看到，参数要求类型,需要输入&quot;b&quot;  &quot;b&quot; 是一个字符串常量，它以 &#x27;\0&#x27; 结尾，or</span></span><br><span class="line"><span class="comment">	char buff = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment">	write(1, &amp;buff, 1);</span></span><br><span class="line"><span class="comment">	以这种第二参数是指针也是可以的.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       int fflush(FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       For  output  streams,  fflush() forces a write of all</span></span><br><span class="line"><span class="comment">       user-space buffered data for the given output or  up‐</span></span><br><span class="line"><span class="comment">       date  stream  via the stream&#x27;s underlying(底层的) write func‐</span></span><br><span class="line"><span class="comment">       tion.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       For input  streams  associated（相关的）  with  seekable（可寻找的）  files</span></span><br><span class="line"><span class="comment">       (e.g.,  disk（磁盘）  files,  but  not  pipes  or terminals（终端）),</span></span><br><span class="line"><span class="comment">       fflush() discards（丢弃） any buffered（缓冲区）  data  that  has  been</span></span><br><span class="line"><span class="comment">       fetched（取出）  from  the  underlying file, but has not been</span></span><br><span class="line"><span class="comment">       consumed（深受影响的） by the application.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The open status of the stream is unaffected（不受影响的）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If the stream argument（参数） is NULL, fflush() flushes  all</span></span><br><span class="line"><span class="comment">       open output streams.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       Upon successful completion 0 is returned.  Otherwise,</span></span><br><span class="line"><span class="comment">       EOF is returned and errno is set to indicate the  error.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -axf命令在类Unix操作系统中用于显示当前正在运行的进程信息。查看进程关系。</span><br><span class="line"></span><br><span class="line">ps -axm 用于显示所有进程以及它们的线程信息</span><br><span class="line"></span><br><span class="line">ps ax -L 用于显示系统中所有进程及其线程的信息</span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_008$ ps ax -L</span><br><span class="line">    PID     LWP TTY      STAT   TIME COMMAND</span><br><span class="line">    PID：进程ID。</span><br><span class="line">    LWP：线程ID（轻量级进程ID）。</span><br><span class="line">    TTY：终端关联信息。</span><br><span class="line">    STAT：进程/线程状态。</span><br><span class="line">    TIME：占用CPU时间。</span><br><span class="line">    COMMAND：启动命令。</span><br><span class="line">    ps：显示活动进程的信息。</span><br><span class="line">    a：显示所有用户的进程。通常，ps只显示当前用户的进程。</span><br><span class="line">    x：显示没有控制终端的进程。</span><br><span class="line">    f：以树状格式显示进程，展示进程之间的层级关系。</span><br><span class="line">    下个进程的PID号其实是根据上个进程里线程的数量而增加的。比如</span><br><span class="line">    449     449 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    449     450 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    449     451 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    594     594 ?        I&lt;     0:00 [cryptd]</span><br><span class="line">    进程号 449-&gt;594 在此期间其他进程中的线程数量增长和消亡</span><br><span class="line">PROCESS STATE CODES</span><br><span class="line">       Here are the different values that the s,</span><br><span class="line">       stat and state output specifiers(详细) (header</span><br><span class="line">       &quot;STAT&quot; or &quot;S&quot;) will display to describe the</span><br><span class="line">       state of a process:</span><br><span class="line"></span><br><span class="line">               D    uninterruptible sleep (usually IO) //不可中断的睡眠态</span><br><span class="line">               I    Idle kernel thread</span><br><span class="line">               R    running or runnable (on run queue)</span><br><span class="line">               S    interruptible sleep (waiting for an event to complete)//可中断的睡眠态</span><br><span class="line">               T    stopped by job control signal</span><br><span class="line">               t    stopped by debugger during the tracing</span><br><span class="line">               W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">               X    dead (should never be seen)</span><br><span class="line">               Z    defunct (&quot;zombie&quot;)（僵尸态） process,terminated but not reaped by its parent</span><br></pre></td></tr></table></figure>



<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fork();</span></span><br><span class="line"><span class="comment">理解关键字：duplicating，意味着拷贝，克隆，一模一样的含义。</span></span><br><span class="line"><span class="comment">fork后父子进程的区别：fork的返回值不一样，pid不同，ppid也不同，未决信号和文件锁不继承，资源利用量清0；</span></span><br><span class="line"><span class="comment">init进程：1号，是所有进程的祖先进程</span></span><br><span class="line"><span class="comment">调度器的调度策略来决定那个进程先运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process is starting!\n&quot;</span>); <span class="comment">//行缓冲</span></span><br><span class="line">    fflush(<span class="literal">NULL</span>); <span class="comment">//刷新全部缓冲区 [1]</span></span><br><span class="line">    pid = fork(); <span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]子进程 is working!\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] 父进程 is working!\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]//假设代码中没有fflush(NULL);</span></span><br><span class="line"><span class="comment">//输出到标准I0设备上，行缓冲</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_002</span></span><br><span class="line"><span class="comment">process is starting!  //只打印一次</span></span><br><span class="line"><span class="comment">[3507] 父进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment">[3508]子进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//通过重定向，输出到文件中，全缓冲</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_002 &gt; text</span></span><br><span class="line"><span class="comment">process is starting!//打印两次，\n在全缓冲中只是相当于文件的换行</span></span><br><span class="line"><span class="comment">[3574] 父进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment">process is starting!</span></span><br><span class="line"><span class="comment">[3575]子进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">   #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       pid_t fork(void);</span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       fork()  creates a new process by duplicating(克隆) the calling process（当前进程）.  The new process is referred to（被称为） as the child process.  The calling process  is  referred  to  as   the   parent process.</span></span><br><span class="line"><span class="comment">       The child process and the parent process run in separate memory spaces（独立的存储空间）.  At the  time  of fork() both memory spaces have the same content（内容. Memory writes, file mappings（映射(mmap(2)),  and  unmappings (munmap(2)) performed（解除映射） by one of the processes do not affect the other.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">       On success, the PID of the child process  is</span></span><br><span class="line"><span class="comment">       returned in the parent, and 0 is returned in</span></span><br><span class="line"><span class="comment">       the child.  On failure, -1  is  returned  in</span></span><br><span class="line"><span class="comment">       the parent, no child process is created, and</span></span><br><span class="line"><span class="comment">       errno is set appropriately（适当地）.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIFE   30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REIGHT 30000200</span></span><br><span class="line"><span class="comment">//多进程计算质数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">for</span>(i = LIFE; i &lt;= REIGHT; i++)&#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                mark = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % j  == <span class="number">0</span>)&#123;</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mark)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//sleep(1000);[1]</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//此处需要进行exit(0)不然子进程也要创建属于它的子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(1000);[2]</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ 30000001 is a primer!</span></span><br><span class="line"><span class="comment">30000037 is a primer!</span></span><br><span class="line"><span class="comment">30000041 is a primer!</span></span><br><span class="line"><span class="comment">30000109 is a primer!</span></span><br><span class="line"><span class="comment">30000023 is a primer!</span></span><br><span class="line"><span class="comment">30000163 is a primer!</span></span><br><span class="line"><span class="comment">30000133 is a primer!</span></span><br><span class="line"><span class="comment">30000193 is a primer!</span></span><br><span class="line"><span class="comment">30000049 is a primer!</span></span><br><span class="line"><span class="comment">30000059 is a primer!</span></span><br><span class="line"><span class="comment">30000083 is a primer!</span></span><br><span class="line"><span class="comment">30000071 is a primer!</span></span><br><span class="line"><span class="comment">30000169 is a primer!</span></span><br><span class="line"><span class="comment">30000079 is a primer!</span></span><br><span class="line"><span class="comment">30000167 is a primer!</span></span><br><span class="line"><span class="comment">30000199 is a primer!</span></span><br><span class="line"><span class="comment">30000137 is a primer!</span></span><br><span class="line"><span class="comment">30000149 is a primer!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">   4467 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4468 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4469 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4470 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4471 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4472 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4473 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">S 指的是可中断的睡眠态  \_ ./process_001 定格说明它的父进程是init进程。这是因为父进程已经执行结束，这些子进程成为孤儿进程，等待子进程sleep（1000）执行结束，由init进程回收资源</span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">   4726 pts/0    S+     0:00  |           \_ ./process_001</span></span><br><span class="line"><span class="comment">   4727 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4728 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4729 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4730 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4731 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Z 指的是僵尸态，僵尸态的进程只占用结构体的内存空间，但它占用这pid，pid是有上限的</span></span><br><span class="line"><span class="comment">sleep（1000）执行结束后，父进程执行exit(0)，子进程将变成孤儿进程，被init进程 1号进程接管</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!\n&quot;</span>);</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        execl(<span class="string">&quot;/bin/date&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;+%s&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//[1] </span></span><br><span class="line">        perror(<span class="string">&quot;execl()&quot;</span>);<span class="comment">//如果execl（）正常执行将跳转到另个程序，不会回来了。执行失败才会继续这行代码。</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);<span class="comment">//[2]</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_003 &gt;text</span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ cat text</span><br><span class="line"><span class="number">1716791563</span></span><br><span class="line">Begin!</span><br><span class="line">End!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       extern char **environ;</span></span><br><span class="line"><span class="comment">       int execl(const char *pathname, const char *arg, ...</span></span><br><span class="line"><span class="comment">                        (char  *) NULL );</span></span><br><span class="line"><span class="comment">       int execlp(const char *file, const char *arg, ...</span></span><br><span class="line"><span class="comment">                        (char  *) NULL );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">execl 是一个系统调用，用于在当前进程中执行另一个程序。它的原型定义如下：</span></span><br><span class="line"><span class="comment">int execl(const char *path, const char *arg, ..., NULL);</span></span><br><span class="line"><span class="comment">path：要执行的程序的路径。</span></span><br><span class="line"><span class="comment">arg：传递给程序的第一个参数（通常是程序名）。</span></span><br><span class="line"><span class="comment">...：后续的参数，直到一个空指针（NULL）为止，表示参数列表的结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">   #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment"> 	   pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment">       pid_t waitpid(pid_t pid, int *wstatus, int options);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       The wait() system call（系统调用） suspends（挂起） execution（执行） of the calling thread（线程） until one of its children terminates（终止）.   The  call  wait(&amp;wstatus)   is equivalent（等同于） to:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           waitpid(-1, &amp;wstatus, 0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The waitpid() system call suspends execution of the calling thread until a  child  specified （规定的） by pid argument（参数） has changed state.  By default（默认情况下）, waitpid() waits only for terminated children,  but  this  behavior（行为） is modifiable（可修改的）via（通过） the options argument, as  described  below（如下所述）.</span></span><br><span class="line"><span class="comment">       The value of pid can be:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       &lt; -1   meaning  wait  for  any child process</span></span><br><span class="line"><span class="comment">              whose process group ID  is  equal  to</span></span><br><span class="line"><span class="comment">              the absolute value of pid.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       -1     meaning wait for any child process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       0      meaning  wait  for  any child process</span></span><br><span class="line"><span class="comment">              whose process group ID  is  equal  to</span></span><br><span class="line"><span class="comment">              that  of  the  calling process at the</span></span><br><span class="line"><span class="comment">              time of the call to waitpid().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       &gt; 0    meaning  wait  for  the  child  whose</span></span><br><span class="line"><span class="comment">              process  ID  is equal to the value of</span></span><br><span class="line"><span class="comment">              pid.</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELIMS  <span class="string">&quot; \t\n&quot;</span><span class="comment">//DELIMS 定义了用于分割输入行的分隔符，这里是空格、制表符和换行符。</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">glob_t</span> globres;<span class="comment">//[1]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prompt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mysell-0.1$ &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">//如果不加这个也可以 因为标准库会在遇到换行符或等待输入前刷新缓冲区，想想曾经写的C语言程序，输入数据前，提示就输出在终端上。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse</span><span class="params">(<span class="type">char</span> *line, <span class="keyword">struct</span> cmd_st *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *tok;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tok = strsep(&amp;line, DELIMS);<span class="comment">//[2]</span></span><br><span class="line">        <span class="keyword">if</span>(tok == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(tok[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        glob(tok, GLOB_NOCHECK|GLOB_APPEND*i, <span class="literal">NULL</span>, &amp;res-&gt;globres);<span class="comment">//[3]</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> linebuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cmd_st</span> <span class="title">cmd</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prompt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getline(&amp;linebuf, &amp;linebuf_size, <span class="built_in">stdin</span>)&lt;<span class="number">0</span>)<span class="comment">//[4]</span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        </span><br><span class="line">        parse(linebuf, &amp;cmd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                execvp(cmd.globres.gl_pathv[<span class="number">0</span>], cmd.globres.gl_pathv);<span class="comment">//[5]</span></span><br><span class="line">                perror(<span class="string">&quot;execvp()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1][3]#include &lt;glob.h&gt;</span></span><br><span class="line"><span class="comment">       int glob(const char *pattern, int flags, int (*errfunc) (const char *epath, int eerrno),    glob_t *pglob);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The glob() function searches for all the pathnames matching(匹配)  pat‐</span></span><br><span class="line"><span class="comment">       tern  according to the rules used by the shell (see glob(7)).  No</span></span><br><span class="line"><span class="comment">       tilde expansion or parameter substitution is done（没有进行波浪展开或参数替换）;  if  you  want</span></span><br><span class="line"><span class="comment">       these, use wordexp(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The results of a glob() call are stored（被存储） in the structure（结构体）  pointed</span></span><br><span class="line"><span class="comment">       to  by  pglob.   This  structure  is  of type glob_t (declared in</span></span><br><span class="line"><span class="comment">       &lt;glob.h&gt;) and includes the following（下列的） elements（元素） defined by  POSIX.2</span></span><br><span class="line"><span class="comment">       (more may be present as an extension):</span></span><br><span class="line"><span class="comment">           typedef struct &#123;</span></span><br><span class="line"><span class="comment">               size_t   gl_pathc;     Count of paths matched so far  到目前为止匹配的路径的计数</span></span><br><span class="line"><span class="comment">               char   **gl_pathv;     List of matched pathnames.  匹配的路径名列表。</span></span><br><span class="line"><span class="comment">               size_t   gl_offs;      Slots（为...空位） to reserve（预留） in gl_pathv.  </span></span><br><span class="line"><span class="comment">           &#125; glob_t;</span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On  successful  completion,  glob() returns zero. </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[2]#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">       char *strsep(char **stringp, const char *delim);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> DESCRIPTION</span></span><br><span class="line"><span class="comment">       If *stringp is NULL, the strsep() function returns NULL and  does</span></span><br><span class="line"><span class="comment">       nothing  else.  Otherwise, this function finds the first token in</span></span><br><span class="line"><span class="comment">       the string *stringp, that is delimited(分隔符) by one of the bytes in the</span></span><br><span class="line"><span class="comment">       string delim（定界符）.  This token is terminated by overwriting the delim‐</span></span><br><span class="line"><span class="comment">       iter with a null byte (&#x27;\0&#x27;), and *stringp is  updated  to  point</span></span><br><span class="line"><span class="comment">       past  the  token.   In  case no delimiter was found, the token is</span></span><br><span class="line"><span class="comment">       taken to be the entire string  *stringp,  and  *stringp  is  made</span></span><br><span class="line"><span class="comment">       NULL.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       The strsep() function returns a pointer to the token, that is, it</span></span><br><span class="line"><span class="comment">       returns the original value of *stringp.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       ssize_t getline(char **lineptr, size_t *n, FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       getline() reads an entire line from stream, storing(存储)  the  address</span></span><br><span class="line"><span class="comment">       of  the  buffer containing the text into *lineptr.  The buffer is</span></span><br><span class="line"><span class="comment">       null-terminated and includes the newline character（换行符）,  if  one  was</span></span><br><span class="line"><span class="comment">       found.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  *lineptr is set to NULL and *n is set 0 before the call, then</span></span><br><span class="line"><span class="comment">       getline() will allocate（分配） a buffer for storing the line.  This buf‐</span></span><br><span class="line"><span class="comment">       fer should be freed by the user program even if getline() failed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Alternatively（或者）,  before  calling getline(), *lineptr can contain a</span></span><br><span class="line"><span class="comment">       pointer to a malloc(3)-allocated buffer *n bytes in size.  If the</span></span><br><span class="line"><span class="comment">       buffer is not large enough to hold the line, getline() resizes it</span></span><br><span class="line"><span class="comment">       with realloc(3), updating *lineptr and *n as necessary.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In either case（无论哪种情况下）, on a successful call, *lineptr and *n will be up‐</span></span><br><span class="line"><span class="comment">       dated  to  reflect（反应）  the buffer address and allocated（分配） size respec‐</span></span><br><span class="line"><span class="comment">       tively（分别地）.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, getline() and getdelim() return the number of charac‐</span></span><br><span class="line"><span class="comment">       ters read, including the delimiter character（分隔符）, but  not  including</span></span><br><span class="line"><span class="comment">       the terminating null byte (&#x27;\0&#x27;).  This value can be used to handle（处理） embedded（嵌入） null bytes in the line read.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Both functions return -1 on failure to  read  a  line  (including</span></span><br><span class="line"><span class="comment">       end-of-file  condition).   In the event of an error, errno is set</span></span><br><span class="line"><span class="comment">       to indicate the cause.       </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[5]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       extern char **environ;</span></span><br><span class="line"><span class="comment">       int execvp(const char *file, char *const argv[]);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>线程的概念</span><br><span class="line">  一个正在运行的函数</span><br><span class="line">  posix线程是一套标准，而不是实现</span><br><span class="line">  openmp线程</span><br><span class="line">  现成标识：<span class="type">pthread_t</span> </span><br><span class="line">  同一进程中的多个线程有各自的调用栈（call <span class="built_in">stack</span>，我们称为线程栈），自己的寄存器环境（<span class="keyword">register</span> context）、自己的线程本地存储（thread-local storage）</span><br><span class="line">    在多线程应用程序中，通常一个进程中包括了多个线程，每个线程都可以参与系统调度、被CPU执行</span><br><span class="line">    线程具有以下一些特点：</span><br><span class="line">		线程不单独存在、而是包含在进程中；</span><br><span class="line">		线程是参与系统调度的基本单位；</span><br><span class="line">		可并发执行。同一进程的多个线程之间可并发执行，在宏观上实现同时运行的效果；</span><br><span class="line">		共享进程资源。同一进程中的各个线程，可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地 址空间），这意味着，线程可以访问该地址空间的每一个虚地址； 此外，还可以访问进程所拥有的已打开文件、定时器、信号量等等。</span><br><span class="line"><span class="number">2.</span>线程的创建</span><br><span class="line">  pthread_creat()</span><br><span class="line">  线程的调度取决于调度器的策略</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>线程的终止</span><br><span class="line">	<span class="number">3</span>种方式：<span class="number">1</span>）线程从启动历程返回，返回值就是线程的退出码</span><br><span class="line">			<span class="number">2</span>）线程可以被同一进程中的其他线程取消</span><br><span class="line">			<span class="number">3</span>）线程调用pthread_exit()函数</span><br><span class="line">	pthread_join --&gt;wait()</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>线程的取消选型</span><br><span class="line">    线程取消：pthread_cancel()</span><br><span class="line">    取消有<span class="number">2</span>种状态：允许和不允许</span><br><span class="line">    允许取消又分为：异步cancel,推迟cancel（默认）-&gt;推迟至cancel点再响应</span><br><span class="line">    cancel点：POSIX定义的cancel点，都是可能引发阻塞的系统调用</span><br><span class="line">    pthread_setcancelstate():设置是否允许取消</span><br><span class="line">    pthread_setcanceltype():设置取消方式</span><br><span class="line">    pthread_testcancel():本函数什么都不做，就是一个取消点 </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup_func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:1&quot;</span>);<span class="comment">//[1]</span></span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:2&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:3&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;push over!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);<span class="comment">//[2]</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//[3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);<span class="comment">//[4]</span></span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);<span class="comment">//[5]</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1][2]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       void pthread_cleanup_push(void (*routine)(void *), void *arg);</span></span><br><span class="line"><span class="comment">       void pthread_cleanup_pop(int execute);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       These functions manipulate(操作) the calling thread&#x27;s stack（栈）  of  thread（线程）-cancellation(取消) clean-up handlers（处理）.  A clean-up handler is a function that is automatically（自动地） executed（处理） when a thread is canceled (or in various other circumstances（在其他情况下）described  below); it might, for example, unlock a mutex（解锁互斥锁） so that it becomes available（可用的） to other threads in the process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The pthread_cleanup_push() function pushes routine（程序）  onto  the  top  of  the</span></span><br><span class="line"><span class="comment">       stack  of  clean-up  handlers.   When  routine is later invoked（当以后调用例程时）, it will be</span></span><br><span class="line"><span class="comment">       given arg as its argument（参数）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The pthread_cleanup_pop() function removes the routine at the  top  of  the</span></span><br><span class="line"><span class="comment">       stack  of  clean-up handlers, and optionally executes it if execute is nonzero.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       void pthread_exit(void *retval);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_exit()  function  terminates  the calling thread and returns a</span></span><br><span class="line"><span class="comment">       value via retval that (if the thread is joinable) is available  to  another</span></span><br><span class="line"><span class="comment">       thread in the same process that calls pthread_join(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Any  clean-up handlers established by pthread_cleanup_push(3) that have not</span></span><br><span class="line"><span class="comment">       yet been popped, are popped (in the reverse of the order in which they were</span></span><br><span class="line"><span class="comment">       pushed)  and  executed.   If the thread has any thread-specific data, then,</span></span><br><span class="line"><span class="comment">       after the clean-up handlers have been executed, the corresponding（相应的）  destructor functions are called, in an unspecified order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       When  a  thread terminates, process-shared resources (e.g., mutexes, condi‐</span></span><br><span class="line"><span class="comment">       tion variables, semaphores, and file descriptors)  are  not  released,  and</span></span><br><span class="line"><span class="comment">       functions registered using atexit(3) are not called.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the last thread in a process terminates, the process terminates as by</span></span><br><span class="line"><span class="comment">       calling exit(3) with an exit status of zero; thus, process-shared resources</span></span><br><span class="line"><span class="comment">       are released and functions registered using atexit(3) are called.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_create(pthread_t *thread, const pthread_attr_t *attr, </span></span><br><span class="line"><span class="comment">                            void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_create()  function starts a new thread in the calling process.</span></span><br><span class="line"><span class="comment">       The new thread starts execution(执行) by invoking start_routine(); arg（自变量） is  passed</span></span><br><span class="line"><span class="comment">       as the sole（唯一） argument of start_routine().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The new thread terminates in one of the following ways:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It  calls pthread_exit(3), specifying（指定） an exit（退出） status value that is available to another thread in the same process that calls pthread_join(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It  returns  from  start_routine().   This  is  equivalent（等同于）   to   calling</span></span><br><span class="line"><span class="comment">         pthread_exit(3) with the value supplied（为...提供） in the return statement.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It is canceled (see pthread_cancel(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * Any  of the threads in the process calls exit(3), or the main thread per‐</span></span><br><span class="line"><span class="comment">         forms a return from main().  This causes the termination of  all  threads</span></span><br><span class="line"><span class="comment">         in the process.</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">        The  attr  argument points to a pthread_attr_t structure whose contents are</span></span><br><span class="line"><span class="comment">       used at thread creation time to determine（确定） attributes（属性） for  the  new  thread;</span></span><br><span class="line"><span class="comment">       this  structure is initialized（初始化） using pthread_attr_init(3) and related functions.  If attr is NULL, then  the  thread  is  created  with  default（默认的）  attributes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Before  returning,  a  successful call to pthread_create() stores（容纳） the ID of</span></span><br><span class="line"><span class="comment">       the new thread in the buffer pointed to by thread; this identifier（标识符） is  used</span></span><br><span class="line"><span class="comment">       to refer to the thread in subsequent（随后） calls to other pthreads functions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  new  thread  inherits（继承）  a  copy  of  the  creating thread&#x27;s signal mask</span></span><br><span class="line"><span class="comment">       (pthread_sigmask(3)).  The set of pending（待处理） signals for  the  new  thread  is</span></span><br><span class="line"><span class="comment">       empty  (sigpending(2)).   The  new  thread  does  not  inherit the creating</span></span><br><span class="line"><span class="comment">       thread&#x27;s alternate signal stack (sigaltstack(2)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The new thread inherits the  calling  thread&#x27;s  floating-point  environment</span></span><br><span class="line"><span class="comment">       (fenv(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The   initial   value  of  the  new  thread&#x27;s  CPU-time  clock  is  0  (see</span></span><br><span class="line"><span class="comment">       pthread_getcpuclockid(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Linux-specific details</span></span><br><span class="line"><span class="comment">       The new thread inherits copies of the calling thread&#x27;s capability sets (see</span></span><br><span class="line"><span class="comment">       capabilities(7)) and CPU affinity mask (see sched_setaffinity(2)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[5]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_join()  function  waits  for the thread specified(指定的) by thread to</span></span><br><span class="line"><span class="comment">       terminate.  If that thread has already terminated, then pthread_join()  returns immediately.  The thread specified by thread must be joinable(可接收的）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  retval（返回值）  is  not NULL, then pthread_join() copies the exit status of the</span></span><br><span class="line"><span class="comment">       target  thread  (i.e.,  the  value  that  the  target  thread  supplied（提供）  to</span></span><br><span class="line"><span class="comment">       pthread_exit(3))  into  the  location  pointed to by retval.  If the target</span></span><br><span class="line"><span class="comment">       thread was canceled,  then  PTHREAD_CANCELED  is  placed  in  the  location</span></span><br><span class="line"><span class="comment">       pointed to by retval.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  multiple（多个的）  threads  simultaneously（同时地） try to join with the same thread, the</span></span><br><span class="line"><span class="comment">       results are undefined（不明确的）.  If the thread calling pthread_join()  is  canceled,</span></span><br><span class="line"><span class="comment">       then  the  target  thread  will  remain  joinable (i.e., it will not be de‐</span></span><br><span class="line"><span class="comment">       tached).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT    30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT   30000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTRNUM  (RIGHT - LEFT +1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line">    <span class="type">pthread_t</span> tid[HTRNUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc() failed!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;n = i;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, p); <span class="comment">//[1]</span></span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT], &amp;ptr);<span class="comment">//[2]</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, mark;</span><br><span class="line">    i = ((<span class="keyword">struct</span> thr_arg_st *)p)-&gt;n;</span><br><span class="line"></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer\n&quot;</span>, i);</span><br><span class="line">    pthread_exit(p);<span class="comment">//[3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">err = pthread_create(tid+(i-LEFT), NULL, thr_prime, p);</span></span><br><span class="line"><span class="comment">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                          void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">pthread_t *thread                          </span></span><br><span class="line"><span class="comment">	这是一个指向 pthread_t 类型变量的指针，用于存储新创建线程的线程ID。</span></span><br><span class="line"><span class="comment">	当 i = LEFT 时，计算结果为 tid[0]，当 i = LEFT + 1 时，结果为 tid[1]，以此类推。这确保了每个线程ID都被存储在 tid 数组的不同位置。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">const pthread_attr_t *attr</span></span><br><span class="line"><span class="comment">	这是一个指向线程属性对象的指针。通过这个参数，你可以指定新线程的属性，例如是否为分离线程、栈大小等</span></span><br><span class="line"><span class="comment">	如果传递 NULL，新线程将使用默认属性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void *(*start_routine) (void *)</span></span><br><span class="line"><span class="comment">	这是一个指向函数的指针，新线程将从该函数开始执行</span></span><br><span class="line"><span class="comment">	thr_prime 是你定义的线程函数，其签名必须匹配 void *(*start_routine) (void *)，即该函数接收一个 void * 类型的参数，并返回一个 void * 类型的结果。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">void *arg</span></span><br><span class="line"><span class="comment">	这是传递给线程函数的参数。它是一个 void * 类型的指针，可以指向任意类型的数据。一般情况下，需要将 arg 指向一个全局或堆变量，意思就是说 在线程的生命周期中，该arg指向的对象必须存在，否则如果线程中访问了该对象将会出现错</span></span><br><span class="line"><span class="comment">误。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">pthread_join(tid[i-LEFT], &amp;ptr);</span></span><br><span class="line"><span class="comment">int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">	void **retval返回的是pthread_create()中 void *arg参数地址</span></span><br><span class="line"><span class="comment">[3]</span></span><br><span class="line"><span class="comment">pthread_exit(p);</span></span><br><span class="line"><span class="comment">void pthread_exit(void *retval);	</span></span><br><span class="line"><span class="comment">	void *retval返回的是在这个进程里参数的地址，void *retval指向一个全局或堆变量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Areslucky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/24/Ubuntu/">http://example.com/2024/04/24/Ubuntu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Areslucky</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/./img/blog004.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="LVGL基础知识"><img class="cover" src="/img/lazyload.gif" data-original="/img/blog006.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LVGL基础知识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/lazyload.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/lazyload.gif'" alt="avatar"/></div><div class="author-info__name">Areslucky</div><div class="author-info__description">我以我心绘风景，风景迷人因我心。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ares629"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记忆是一种相会，遗忘是一种自由。</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/24/Ubuntu/" title="Ubuntu"><img src="/img/lazyload.gif" data-original="/./img/blog004.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu"/></a><div class="content"><a class="title" href="/2024/04/24/Ubuntu/" title="Ubuntu">Ubuntu</a><time datetime="2024-04-24T13:15:59.054Z" title="发表于 2024-04-24 21:15:59">2024-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="LVGL基础知识"><img src="/img/lazyload.gif" data-original="/img/blog006.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LVGL基础知识"/></a><div class="content"><a class="title" href="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="LVGL基础知识">LVGL基础知识</a><time datetime="2024-04-20T07:55:52.020Z" title="发表于 2024-04-20 15:55:52">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="c语言基础知识"><img src="/img/lazyload.gif" data-original="/img/blog001.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言基础知识"/></a><div class="content"><a class="title" href="/2024/04/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="c语言基础知识">c语言基础知识</a><time datetime="2024-04-01T09:30:27.272Z" title="发表于 2024-04-01 17:30:27">2024-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/30/Gcc%E7%BC%96%E8%AF%91%E4%B8%8EGdb%E8%B0%83%E8%AF%95/" title="GCC编译与GDB调试"><img src="/img/lazyload.gif" data-original="/img/blog006.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GCC编译与GDB调试"/></a><div class="content"><a class="title" href="/2024/03/30/Gcc%E7%BC%96%E8%AF%91%E4%B8%8EGdb%E8%B0%83%E8%AF%95/" title="GCC编译与GDB调试">GCC编译与GDB调试</a><time datetime="2024-03-30T03:53:25.442Z" title="发表于 2024-03-30 11:53:25">2024-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/29/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="C++基础知识"><img src="/img/lazyload.gif" data-original="/./img/blog004.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++基础知识"/></a><div class="content"><a class="title" href="/2024/03/29/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="C++基础知识">C++基础知识</a><time datetime="2024-03-29T09:30:37.527Z" title="发表于 2024-03-29 17:30:37">2024-03-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/blog004.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Areslucky</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="lucky,love,endeavor,brave" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>
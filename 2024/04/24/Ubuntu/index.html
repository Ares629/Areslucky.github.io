<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Ubuntu | Areslucky</title><meta name="author" content="Areslucky"><meta name="copyright" content="Areslucky"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="安装ubuntu时，安装界面不全：ctrl+alt+t &#x2F;&#x2F;打开终端: xrandr  &#x2F;&#x2F;查看分辨率: xrandr -s 1920x1080_59.96 &#x2F;&#x2F;选择分辨率  换源#添加阿里源deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.al">
<meta property="og:type" content="article">
<meta property="og:title" content="Ubuntu">
<meta property="og:url" content="http://example.com/2024/04/24/Ubuntu/index.html">
<meta property="og:site_name" content="Areslucky">
<meta property="og:description" content="安装ubuntu时，安装界面不全：ctrl+alt+t &#x2F;&#x2F;打开终端: xrandr  &#x2F;&#x2F;查看分辨率: xrandr -s 1920x1080_59.96 &#x2F;&#x2F;选择分辨率  换源#添加阿里源deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; focal main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.al">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/blog004.jpg">
<meta property="article:published_time" content="2024-04-24T13:15:59.054Z">
<meta property="article:modified_time" content="2024-06-12T10:22:27.539Z">
<meta property="article:author" content="Areslucky">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/blog004.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/04/24/Ubuntu/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: ,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ubuntu',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-06-12 18:22:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Areslucky" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/lazyload.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/lazyload.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 视音</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/blog004.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Areslucky"><span class="site-name">Areslucky</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 视音</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Ubuntu</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-24T13:15:59.054Z" title="发表于 2024-04-24 21:15:59">2024-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-12T10:22:27.539Z" title="更新于 2024-06-12 18:22:27">2024-06-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>86分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Ubuntu"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h5 id="安装ubuntu时，安装界面不全："><a href="#安装ubuntu时，安装界面不全：" class="headerlink" title="安装ubuntu时，安装界面不全："></a>安装ubuntu时，安装界面不全：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctrl+alt+t <span class="comment">//打开终端</span></span><br><span class="line">: xrandr  <span class="comment">//查看分辨率</span></span><br><span class="line">: xrandr -s <span class="number">1920</span>x1080_59<span class="number">.96</span> <span class="comment">//选择分辨率</span></span><br></pre></td></tr></table></figure>

<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加阿里源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>



<h2 id="linux基础命令"><a href="#linux基础命令" class="headerlink" title="linux基础命令"></a>linux基础命令</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*安装c的时候，c依赖b，b又依赖a，这个时候会自动安装a和b</span></span><br><span class="line"><span class="comment">但是，如果c利用了b默认隐含a包的条件，直接调用了a中的api，而下次更新b包的时候，假如b不再依赖a，这个时候autoremove会删掉a包，使c包不可用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">于是当你sudo apt-get remove c 后，autoremove会删除a,b.</span><br><span class="line">sudo apt-get autoremove <span class="comment">//卸载所有自动安装且不再使用的软件包</span></span><br></pre></td></tr></table></figure>

<h2 id="vim-文本文档命令"><a href="#vim-文本文档命令" class="headerlink" title="vim &amp; 文本文档命令"></a>vim &amp; 文本文档命令</h2><h5 id="一般模式下的"><a href="#一般模式下的" class="headerlink" title="一般模式下的"></a>一般模式下的</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + f //向下一页</span><br><span class="line">ctrl + d //向下半页</span><br><span class="line">+ //光标移动到非空格符的下一行，此时需要按住shift 和 =  输出 +</span><br><span class="line">ctrl + b //向上一页</span><br><span class="line">ctrl + u //向上半页</span><br><span class="line">- //光标移动到非空格符的上一行，只需要按住-</span><br><span class="line">n&lt;space&gt; //光标会向右移动这一行的 n 个字符，如果超出这一行的长度会停留在最后一个字符</span><br><span class="line">0 //光标移动到这一行的第一个字符</span><br><span class="line">$ //光标移动到这一行的最后一个字符</span><br><span class="line">H //光标移动到这个屏幕的一个字符</span><br><span class="line">L //光标移动到这个屏幕的最后一个字符</span><br><span class="line">G //光标移动到这个档案的最后</span><br><span class="line">nG //n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</span><br><span class="line">gg //移动到这个档案的第一行</span><br><span class="line">n&lt;Enter&gt; //n 为数字。光标向下移动 n 行</span><br><span class="line">r //替换当前光标所处位置的一个字符</span><br><span class="line">R //从光标处开始替换直到ESC退出替换模式</span><br><span class="line">x //删除当前光标位置的一个字符</span><br><span class="line">X //删除光标前的一个字符</span><br><span class="line"></span><br><span class="line">//替换当前行第一个匹配的字符串</span><br><span class="line">:s/old_string/new_string/</span><br><span class="line">//替换当前行所有匹配的字符串：</span><br><span class="line">:s/old_string/new_string/g</span><br><span class="line">//替换当前文件中所有匹配的字符串</span><br><span class="line">:%s/old_string/new_string/g</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="gcc命令"><a href="#gcc命令" class="headerlink" title="gcc命令"></a>gcc命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc demo.c -E //对文件进行预处理  </span><br></pre></td></tr></table></figure>

<h2 id="eog命令"><a href="#eog命令" class="headerlink" title="eog命令"></a>eog命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eog  //查看图片文件</span><br></pre></td></tr></table></figure>



<h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除空目录，可以使用 rmdir 命令,如果目录不为空，rmdir 将会报错</span><br><span class="line">rmdir directory_name</span><br><span class="line">//删除非空目录,要删除一个包含文件的非空目录，可以使用 rm 命令与 -r 选项（递归删除）</span><br><span class="line">rm -r directory_name</span><br></pre></td></tr></table></figure>

<h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//更改文件名</span><br><span class="line">mv process_001 process_001.c</span><br></pre></td></tr></table></figure>



<h2 id="chmod权限设置"><a href="#chmod权限设置" class="headerlink" title="chmod权限设置"></a>chmod权限设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r（读取）：4</span><br><span class="line">w（写入）：2</span><br><span class="line">x（执行）：1</span><br><span class="line">用户权限：rwx -&gt; 4 + 2 + 1 = 7</span><br><span class="line">组权限：r-x -&gt; 4 + 0 + 1 = 5</span><br><span class="line">其他用户权限：r-x -&gt; 4 + 0 + 1 = 5</span><br><span class="line">755的权限模式表示文件所有者具有读、写、执行权限（7），而组和其他用户只有读和执行权限（5）。</span><br><span class="line">chmod +x hello.sh //为该文件的所有者添加执行权限</span><br><span class="line">chmod g+x hello.sh //为该文件的所属组添加执行权限</span><br><span class="line">chmod o+x hello.sh //为该文件的其他用户添加执行权限</span><br></pre></td></tr></table></figure>

<h2 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h2><ul>
<li><p>**<code>$0</code>**：显示脚本的名称（包含路径）。</p>
</li>
<li><p>**<code>$1</code> 和 <code>$2</code>**：显示传递给脚本的第一个和第二个参数。</p>
</li>
<li><p>**<code>$#</code>**：显示传递给脚本的参数数量。</p>
</li>
<li><p><code>$@</code> 和 <code>$*</code></p>
<p>：显示传递给脚本的所有参数。注意，它们的表现有所不同：</p>
<ul>
<li><code>&quot;$@&quot;</code> 将每个参数作为独立的字符串处理。</li>
<li><code>&quot;$*&quot;</code> 将所有参数作为一个单一的字符串处理。</li>
</ul>
</li>
<li><p>**<code>$?</code>**：显示上一个命令（<code>ls /nonexistent</code>）的退出状态，因为该目录不存在，所以退出状态为 2。</p>
</li>
<li><p>**<code>$$</code>**：显示当前脚本的进程 ID。</p>
</li>
<li><p>**<code>$!</code>**：显示最后一个后台进程的进程 ID（<code>sleep 5 &amp;</code>）</p>
</li>
</ul>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//grep的基本语法 grep [选项] 模式 文件名</span><br><span class="line">grep hello example.txt</span><br><span class="line"></span><br><span class="line">//搜索文件夹下的文件 grep -r pattern folder_name</span><br><span class="line">//搜索文件夹/home/user/documents下所有文件中包含单词&quot;world&quot;的行</span><br><span class="line">grep -r world /home/user/documents</span><br><span class="line"></span><br><span class="line">//搜索的内容不区分大小写 grep -i pattern file</span><br><span class="line">grep -i hello example.txt</span><br><span class="line"></span><br><span class="line">//输出匹配行数  grep -c pattern file</span><br><span class="line">grep -c hello example.txt</span><br><span class="line"></span><br><span class="line">//使用正则表达式进行更复杂的匹配 grep -E &quot;pattern&quot; file</span><br><span class="line">grep -E &quot;[a-zA-Z0-9]+&quot; example.txt</span><br><span class="line"></span><br><span class="line">//将grep输出结果导出到文件</span><br><span class="line">grep &quot;hello&quot; example.txt &gt; output.txt</span><br><span class="line"></span><br><span class="line">//使用grep进行递归搜索 通过使用-r选项，我们可以实现递归搜索。例如，以下命令将在文件夹documents中递归搜索包含字符串&quot;hello&quot;的行：</span><br><span class="line">grep -r &quot;hello&quot; documents</span><br><span class="line"></span><br><span class="line">//使用grep进行多关键词搜索 以下命令在文件example.txt中搜索同时包含&quot;hello&quot;和&quot;world&quot;的行：</span><br><span class="line">grep &quot;hello&quot; example.txt | grep &quot;world&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="管道操作符"><a href="#管道操作符" class="headerlink" title="| 管道操作符"></a>| 管道操作符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令 ./process_001 | wc -l 由两部分组成：一个可执行文件 process_001 和管道操作符 |，以及 wc -l。这个命令的作用是运行 process_001 并统计其输出的行数。</span><br><span class="line">|：管道操作符，用于将前一个命令的输出作为下一个命令的输入。</span><br></pre></td></tr></table></figure>



<h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//sed &#x27;s/原字符串/新字符串/&#x27; 文件名   </span><br><span class="line">sed &#x27;s/hello/world/&#x27; file.txt   //只替换每一行的一个符合的字符串</span><br><span class="line">sed &#x27;s/hello/world/g&#x27; file.txt  //替换每行的所有匹配项</span><br><span class="line"></span><br><span class="line">//使用-i选项可以直接修改文件内容</span><br><span class="line">sed -i &#x27;s/hello/world/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//打印文件file.txt中的第二列</span><br><span class="line">awk &#x27;&#123;print $2&#125;&#x27; file.txt</span><br><span class="line"></span><br><span class="line">//如果文件以逗号分隔，可以使用-F选项指定分隔符</span><br><span class="line">awk -F &#x27;,&#x27; &#x27;&#123;print $2&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean #来声明伪目标,伪目标是一种不与文件系统中的实际文件相关联的目标，它们通常用来执行某些命令，而不是生成某个文件。它的作用1.避免文件名冲突 2.提高执行效率</span></span><br><span class="line"></span><br><span class="line">GCC=gcc <span class="comment">#定义变量</span></span><br><span class="line">EXE=main</span><br><span class="line"><span class="comment">#OBJS=text.o input.o calcu.o</span></span><br><span class="line">RM=rm</span><br><span class="line"><span class="comment">#CFLAGS+=-D_FILE_OFFSET_BITS=64  //预处理器宏定义的正确格式是 -D宏名=值，中间没有空格。CFLAGS 是编译器标志变量，使用 += 可以将新标志追加到现有的 CFLAGS 中</span></span><br><span class="line">SRCS=$&#123;wildcard *.c&#125;  <span class="comment">#*：通配符  wildcard</span></span><br><span class="line">OBJS=$&#123;patsubst %.c, %.o, $&#123;SRCS&#125;&#125; <span class="comment">#%：模式匹配符</span></span><br><span class="line"><span class="section">$&#123;EXE&#125;: $&#123;OBJS&#125;</span></span><br><span class="line">	$&#123;GCC&#125; -o $&#123;EXE&#125; $&#123;OBJS&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	$&#123;GCC&#125; -c <span class="variable">$^</span></span><br><span class="line"><span class="comment">#text.o: text.c</span></span><br><span class="line"><span class="comment">#	$&#123;GCC&#125; -c $^</span></span><br><span class="line"><span class="comment">#input.o: input.c</span></span><br><span class="line"><span class="comment">#	$&#123;GCC&#125; -c $^</span></span><br><span class="line"><span class="comment">#calcu.o: calcu.c</span></span><br><span class="line"><span class="comment">#	$&#123;GCC&#125; -c $^</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	$&#123;RM&#125; $&#123;OBJS&#125;</span><br><span class="line">	$&#123;RM&#125; $&#123;EXE&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">I/O:stdio标准IO  <span class="comment">//FILE类型贯穿始终</span></span><br><span class="line">	sysio系统调用IO(文件IO)</span><br><span class="line">	<span class="comment">//在两种都能用的环境下，优先使用标准IO</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//demo_stdio.c  实现打开关闭文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;demo_file&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen() failed! :%s\n&quot;</span>, strerror(errno));<span class="comment">//[2]</span></span><br><span class="line">        <span class="comment">//perror(&quot;fopen() failed!&quot;); //[3]与上面error相同 但无法使用格式化输出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    fclose(fp);<span class="comment">//[4]谁打开谁关闭</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen() failed! :%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	FILE *fopen(const char *pathname, const char *mode); //const只读，不会改变参数数据。 FILE类型存储在堆上</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">      r      Open text file for reading.  The stream（数据流） is positioned at the be‐</span></span><br><span class="line"><span class="comment">              ginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       r+     Open  for  reading and writing.  The stream is positioned at the</span></span><br><span class="line"><span class="comment">              beginning of the file.</span></span><br><span class="line"><span class="comment">				使用r/r+打开不存在的文件会报错</span></span><br><span class="line"><span class="comment">       w      Truncate（截断） file to zero length or create text  file  for  writing.</span></span><br><span class="line"><span class="comment">              The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       w+     Open  for  reading  and writing.  The file is created if it does</span></span><br><span class="line"><span class="comment">              not exist, otherwise it is truncated.  The stream is  positioned</span></span><br><span class="line"><span class="comment">              at the beginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       a      Open  for  appending (writing at end of file).  The file is cre‐</span></span><br><span class="line"><span class="comment">              ated if it does not exist.  The stream is positioned at the  end</span></span><br><span class="line"><span class="comment">              of the file.</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">[2]#include &lt;stdio,h&gt;</span></span><br><span class="line"><span class="comment">	   extern FILE *stdin;</span></span><br><span class="line"><span class="comment">       extern FILE *stdout;</span></span><br><span class="line"><span class="comment">       extern FILE *stderr;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">	Under  normal circumstances（正常情况） every UNIX program has three streams opened</span></span><br><span class="line"><span class="comment">for it when it starts up, one for input, one for output,  and  one  for</span></span><br><span class="line"><span class="comment">printing diagnostic（诊断提示） or error messages.</span></span><br><span class="line"><span class="comment">	The input stream is referred to as &quot;standard input（标准输入）&quot;; the output  stream</span></span><br><span class="line"><span class="comment">is  referred  to as &quot;standard output&quot;; and the error stream is referred</span></span><br><span class="line"><span class="comment">to as &quot;standard error&quot;.  These terms（术语） are abbreviated（缩写为） to form  the  sym‐</span></span><br><span class="line"><span class="comment">bols used to refer to these files, namely stdin, stdout, and stderr.</span></span><br><span class="line"><span class="comment">	Each  of these symbols is a stdio(3) macro（宏） of type pointer to FILE, and</span></span><br><span class="line"><span class="comment">can be used with functions like fprintf(3) or fread(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	 void perror(const char *s);</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">	 The  perror()  function produces a message on standard error describing</span></span><br><span class="line"><span class="comment">the last error encountered（在...中遇到的） during a call to a system or  library  func‐</span></span><br><span class="line"><span class="comment">tion.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	int fclose(FILE *stream);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">DESCRIPTION:	</span></span><br><span class="line"><span class="comment">	Upon（在...之上）  successful completion（完成）, 0 is returned.  Otherwise（否则）, EOF is returned</span></span><br><span class="line"><span class="comment">and errno is set to indicate the error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo_cp.c 实现文件的cp， </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">	<span class="comment">//判断参数数量</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s open filed! :%s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fclose(fps);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s open filed! :%s\n&quot;</span>, argv[<span class="number">2</span>], strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用fgetc(),fputc()一个一个字符cp</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ch = fgetc(fps);<span class="comment">//[1] ch 如果是char类型 ，可能导致有些字符无法显示</span></span><br><span class="line">        <span class="keyword">if</span>(ch == EOF)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fputc(ch, fpd);<span class="comment">//[2]</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*使用fgets(), fputs()进行BUFFSIZE大小的读写的操作</span></span><br><span class="line"><span class="comment">	#define BUFFSIZE 1024</span></span><br><span class="line"><span class="comment">	char buff[BUFFSIZE];</span></span><br><span class="line"><span class="comment">    while(fgets(buff, BUFFSIZE, fps) != NULL)&#123;    [3]</span></span><br><span class="line"><span class="comment">        fputs(buff, fpd);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*使用fread(),fwrite()进行BUFFSIZE大小的读写操作</span></span><br><span class="line"><span class="comment">	while(fread(buff,1,BUFFSIZE,fps) == BUFFSIZE)&#123; [4]</span></span><br><span class="line"><span class="comment">        fwrite(buff,1,BUFFSIZE,fpd);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fseek(fps, 0, SEEK_END);[5]</span></span><br><span class="line"><span class="comment">    fprintf(stdout, &quot;size:%ld&quot;, ftell(fps));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	int fgetc(FILE *stream);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">	fgetc()  reads  the next character(字符) from stream and returns it as an un‐</span></span><br><span class="line"><span class="comment">signed char cast to an int, or EOF on end of file or error.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">	fgetc(),  getc() and getchar() return the character read as an unsigned char cast to an int or EOF on end of file or error.</span></span><br><span class="line"><span class="comment">[2]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fputc(int c, FILE *stream);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">    fputc() writes the character c, cast to an unsigned char, to stream.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">    fputc(),  putc()  and  putchar() return the character written as an unsigned char cast to(转换类型) an int or EOF on error.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">	char *fgets(char *s, int size, FILE *stream);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">	fgets()  reads in at most one less than size characters（最多读入一个小于size大小的字符串） from stream and stores them into the buffer pointed to by s.  Reading  stops  after  anEOF  or a newline.  If a newline is read, it is stored into the buffer.A terminating null byte (&#x27;\0&#x27;) is stored after the  last  character  inthe buffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">	fgets() returns s on success, and NULL on error or when end of file occurs while no characters have been read.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span></span><br><span class="line"><span class="comment">       size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">	The  function  fread() reads nmemb items(项数) of data, each size bytes long,from the stream pointed to by stream,  storing（存储）  them  at  the  location given by ptr.</span></span><br><span class="line"><span class="comment">    The function fwrite() writes nmemb items of data, each size bytes long,to the stream pointed to by stream, obtaining them  from  the  location given by ptr.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">	On  success,  fread()  and  fwrite() return the number of items read or written.  This number equals the number of bytes transferred only  when size  is 1.  If an error occurs, or the end of the file is reached, the return value is a short item count (or zero).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[5]include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment">       long ftell(FILE *stream);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  fseek()  function  sets the file position indicator(标志) for the stream pointed to by stream.  The new position, measured（测量） in bytes, is obtained（得到）by  adding offset（偏移量） bytes to the position specified（规定的） by whence（到原来的地方）.  If whence is set to SEEK_SET, SEEK_CUR, or SEEK_END, the offset  is  relative  to the  start of the file, the current position indicator, or end-of-file,respectively.  A successful call to the  fseek()  function  clears  the end-of-file  indicator  for  the  stream  and undoes any effects of the ungetc(3) function on the same stream.      </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       The ftell() function obtains the current value of the file position indicator for the stream pointed to by stream.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="标准IO与系统调用IO的区别"><a href="#标准IO与系统调用IO的区别" class="headerlink" title="标准IO与系统调用IO的区别"></a>标准IO与系统调用IO的区别</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">//标准IO [1] </span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>); <span class="comment">//系统调用IO [2]</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">//标准错误流  无缓冲</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;d&quot;</span>); <span class="comment">//标准输出流  行缓冲</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;e\n&quot;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//[3] </span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strace ./main  <span class="comment">//可以查看程序执行过程</span></span><br><span class="line"></span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0x5600efca1000</span></span><br><span class="line">brk(<span class="number">0x5600efcc2000</span>)                     = <span class="number">0x5600efcc2000</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>c)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;ade\n&quot;</span>, <span class="number">4</span>ade</span><br><span class="line">)                    = <span class="number">4</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>a)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>a)                        = <span class="number">1</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双引号用来表示字符串字面量（string literal）。</span></span><br><span class="line"><span class="comment">在大多数编程语言中，双引号内的内容被视为字符串，编译器或解释器会将其解析为字符串类型的数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">单引号用来表示字符字面量（character literal）。</span></span><br><span class="line"><span class="comment">在C语言中，字符值（Character value）的确是用整数类型来表示的，具体来说是使用 int 类型。</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int putchar(int c);</span></span><br><span class="line"><span class="comment">    从函数原型可以看到，参数要求int类型,需要输入&#x27;a&#x27;  而不是&quot;a&quot;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">[2]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">	ssize_t write(int __fd, const void *__buf, size_t __n)</span></span><br><span class="line"><span class="comment">	从函数原型可以看到，参数要求类型,需要输入&quot;b&quot;  &quot;b&quot; 是一个字符串常量，它以 &#x27;\0&#x27; 结尾，or</span></span><br><span class="line"><span class="comment">	char buff = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment">	write(1, &amp;buff, 1);</span></span><br><span class="line"><span class="comment">	以这种第二参数是指针也是可以的.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       int fflush(FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       For  output  streams,  fflush() forces a write of all</span></span><br><span class="line"><span class="comment">       user-space buffered data for the given output or  up‐</span></span><br><span class="line"><span class="comment">       date  stream  via the stream&#x27;s underlying(底层的) write func‐</span></span><br><span class="line"><span class="comment">       tion.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       For input  streams  associated（相关的）  with  seekable（可寻找的）  files</span></span><br><span class="line"><span class="comment">       (e.g.,  disk（磁盘）  files,  but  not  pipes  or terminals（终端）),</span></span><br><span class="line"><span class="comment">       fflush() discards（丢弃） any buffered（缓冲区）  data  that  has  been</span></span><br><span class="line"><span class="comment">       fetched（取出）  from  the  underlying file, but has not been</span></span><br><span class="line"><span class="comment">       consumed（深受影响的） by the application.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The open status of the stream is unaffected（不受影响的）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If the stream argument（参数） is NULL, fflush() flushes  all</span></span><br><span class="line"><span class="comment">       open output streams.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       Upon successful completion 0 is returned.  Otherwise,</span></span><br><span class="line"><span class="comment">       EOF is returned and errno is set to indicate the  error.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -axf命令在类Unix操作系统中用于显示当前正在运行的进程信息。查看进程关系。</span><br><span class="line"></span><br><span class="line">ps -axm 用于显示所有进程以及它们的线程信息</span><br><span class="line"></span><br><span class="line">ps ax -L 用于显示系统中所有进程及其线程的信息</span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_008$ ps ax -L</span><br><span class="line">    PID     LWP TTY      STAT   TIME COMMAND</span><br><span class="line">    PID：进程ID。</span><br><span class="line">    LWP：线程ID（轻量级进程ID）。</span><br><span class="line">    TTY：终端关联信息。</span><br><span class="line">    STAT：进程/线程状态。</span><br><span class="line">    TIME：占用CPU时间。</span><br><span class="line">    COMMAND：启动命令。</span><br><span class="line">    ps：显示活动进程的信息。</span><br><span class="line">    a：显示所有用户的进程。通常，ps只显示当前用户的进程。</span><br><span class="line">    x：显示没有控制终端的进程。</span><br><span class="line">    f：以树状格式显示进程，展示进程之间的层级关系。</span><br><span class="line">    下个进程的PID号其实是根据上个进程里线程的数量而增加的。比如</span><br><span class="line">    449     449 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    449     450 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    449     451 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    594     594 ?        I&lt;     0:00 [cryptd]</span><br><span class="line">    进程号 449-&gt;594 在此期间其他进程中的线程数量增长和消亡</span><br><span class="line">PROCESS STATE CODES</span><br><span class="line">       Here are the different values that the s,</span><br><span class="line">       stat and state output specifiers(详细) (header</span><br><span class="line">       &quot;STAT&quot; or &quot;S&quot;) will display to describe the</span><br><span class="line">       state of a process:</span><br><span class="line"></span><br><span class="line">               D    uninterruptible sleep (usually IO) //不可中断的睡眠态</span><br><span class="line">               I    Idle kernel thread</span><br><span class="line">               R    running or runnable (on run queue)</span><br><span class="line">               S    interruptible sleep (waiting for an event to complete)//可中断的睡眠态</span><br><span class="line">               T    stopped by job control signal</span><br><span class="line">               t    stopped by debugger during the tracing</span><br><span class="line">               W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">               X    dead (should never be seen)</span><br><span class="line">               Z    defunct (&quot;zombie&quot;)（僵尸态） process,terminated but not reaped by its parent</span><br></pre></td></tr></table></figure>

<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">异步事件的处理：查询法， 通知法</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>信号的概念</span><br><span class="line">    信号是软件中断。</span><br><span class="line">    信号的响应依赖于中断。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>signal();</span><br><span class="line"><span class="number">3.</span>信号的不可靠</span><br><span class="line"><span class="number">4.</span>可重入函数</span><br><span class="line"><span class="number">5.</span>信号的响应过程</span><br><span class="line"><span class="number">6.</span>常用函数</span><br><span class="line">    kill();</span><br><span class="line">	raise();</span><br><span class="line">	alarm();</span><br><span class="line">	pause();</span><br><span class="line">	<span class="built_in">abort</span>();</span><br><span class="line">	system();</span><br><span class="line">	sleep();</span><br><span class="line"><span class="number">7.</span>信号集</span><br><span class="line"><span class="number">8.</span>信号屏蔽字/pending集的处理</span><br><span class="line"><span class="number">9.</span>扩展</span><br><span class="line">    sigsuspend();</span><br><span class="line">	sigaction();</span><br><span class="line">	setitimer();</span><br><span class="line"><span class="number">10.</span>实时信号</span><br></pre></td></tr></table></figure>



<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fork();</span></span><br><span class="line"><span class="comment">理解关键字：duplicating，意味着拷贝，克隆，一模一样的含义。</span></span><br><span class="line"><span class="comment">fork后父子进程的区别：fork的返回值不一样，pid不同，ppid也不同，未决信号和文件锁不继承，资源利用量清0；</span></span><br><span class="line"><span class="comment">init进程：1号，是所有进程的祖先进程</span></span><br><span class="line"><span class="comment">调度器的调度策略来决定那个进程先运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process is starting!\n&quot;</span>); <span class="comment">//行缓冲</span></span><br><span class="line">    fflush(<span class="literal">NULL</span>); <span class="comment">//刷新全部缓冲区 [1]</span></span><br><span class="line">    pid = fork(); <span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]子进程 is working!\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] 父进程 is working!\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]//假设代码中没有fflush(NULL);</span></span><br><span class="line"><span class="comment">//输出到标准I0设备上，行缓冲</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_002</span></span><br><span class="line"><span class="comment">process is starting!  //只打印一次</span></span><br><span class="line"><span class="comment">[3507] 父进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment">[3508]子进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//通过重定向，输出到文件中，全缓冲</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_002 &gt; text</span></span><br><span class="line"><span class="comment">process is starting!//打印两次，\n在全缓冲中只是相当于文件的换行</span></span><br><span class="line"><span class="comment">[3574] 父进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment">process is starting!</span></span><br><span class="line"><span class="comment">[3575]子进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">   #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       pid_t fork(void);</span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       fork()  creates a new process by duplicating(克隆) the calling process（当前进程）.  The new process is referred to（被称为） as the child process.  The calling process  is  referred  to  as   the   parent process.</span></span><br><span class="line"><span class="comment">       The child process and the parent process run in separate memory spaces（独立的存储空间）.  At the  time  of fork() both memory spaces have the same content（内容. Memory writes, file mappings（映射(mmap(2)),  and  unmappings (munmap(2)) performed（解除映射） by one of the processes do not affect the other.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">       On success, the PID of the child process  is</span></span><br><span class="line"><span class="comment">       returned in the parent, and 0 is returned in</span></span><br><span class="line"><span class="comment">       the child.  On failure, -1  is  returned  in</span></span><br><span class="line"><span class="comment">       the parent, no child process is created, and</span></span><br><span class="line"><span class="comment">       errno is set appropriately（适当地）.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIFE   30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REIGHT 30000200</span></span><br><span class="line"><span class="comment">//多进程计算质数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">for</span>(i = LIFE; i &lt;= REIGHT; i++)&#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                mark = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % j  == <span class="number">0</span>)&#123;</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mark)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//sleep(1000);[1]</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//此处需要进行exit(0)不然子进程也要创建属于它的子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(1000);[2]</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ 30000001 is a primer!</span></span><br><span class="line"><span class="comment">30000037 is a primer!</span></span><br><span class="line"><span class="comment">30000041 is a primer!</span></span><br><span class="line"><span class="comment">30000109 is a primer!</span></span><br><span class="line"><span class="comment">30000023 is a primer!</span></span><br><span class="line"><span class="comment">30000163 is a primer!</span></span><br><span class="line"><span class="comment">30000133 is a primer!</span></span><br><span class="line"><span class="comment">30000193 is a primer!</span></span><br><span class="line"><span class="comment">30000049 is a primer!</span></span><br><span class="line"><span class="comment">30000059 is a primer!</span></span><br><span class="line"><span class="comment">30000083 is a primer!</span></span><br><span class="line"><span class="comment">30000071 is a primer!</span></span><br><span class="line"><span class="comment">30000169 is a primer!</span></span><br><span class="line"><span class="comment">30000079 is a primer!</span></span><br><span class="line"><span class="comment">30000167 is a primer!</span></span><br><span class="line"><span class="comment">30000199 is a primer!</span></span><br><span class="line"><span class="comment">30000137 is a primer!</span></span><br><span class="line"><span class="comment">30000149 is a primer!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">   4467 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4468 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4469 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4470 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4471 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4472 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4473 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">S 指的是可中断的睡眠态  \_ ./process_001 定格说明它的父进程是init进程。这是因为父进程已经执行结束，这些子进程成为孤儿进程，等待子进程sleep（1000）执行结束，由init进程回收资源</span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">   4726 pts/0    S+     0:00  |           \_ ./process_001</span></span><br><span class="line"><span class="comment">   4727 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4728 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4729 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4730 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4731 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Z 指的是僵尸态，僵尸态的进程只占用结构体的内存空间，但它占用这pid，pid是有上限的</span></span><br><span class="line"><span class="comment">sleep（1000）执行结束后，父进程执行exit(0)，子进程将变成孤儿进程，被init进程 1号进程接管</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!\n&quot;</span>);</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        execl(<span class="string">&quot;/bin/date&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;+%s&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//[1] </span></span><br><span class="line">        perror(<span class="string">&quot;execl()&quot;</span>);<span class="comment">//如果execl（）正常执行将跳转到另个程序，不会回来了。执行失败才会继续这行代码。</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);<span class="comment">//[2]</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_003 &gt;text</span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ cat text</span><br><span class="line"><span class="number">1716791563</span></span><br><span class="line">Begin!</span><br><span class="line">End!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       extern char **environ;</span></span><br><span class="line"><span class="comment">       int execl(const char *pathname, const char *arg, ...</span></span><br><span class="line"><span class="comment">                        (char  *) NULL );</span></span><br><span class="line"><span class="comment">       int execlp(const char *file, const char *arg, ...</span></span><br><span class="line"><span class="comment">                        (char  *) NULL );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">execl 是一个系统调用，用于在当前进程中执行另一个程序。它的原型定义如下：</span></span><br><span class="line"><span class="comment">int execl(const char *path, const char *arg, ..., NULL);</span></span><br><span class="line"><span class="comment">path：要执行的程序的路径。</span></span><br><span class="line"><span class="comment">arg：传递给程序的第一个参数（通常是程序名）。</span></span><br><span class="line"><span class="comment">...：后续的参数，直到一个空指针（NULL）为止，表示参数列表的结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">   #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment"> 	   pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment">       pid_t waitpid(pid_t pid, int *wstatus, int options);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       The wait() system call（系统调用） suspends（挂起） execution（执行） of the calling thread（线程） until one of its children terminates（终止）.   The  call  wait(&amp;wstatus)   is equivalent（等同于） to:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           waitpid(-1, &amp;wstatus, 0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The waitpid() system call suspends execution of the calling thread until a  child  specified （规定的） by pid argument（参数） has changed state.  By default（默认情况下）, waitpid() waits only for terminated children,  but  this  behavior（行为） is modifiable（可修改的）via（通过） the options argument, as  described  below（如下所述）.</span></span><br><span class="line"><span class="comment">       The value of pid can be:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       &lt; -1   meaning  wait  for  any child process</span></span><br><span class="line"><span class="comment">              whose process group ID  is  equal  to</span></span><br><span class="line"><span class="comment">              the absolute value of pid.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       -1     meaning wait for any child process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       0      meaning  wait  for  any child process</span></span><br><span class="line"><span class="comment">              whose process group ID  is  equal  to</span></span><br><span class="line"><span class="comment">              that  of  the  calling process at the</span></span><br><span class="line"><span class="comment">              time of the call to waitpid().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       &gt; 0    meaning  wait  for  the  child  whose</span></span><br><span class="line"><span class="comment">              process  ID  is equal to the value of</span></span><br><span class="line"><span class="comment">              pid.</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELIMS  <span class="string">&quot; \t\n&quot;</span><span class="comment">//DELIMS 定义了用于分割输入行的分隔符，这里是空格、制表符和换行符。</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">glob_t</span> globres;<span class="comment">//[1]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prompt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mysell-0.1$ &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">//如果不加这个也可以 因为标准库会在遇到换行符或等待输入前刷新缓冲区，想想曾经写的C语言程序，输入数据前，提示就输出在终端上。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse</span><span class="params">(<span class="type">char</span> *line, <span class="keyword">struct</span> cmd_st *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *tok;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tok = strsep(&amp;line, DELIMS);<span class="comment">//[2]</span></span><br><span class="line">        <span class="keyword">if</span>(tok == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(tok[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        glob(tok, GLOB_NOCHECK|GLOB_APPEND*i, <span class="literal">NULL</span>, &amp;res-&gt;globres);<span class="comment">//[3]</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> linebuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cmd_st</span> <span class="title">cmd</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prompt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getline(&amp;linebuf, &amp;linebuf_size, <span class="built_in">stdin</span>)&lt;<span class="number">0</span>)<span class="comment">//[4]</span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        </span><br><span class="line">        parse(linebuf, &amp;cmd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                execvp(cmd.globres.gl_pathv[<span class="number">0</span>], cmd.globres.gl_pathv);<span class="comment">//[5]</span></span><br><span class="line">                perror(<span class="string">&quot;execvp()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1][3]#include &lt;glob.h&gt;</span></span><br><span class="line"><span class="comment">       int glob(const char *pattern, int flags, int (*errfunc) (const char *epath, int eerrno),    glob_t *pglob);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The glob() function searches for all the pathnames matching(匹配)  pat‐</span></span><br><span class="line"><span class="comment">       tern  according to the rules used by the shell (see glob(7)).  No</span></span><br><span class="line"><span class="comment">       tilde expansion or parameter substitution is done（没有进行波浪展开或参数替换）;  if  you  want</span></span><br><span class="line"><span class="comment">       these, use wordexp(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The results of a glob() call are stored（被存储） in the structure（结构体）  pointed</span></span><br><span class="line"><span class="comment">       to  by  pglob.   This  structure  is  of type glob_t (declared in</span></span><br><span class="line"><span class="comment">       &lt;glob.h&gt;) and includes the following（下列的） elements（元素） defined by  POSIX.2</span></span><br><span class="line"><span class="comment">       (more may be present as an extension):</span></span><br><span class="line"><span class="comment">           typedef struct &#123;</span></span><br><span class="line"><span class="comment">               size_t   gl_pathc;     Count of paths matched so far  到目前为止匹配的路径的计数</span></span><br><span class="line"><span class="comment">               char   **gl_pathv;     List of matched pathnames.  匹配的路径名列表。</span></span><br><span class="line"><span class="comment">               size_t   gl_offs;      Slots（为...空位） to reserve（预留） in gl_pathv.  </span></span><br><span class="line"><span class="comment">           &#125; glob_t;</span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On  successful  completion,  glob() returns zero. </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[2]#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">       char *strsep(char **stringp, const char *delim);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> DESCRIPTION</span></span><br><span class="line"><span class="comment">       If *stringp is NULL, the strsep() function returns NULL and  does</span></span><br><span class="line"><span class="comment">       nothing  else.  Otherwise, this function finds the first token in</span></span><br><span class="line"><span class="comment">       the string *stringp, that is delimited(分隔符) by one of the bytes in the</span></span><br><span class="line"><span class="comment">       string delim（定界符）.  This token is terminated by overwriting the delim‐</span></span><br><span class="line"><span class="comment">       iter with a null byte (&#x27;\0&#x27;), and *stringp is  updated  to  point</span></span><br><span class="line"><span class="comment">       past  the  token.   In  case no delimiter was found, the token is</span></span><br><span class="line"><span class="comment">       taken to be the entire string  *stringp,  and  *stringp  is  made</span></span><br><span class="line"><span class="comment">       NULL.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       The strsep() function returns a pointer to the token, that is, it</span></span><br><span class="line"><span class="comment">       returns the original value of *stringp.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       ssize_t getline(char **lineptr, size_t *n, FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       getline() reads an entire line from stream, storing(存储)  the  address</span></span><br><span class="line"><span class="comment">       of  the  buffer containing the text into *lineptr.  The buffer is</span></span><br><span class="line"><span class="comment">       null-terminated and includes the newline character（换行符）,  if  one  was</span></span><br><span class="line"><span class="comment">       found.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  *lineptr is set to NULL and *n is set 0 before the call, then</span></span><br><span class="line"><span class="comment">       getline() will allocate（分配） a buffer for storing the line.  This buf‐</span></span><br><span class="line"><span class="comment">       fer should be freed by the user program even if getline() failed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Alternatively（或者）,  before  calling getline(), *lineptr can contain a</span></span><br><span class="line"><span class="comment">       pointer to a malloc(3)-allocated buffer *n bytes in size.  If the</span></span><br><span class="line"><span class="comment">       buffer is not large enough to hold the line, getline() resizes it</span></span><br><span class="line"><span class="comment">       with realloc(3), updating *lineptr and *n as necessary.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In either case（无论哪种情况下）, on a successful call, *lineptr and *n will be up‐</span></span><br><span class="line"><span class="comment">       dated  to  reflect（反应）  the buffer address and allocated（分配） size respec‐</span></span><br><span class="line"><span class="comment">       tively（分别地）.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, getline() and getdelim() return the number of charac‐</span></span><br><span class="line"><span class="comment">       ters read, including the delimiter character（分隔符）, but  not  including</span></span><br><span class="line"><span class="comment">       the terminating null byte (&#x27;\0&#x27;).  This value can be used to handle（处理） embedded（嵌入） null bytes in the line read.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Both functions return -1 on failure to  read  a  line  (including</span></span><br><span class="line"><span class="comment">       end-of-file  condition).   In the event of an error, errno is set</span></span><br><span class="line"><span class="comment">       to indicate the cause.       </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[5]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       extern char **environ;</span></span><br><span class="line"><span class="comment">       int execvp(const char *file, char *const argv[]);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo ufw disable <span class="comment">//关闭防火墙</span></span><br><span class="line">sudo ufw allow <span class="number">1989</span>/udp <span class="comment">//设置端口白名单</span></span><br></pre></td></tr></table></figure>





<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>线程的概念</span><br><span class="line">  一个正在运行的函数</span><br><span class="line">  posix线程是一套标准，而不是实现</span><br><span class="line">  openmp线程</span><br><span class="line">  现成标识：<span class="type">pthread_t</span> </span><br><span class="line">  同一进程中的多个线程有各自的调用栈（call <span class="built_in">stack</span>，我们称为线程栈），自己的寄存器环境（<span class="keyword">register</span> context）、自己的线程本地存储（thread-local storage）</span><br><span class="line">    在多线程应用程序中，通常一个进程中包括了多个线程，每个线程都可以参与系统调度、被CPU执行</span><br><span class="line">    线程具有以下一些特点：</span><br><span class="line">		线程不单独存在、而是包含在进程中；</span><br><span class="line">		线程是参与系统调度的基本单位；</span><br><span class="line">		可并发执行。同一进程的多个线程之间可并发执行，在宏观上实现同时运行的效果；</span><br><span class="line">		共享进程资源。同一进程中的各个线程，可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地 址空间），这意味着，线程可以访问该地址空间的每一个虚地址； 此外，还可以访问进程所拥有的已打开文件、定时器、信号量等等。</span><br><span class="line"><span class="number">2.</span>线程的创建</span><br><span class="line">  pthread_creat()</span><br><span class="line">  线程的调度取决于调度器的策略</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>线程的终止</span><br><span class="line">	<span class="number">3</span>种方式：<span class="number">1</span>）线程从启动历程返回，返回值就是线程的退出码</span><br><span class="line">			<span class="number">2</span>）线程可以被同一进程中的其他线程取消</span><br><span class="line">			<span class="number">3</span>）线程调用pthread_exit()函数</span><br><span class="line">	pthread_join --&gt;wait()</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>线程的取消选型</span><br><span class="line">    线程取消：pthread_cancel()</span><br><span class="line">    取消有<span class="number">2</span>种状态：允许和不允许</span><br><span class="line">    允许取消又分为：异步cancel,推迟cancel（默认）-&gt;推迟至cancel点再响应</span><br><span class="line">    cancel点：POSIX定义的cancel点，都是可能引发阻塞的系统调用</span><br><span class="line">    pthread_setcancelstate():设置是否允许取消</span><br><span class="line">    pthread_setcanceltype():设置取消方式</span><br><span class="line">    pthread_testcancel():本函数什么都不做，就是一个取消点 </span><br><span class="line">	</span><br><span class="line"><span class="number">5.</span>线程分离</span><br><span class="line">    pthread_detach();</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>线程同步</span><br><span class="line">    互斥量：<span class="type">pthread_mutex_t</span></span><br><span class="line">    	   <span class="title function_">pthread_mutex_init</span><span class="params">()</span>;</span><br><span class="line">		   pthread_mutex_destroy();</span><br><span class="line">		   pthread_mutex_lock();</span><br><span class="line">		   pthread_mutex_trylock();</span><br><span class="line">		   pthread_mutex_nulock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup_func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:1&quot;</span>);<span class="comment">//[1]</span></span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:2&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:3&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;push over!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);<span class="comment">//[2]</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//[3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);<span class="comment">//[4]</span></span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);<span class="comment">//[5]</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1][2]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       void pthread_cleanup_push(void (*routine)(void *), void *arg);</span></span><br><span class="line"><span class="comment">       void pthread_cleanup_pop(int execute);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       These functions manipulate(操作) the calling thread&#x27;s stack（栈）  of  thread（线程）-cancellation(取消) clean-up handlers（处理）.  A clean-up handler is a function that is automatically（自动地） executed（处理） when a thread is canceled (or in various other circumstances（在其他情况下）described  below); it might, for example, unlock a mutex（解锁互斥锁） so that it becomes available（可用的） to other threads in the process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The pthread_cleanup_push() function pushes routine（程序）  onto  the  top  of  the</span></span><br><span class="line"><span class="comment">       stack  of  clean-up  handlers.   When  routine is later invoked（当以后调用例程时）, it will be</span></span><br><span class="line"><span class="comment">       given arg as its argument（参数）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The pthread_cleanup_pop() function removes the routine at the  top  of  the</span></span><br><span class="line"><span class="comment">       stack  of  clean-up handlers, and optionally executes it if execute is nonzero.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       void pthread_exit(void *retval);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_exit()  function  terminates  the calling thread and returns a</span></span><br><span class="line"><span class="comment">       value via retval that (if the thread is joinable) is available  to  another</span></span><br><span class="line"><span class="comment">       thread in the same process that calls pthread_join(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Any  clean-up handlers established by pthread_cleanup_push(3) that have not</span></span><br><span class="line"><span class="comment">       yet been popped, are popped (in the reverse of the order in which they were</span></span><br><span class="line"><span class="comment">       pushed)  and  executed.   If the thread has any thread-specific data, then,</span></span><br><span class="line"><span class="comment">       after the clean-up handlers have been executed, the corresponding（相应的）  destructor functions are called, in an unspecified order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       When  a  thread terminates, process-shared resources (e.g., mutexes, condi‐</span></span><br><span class="line"><span class="comment">       tion variables, semaphores, and file descriptors)  are  not  released,  and</span></span><br><span class="line"><span class="comment">       functions registered using atexit(3) are not called.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the last thread in a process terminates, the process terminates as by</span></span><br><span class="line"><span class="comment">       calling exit(3) with an exit status of zero; thus, process-shared resources</span></span><br><span class="line"><span class="comment">       are released and functions registered using atexit(3) are called.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_create(pthread_t *thread, const pthread_attr_t *attr, </span></span><br><span class="line"><span class="comment">                            void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_create()  function starts a new thread in the calling process.</span></span><br><span class="line"><span class="comment">       The new thread starts execution(执行) by invoking start_routine(); arg（自变量） is  passed</span></span><br><span class="line"><span class="comment">       as the sole（唯一） argument of start_routine().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The new thread terminates in one of the following ways:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It  calls pthread_exit(3), specifying（指定） an exit（退出） status value that is available to another thread in the same process that calls pthread_join(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It  returns  from  start_routine().   This  is  equivalent（等同于）   to   calling</span></span><br><span class="line"><span class="comment">         pthread_exit(3) with the value supplied（为...提供） in the return statement.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It is canceled (see pthread_cancel(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * Any  of the threads in the process calls exit(3), or the main thread per‐</span></span><br><span class="line"><span class="comment">         forms a return from main().  This causes the termination of  all  threads</span></span><br><span class="line"><span class="comment">         in the process.</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">        The  attr  argument points to a pthread_attr_t structure whose contents are</span></span><br><span class="line"><span class="comment">       used at thread creation time to determine（确定） attributes（属性） for  the  new  thread;</span></span><br><span class="line"><span class="comment">       this  structure is initialized（初始化） using pthread_attr_init(3) and related functions.  If attr is NULL, then  the  thread  is  created  with  default（默认的）  attributes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Before  returning,  a  successful call to pthread_create() stores（容纳） the ID of</span></span><br><span class="line"><span class="comment">       the new thread in the buffer pointed to by thread; this identifier（标识符） is  used</span></span><br><span class="line"><span class="comment">       to refer to the thread in subsequent（随后） calls to other pthreads functions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  new  thread  inherits（继承）  a  copy  of  the  creating thread&#x27;s signal mask</span></span><br><span class="line"><span class="comment">       (pthread_sigmask(3)).  The set of pending（待处理） signals for  the  new  thread  is</span></span><br><span class="line"><span class="comment">       empty  (sigpending(2)).   The  new  thread  does  not  inherit the creating</span></span><br><span class="line"><span class="comment">       thread&#x27;s alternate signal stack (sigaltstack(2)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The new thread inherits the  calling  thread&#x27;s  floating-point  environment</span></span><br><span class="line"><span class="comment">       (fenv(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The   initial   value  of  the  new  thread&#x27;s  CPU-time  clock  is  0  (see</span></span><br><span class="line"><span class="comment">       pthread_getcpuclockid(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Linux-specific details</span></span><br><span class="line"><span class="comment">       The new thread inherits copies of the calling thread&#x27;s capability sets (see</span></span><br><span class="line"><span class="comment">       capabilities(7)) and CPU affinity mask (see sched_setaffinity(2)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[5]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_join()  function  waits  for the thread specified(指定的) by thread to</span></span><br><span class="line"><span class="comment">       terminate.  If that thread has already terminated, then pthread_join()  returns immediately.  The thread specified by thread must be joinable(可接收的）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  retval（返回值）  is  not NULL, then pthread_join() copies the exit status of the</span></span><br><span class="line"><span class="comment">       target  thread  (i.e.,  the  value  that  the  target  thread  supplied（提供）  to</span></span><br><span class="line"><span class="comment">       pthread_exit(3))  into  the  location  pointed to by retval.  If the target</span></span><br><span class="line"><span class="comment">       thread was canceled,  then  PTHREAD_CANCELED  is  placed  in  the  location</span></span><br><span class="line"><span class="comment">       pointed to by retval.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  multiple（多个的）  threads  simultaneously（同时地） try to join with the same thread, the</span></span><br><span class="line"><span class="comment">       results are undefined（不明确的）.  If the thread calling pthread_join()  is  canceled,</span></span><br><span class="line"><span class="comment">       then  the  target  thread  will  remain  joinable (i.e., it will not be de‐</span></span><br><span class="line"><span class="comment">       tached).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT    30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT   30000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTRNUM  (RIGHT - LEFT +1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line">    <span class="type">pthread_t</span> tid[HTRNUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc() failed!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;n = i;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, p); <span class="comment">//[1]</span></span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT], &amp;ptr);<span class="comment">//[2]</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, mark;</span><br><span class="line">    i = ((<span class="keyword">struct</span> thr_arg_st *)p)-&gt;n;</span><br><span class="line"></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer\n&quot;</span>, i);</span><br><span class="line">    pthread_exit(p);<span class="comment">//[3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">err = pthread_create(tid+(i-LEFT), NULL, thr_prime, p);</span></span><br><span class="line"><span class="comment">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                          void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">pthread_t *thread                          </span></span><br><span class="line"><span class="comment">	这是一个指向 pthread_t 类型变量的指针，用于存储新创建线程的线程ID。</span></span><br><span class="line"><span class="comment">	当 i = LEFT 时，计算结果为 tid[0]，当 i = LEFT + 1 时，结果为 tid[1]，以此类推。这确保了每个线程ID都被存储在 tid 数组的不同位置。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">const pthread_attr_t *attr</span></span><br><span class="line"><span class="comment">	这是一个指向线程属性对象的指针。通过这个参数，你可以指定新线程的属性，例如是否为分离线程、栈大小等</span></span><br><span class="line"><span class="comment">	如果传递 NULL，新线程将使用默认属性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void *(*start_routine) (void *)</span></span><br><span class="line"><span class="comment">	这是一个指向函数的指针，新线程将从该函数开始执行</span></span><br><span class="line"><span class="comment">	thr_prime 是你定义的线程函数，其签名必须匹配 void *(*start_routine) (void *)，即该函数接收一个 void * 类型的参数，并返回一个 void * 类型的结果。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">void *arg</span></span><br><span class="line"><span class="comment">	这是传递给线程函数的参数。它是一个 void * 类型的指针，可以指向任意类型的数据。一般情况下，需要将 arg 指向一个全局或堆变量，意思就是说 在线程的生命周期中，该arg指向的对象必须存在，否则如果线程中访问了该对象将会出现错</span></span><br><span class="line"><span class="comment">误。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">pthread_join(tid[i-LEFT], &amp;ptr);</span></span><br><span class="line"><span class="comment">int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">	void **retval返回的是pthread_create()中 void *arg参数地址</span></span><br><span class="line"><span class="comment">[3]</span></span><br><span class="line"><span class="comment">pthread_exit(p);</span></span><br><span class="line"><span class="comment">void pthread_exit(void *retval);	</span></span><br><span class="line"><span class="comment">	void *retval返回的是在这个进程里参数的地址，void *retval指向一个全局或堆变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM  4</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mut[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n + <span class="number">1</span> == THRNUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)p;</span><br><span class="line">    <span class="type">int</span> c = <span class="string">&#x27;a&#x27;</span> + (<span class="type">int</span>)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mut+n);<span class="comment">//[1]</span></span><br><span class="line">        write(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        pthread_mutex_unlock(mut+next(n));<span class="comment">//[2]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err, i;</span><br><span class="line">    <span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mut+i, <span class="literal">NULL</span>);<span class="comment">//[3]</span></span><br><span class="line">        pthread_mutex_lock(mut+i);</span><br><span class="line"></span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_func, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(mut+<span class="number">0</span>);</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$sudo apt-get install manpages-posix manpages-posix-dev</span></span><br><span class="line"><span class="comment">获取posix手册</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[1][2]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">       int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       The mutex（互斥） object referenced by mutex shall be locked（将会被锁定） by a call</span></span><br><span class="line"><span class="comment">       to pthread_mutex_lock() that returns zero or [EOWNERDEAD].  If</span></span><br><span class="line"><span class="comment">       the  mutex  is  already  locked by another thread, the calling</span></span><br><span class="line"><span class="comment">       thread shall block（阻塞） until the mutex becomes available. This operation（操作） shall return with the mutex object referenced by mutex in the locked state with the calling thread as its owner. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       If  successful,  the  pthread_mutex_lock(), pthread_mutex_try‐</span></span><br><span class="line"><span class="comment">       lock(),  and  pthread_mutex_unlock()  functions  shall  return</span></span><br><span class="line"><span class="comment">       zero; otherwise, an error number shall be returned to indicate</span></span><br><span class="line"><span class="comment">       the error.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[3]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span></span><br><span class="line"><span class="comment">       							const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">       pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       pthread_mutex_t log_lock; //直接使用，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    由于是全局变量，编译后结构体成员默认值为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pthread_mutex_t log_lock = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这个宏实际定义为</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # define PTHREAD_MUTEX_INITIALIZER  &#123; &#123; 0, 0, 0, 0, 0, 0, &#123; 0, 0 &#125; &#125; &#125; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这个初始化函数没有仔细追代码，猜想也是初始化成员为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT    30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT   30000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM  4</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line">    <span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)<span class="comment">//创建线程，此时都等待线程池的数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=LEFT; i&lt;=RIGHT; i++)<span class="comment">//开始向线程池抛数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);<span class="comment">//先上锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)<span class="comment">//！= 说明其他线程还没处理num，又被主线程抢到了，这是要告诉调度代码让出内核</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        num = i;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);<span class="comment">//解锁， 线程开抢</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, mark;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);<span class="comment">//多线程编程中，当一个线程在执行 pthread_mutex_lock(&amp;mut_num); 时，如果互斥锁 mut_num 已经被其他线程持有，该线程会被阻塞，直到获取到互斥锁为止。</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>; j&lt;i/<span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d]:%d is a primer\n&quot;</span>, (<span class="type">int</span>)p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************proto.h***********************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPATH <span class="string">&quot;/etc/services&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPROJ <span class="string">&#x27;g&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//************************snder.c***********************************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">   </span><br><span class="line">    key = ftok(KEYPATH, KEYPROJ);<span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key, <span class="number">0</span>);<span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sbuf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name, <span class="string">&quot;Alan&quot;</span>);<span class="comment">//[3]</span></span><br><span class="line">    sbuf.math = rand()%<span class="number">100</span>;<span class="comment">//[4]</span></span><br><span class="line">    sbuf.chinese = rand()%<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(msgsnd(msgid, &amp;sbuf, <span class="keyword">sizeof</span>(sbuf)-<span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>) &lt; <span class="number">0</span>)<span class="comment">//[5]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsnd()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//************************rcver.c***********************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    key = ftok(KEYPATH, KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key, IPC_CREAT|<span class="number">0600</span>);<span class="comment">//[6]</span></span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid, &amp;rbuf, <span class="keyword">sizeof</span>(rbuf)-<span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgrcv()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NAME = %s\n&quot;</span>, rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MATH = %d\n&quot;</span>, rbuf.math);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CHINESE = %d\n&quot;</span>, rbuf.chinese);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);<span class="comment">//[7]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先运行被动端（rcver.c），因为msgget（）在rcver.c创建，也在此文件销毁，遵循谁创建谁销毁的原则。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[1]#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">       key_t ftok(const char *pathname, int proj_id);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">NAME：</span></span><br><span class="line"><span class="comment">       ftok  -  convert(转换) a pathname and a project identifier（标识） to a System V</span></span><br><span class="line"><span class="comment">       IPC key</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       The ftok() function uses the identity of the  file  named  by  the</span></span><br><span class="line"><span class="comment">       given  pathname (which must refer to an existing, accessible（可使用的） file)</span></span><br><span class="line"><span class="comment">       and the least significant（相当数量） 8 bits of proj_id (which  must  be  non‐</span></span><br><span class="line"><span class="comment">       zero)  to generate（生成） a key_t type System V IPC key, suitable（合适的） for use</span></span><br><span class="line"><span class="comment">       with msgget(2), semget(2), or shmget(2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The resulting value is the same for all pathnames  that  name  the</span></span><br><span class="line"><span class="comment">       same  file, when the same value of proj_id is used.  The value returned should be  different  when  the  (simultaneously（同时地）  existing)files or the project IDs differ.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       On  success, the generated key_t value is returned.  On failure -1</span></span><br><span class="line"><span class="comment">       is returned, with errno indicating the error as  for  the  stat(2)</span></span><br><span class="line"><span class="comment">       system call.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">NAME:</span></span><br><span class="line"><span class="comment">       msgget - get a System V message queue identifier</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS:</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int msgget(key_t key, int msgflg);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       The  msgget() system call returns the System V message queue identifier associated with the value of the key argument.  It  may  be used  either to obtain（获得） the identifier of a previously(先前的) created message queue (when msgflg is zero and key does not  have  the  value IPC_PRIVATE), or to create a new set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       A new message queue is created if key has the value IPC_PRIVATE or</span></span><br><span class="line"><span class="comment">       key isn&#x27;t IPC_PRIVATE, no message queue with the given key key exists, and IPC_CREAT is specified（指定） in msgflg.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  msgflg  specifies  both  IPC_CREAT  and IPC_EXCL and a message</span></span><br><span class="line"><span class="comment">       queue already exists for key, then msgget() fails with  errno  set</span></span><br><span class="line"><span class="comment">       to  EEXIST.   (This  is analogous（类似的） to the effect of the combination</span></span><br><span class="line"><span class="comment">       O_CREAT | O_EXCL for open(2).)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Upon creation（在创建时）, the least significant bits of the  argument  msgflg</span></span><br><span class="line"><span class="comment">       define  the  permissions（权限）  of  the message queue.  These permission</span></span><br><span class="line"><span class="comment">       bits have the same format（格式） and semantics（语义） as the permissions  specified  for  the mode argument of open(2).  (The execute（执行） permissions are not used.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If a new message queue is created, then its associated（有关联） data structure msqid_ds (see msgctl(2)) is initialized（初始化） as follows:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_perm.cuid  and  msg_perm.uid  are  set to the effective</span></span><br><span class="line"><span class="comment">              user ID of the calling process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_perm.cgid and msg_perm.gid are  set  to  the  effective</span></span><br><span class="line"><span class="comment">              group ID of the calling process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              The  least  significant  9 bits of msg_perm.mode are set to</span></span><br><span class="line"><span class="comment">              the least significant 9 bits of msgflg.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_qnum, msg_lspid, msg_lrpid,  msg_stime,  and  msg_rtime</span></span><br><span class="line"><span class="comment">              are set to 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_ctime is set to the current time.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_qbytes is set to the system limit MSGMNB.</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">       If  the message queue already exists the permissions are verified（核实）,</span></span><br><span class="line"><span class="comment">       and a check is made to see if it is marked（标记） for destruction（销毁）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       If successful, the return value will be the message queue  identifier  (a  nonnegative（非负的） integer), otherwise -1 with errno indicating the error.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[3]</span></span><br><span class="line"><span class="comment">NAME:</span></span><br><span class="line"><span class="comment">       strcpy, strncpy - copy a string</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS:</span></span><br><span class="line"><span class="comment">       #include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">       char *strcpy(char *dest, const char *src);</span></span><br><span class="line"><span class="comment">       char *strncpy(char *dest, const char *src, size_t n);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       The strcpy() function copies the string pointed to by src, includ‐</span></span><br><span class="line"><span class="comment">       ing the terminating null byte (&#x27;\0&#x27;), to the buffer pointed to  by</span></span><br><span class="line"><span class="comment">       dest(对像）.   The  strings  may  not overlap（重叠）, and the destination（目标） string</span></span><br><span class="line"><span class="comment">       dest must be large enough to receive the copy.  Beware（当心）  of  buffer</span></span><br><span class="line"><span class="comment">       overruns!  (See BUGS.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  strncpy() function is similar, except that at most n bytes of</span></span><br><span class="line"><span class="comment">       src are copied.  Warning: If there is no null byte among the first</span></span><br><span class="line"><span class="comment">       n  bytes of src, the string placed in dest will not be null-termi‐</span></span><br><span class="line"><span class="comment">       nated.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[4]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       openssl-rand, rand - generate pseudo(假的）-random bytes</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       This command（命令） generates num random bytes using a cryptographically（秘密地）</span></span><br><span class="line"><span class="comment">       secure（安全的） pseudo random number generator (CSPRNG).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The random bytes are generated using the RAND_bytes(3) function,</span></span><br><span class="line"><span class="comment">       which provides a security level of 256 bits, provided it managed（管理）</span></span><br><span class="line"><span class="comment">       to seed itself successfully from a trusted（可靠的） operating（操作） system</span></span><br><span class="line"><span class="comment">       entropy source.  Otherwise, the command will fail with a nonzero</span></span><br><span class="line"><span class="comment">       error code.  For more details, see RAND_bytes(3), RAND(7), and</span></span><br><span class="line"><span class="comment">       RAND_DRBG(7).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[5]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       msgrcv, msgsnd - System V message queue operations</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,</span></span><br><span class="line"><span class="comment">                      int msgflg);</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  msgsnd()  and msgrcv() system calls are used to send messages</span></span><br><span class="line"><span class="comment">       to, and receive messages from,  a  System V  message  queue.   The</span></span><br><span class="line"><span class="comment">       calling process must have write permission on the message queue in</span></span><br><span class="line"><span class="comment">       order to send a message, and read permission to receive a message.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The msgp argument is a pointer to a  caller-defined  structure  of</span></span><br><span class="line"><span class="comment">       the following general form:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           struct msgbuf &#123;</span></span><br><span class="line"><span class="comment">               long mtype;        message type, must be &gt; 0 </span></span><br><span class="line"><span class="comment">               char mtext[1];     message data </span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  mtext  field  is  an array(数组) (or other structure) whose size is</span></span><br><span class="line"><span class="comment">       specified by msgsz, a nonnegative（非负的） integer value.  Messages of zero</span></span><br><span class="line"><span class="comment">       length (i.e., no mtext field) are permitted.  The mtype field must</span></span><br><span class="line"><span class="comment">       have a strictly（严格的） positive（确切的） integer value.  This value can be used by</span></span><br><span class="line"><span class="comment">       the  receiving  process for message selection (see the description</span></span><br><span class="line"><span class="comment">       of msgrcv() below).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       msgsnd()</span></span><br><span class="line"><span class="comment">       The msgsnd() system call appends a copy of the message pointed  to</span></span><br><span class="line"><span class="comment">       by  msgp  to  the  message  queue whose identifier is specified by</span></span><br><span class="line"><span class="comment">       msqid.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If sufficient（充足的） space is available in the queue,  msgsnd()  succeeds</span></span><br><span class="line"><span class="comment">       immediately.   The  queue  capacity（容量）  is governed（管理） by the msg_qbytes</span></span><br><span class="line"><span class="comment">       field in the associated data  structure  for  the  message  queue.</span></span><br><span class="line"><span class="comment">       During  queue  creation this field is initialized to MSGMNB bytes,</span></span><br><span class="line"><span class="comment">       but this limit can be modified（修改的） using msgctl(2).  A  message  queue</span></span><br><span class="line"><span class="comment">       is  considered（认为） to be full if either of the following conditions（条件） is</span></span><br><span class="line"><span class="comment">       true:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * Adding a new message to the queue would cause the  total  number</span></span><br><span class="line"><span class="comment">         of  bytes  in  the queue to exceed（超出） the queue&#x27;s maximum size (the</span></span><br><span class="line"><span class="comment">         msg_qbytes field).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * Adding another message to the queue would cause the total number</span></span><br><span class="line"><span class="comment">         of messages in the queue to exceed the queue&#x27;s maximum size (the</span></span><br><span class="line"><span class="comment">         msg_qbytes field).  This check is necessary to prevent（防止） an unlim‐</span></span><br><span class="line"><span class="comment">         ited  number  of zero-length messages being placed on the queue.</span></span><br><span class="line"><span class="comment">         Although such messages contain（包含） no data, they  nevertheless  consume（消耗 (locked) kernel memory（内核内存）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      msgrcv()</span></span><br><span class="line"><span class="comment">       The msgrcv() system call removes a message from the  queue  speci‐</span></span><br><span class="line"><span class="comment">       fied by msqid and places it in the buffer pointed to by msgp.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  argument  msgsz  specifies  the maximum size in bytes for the</span></span><br><span class="line"><span class="comment">       member mtext of the structure pointed to by the msgp argument.  If</span></span><br><span class="line"><span class="comment">       the  message text has length greater（较大的） than msgsz, then the behavior</span></span><br><span class="line"><span class="comment">       depends on whether MSG_NOERROR is specified in msgflg.  If MSG_NO‐</span></span><br><span class="line"><span class="comment">       ERROR  is  specified, then the message text will be truncated (and</span></span><br><span class="line"><span class="comment">       the truncated part will be lost); if MSG_NOERROR is not specified,</span></span><br><span class="line"><span class="comment">       then  the message isn&#x27;t removed from the queue and the system call</span></span><br><span class="line"><span class="comment">       fails returning -1 with errno set to E2BIG.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On failure both functions return -1 with errno indicating the  er‐</span></span><br><span class="line"><span class="comment">       ror,  otherwise msgsnd() returns 0 and msgrcv() returns the number</span></span><br><span class="line"><span class="comment">       of bytes actually copied into the mtext array.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="网络套接字"><a href="#网络套接字" class="headerlink" title="网络套接字"></a>网络套接字</h2><p>​	</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">网络套接字socket</span><br><span class="line">	<span class="number">1.</span> 字节序问题：</span><br><span class="line">		大端：低地址处放高字节</span><br><span class="line">		小端：低地址处放低字节</span><br><span class="line">		主机字节序：host</span><br><span class="line">		网络字节序：network</span><br><span class="line">		解决：_to_ _ : htons, htonl, ntohs, ntohl</span><br><span class="line">		</span><br><span class="line">	<span class="number">2.</span> 对齐：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">demo_001</span> //12字节</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="type">char</span> b;</span><br><span class="line">            <span class="type">float</span> c;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">demo_002</span>//24字节</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">int</span> d;</span><br><span class="line">            <span class="type">double</span> e;</span><br><span class="line">            <span class="type">char</span> f;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">demo_003</span>//9字节</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="type">char</span> b;</span><br><span class="line">            <span class="type">float</span> c;</span><br><span class="line">        &#125;__attribute__((packed));</span><br><span class="line">        解决： 不对齐</span><br><span class="line">        </span><br><span class="line">     <span class="number">3.</span> 类型长度问题：</span><br><span class="line">     	<span class="type">int</span></span><br><span class="line">     	<span class="type">char</span></span><br><span class="line">     	解决: <span class="type">int32_t</span>, <span class="type">uint32_t</span>, <span class="type">int64_t</span>, <span class="type">int8_t</span>, <span class="type">uint8_t</span></span><br><span class="line">            </span><br><span class="line"> 	 <span class="number">4.</span>报式套接字：</span><br><span class="line">            socket（）；</span><br><span class="line">            bind();</span><br><span class="line">			sendto();</span><br><span class="line">			rcvfrom();</span><br><span class="line">			inet_pton();</span><br><span class="line">			inet_ntop();</span><br><span class="line"></span><br><span class="line">		多点通讯：广播（全网广播， 子网广播），多播/组播 </span><br><span class="line">     	</span><br><span class="line">     	</span><br><span class="line">被动端（先运行）</span><br><span class="line"><span class="number">1.</span>取得socker</span><br><span class="line"><span class="number">2.</span>给socket取得地址</span><br><span class="line"><span class="number">3.</span>收/发消息</span><br><span class="line"><span class="number">4.</span>关闭socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主动端</span><br><span class="line"><span class="number">1.</span>取得socket</span><br><span class="line"><span class="number">2.</span>给socket取得地址（可省略）</span><br><span class="line"><span class="number">3.</span>收/发消息</span><br><span class="line"><span class="number">4.</span>关闭socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">netstat -anu   <span class="comment">//命令查看报式套接字</span></span><br><span class="line">netstat -ant  <span class="comment">//命令查看流式套接字</span></span><br></pre></td></tr></table></figure>

<h3 id="报式套接字"><a href="#报式套接字" class="headerlink" title="报式套接字"></a>报式套接字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//***************************proto.h*******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span>    <span class="comment">// 包含了 uint8_t 和 uint32_t 类型的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCVPORT         <span class="string">&quot;1989&quot;</span>   <span class="comment">// 接收端口号定义为字符串 &quot;1989&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE        11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE       40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">uint32_t</span> math;</span><br><span class="line">    <span class="type">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed));<span class="comment">//[1]  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************rcver.c*******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>, <span class="title">raddr</span>;</span>   <span class="comment">//[3] 本地地址和远程地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];             <span class="comment">// 存储 IP 地址的字符串</span></span><br><span class="line"></span><br><span class="line">    sd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">/*IPPROTO_UDP*/</span><span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));<span class="comment">//[4]</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;laddr.sin_addr);<span class="comment">//[5]  // 绑定的 IP 地址，监听所有地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (<span class="type">void</span> *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)<span class="comment">//[6]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*!!!*/</span></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);<span class="comment">//不加这个，第一次数据发送会失败，第二次后通信知道数据的长度后会成功。确保传递给 recvfrom 函数的地址结构体大小是正确的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        recvfrom(sd, &amp;rbuf, <span class="keyword">sizeof</span>(rbuf),<span class="number">0</span>, (<span class="type">void</span> *)&amp;raddr, &amp;raddr_len);<span class="comment">//[8]</span></span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);<span class="comment">//[9]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---MESSAGE FROM %s:%d---\n&quot;</span>, ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NAME = %s\n&quot;</span>, rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MATH = %d\n&quot;</span>, ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CHINESE = %d\n&quot;</span>, ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************snder.c*******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> sd;                        <span class="comment">// socket 描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span>            <span class="comment">// 发送消息的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span>      <span class="comment">// 接收端地址结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage....\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);   <span class="comment">// 创建 UDP socket</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);         <span class="comment">// 随机生成数学成绩，并转换为网络字节序（大端序）</span></span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;                     <span class="comment">// IPv4 地址族</span></span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));          <span class="comment">// 目标端口号，从宏 RCVPORT 获取并转换为网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;raddr.sin_addr);   <span class="comment">// 将输入的目标 IP 地址转换为网络地址结构体中的地址</span></span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd, &amp;sbuf, <span class="keyword">sizeof</span>(sbuf), <span class="number">0</span>, (<span class="type">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)<span class="comment">//[9]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">	__attribute__((packed)) 是GCC和一些兼容的编译器扩展，用于告诉编译器结构体或联合体不需要进行字节对齐，而是按照定义顺序紧凑地排列成员，即按照成员声明的顺序连续地存放在内存中，没有填充字节。</span></span><br><span class="line"><span class="comment">	在C语言中，默认情况下，编译器会为了优化访问速度而对结构体或联合体进行字节对齐，即按照某种规则在结构体成员之间插入一些填充字节，使得结构体成员的地址是对齐的。这种对齐可以提高访问结构体成员的效率，但会增加结构体的大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">NAME：</span></span><br><span class="line"><span class="comment">       socket - create an endpoint(端点) for communication</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS：</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;          </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">       int socket(int domain, int type, int protocol);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       socket()  creates  an  endpoint for communication and returns a file descriptor that  refers  to  that  endpoint.</span></span><br><span class="line"><span class="comment">       The file descriptor returned by a successful call will be</span></span><br><span class="line"><span class="comment">       the lowest-numbered（编号最小的） file descriptor  not  currently（当前）  open</span></span><br><span class="line"><span class="comment">       for the process（过程）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  domain（定义域）  argument  specifies  a communication domain;</span></span><br><span class="line"><span class="comment">       this selects the protocol family（协议族） which will be  used  for</span></span><br><span class="line"><span class="comment">       communication.     These    families   are   defined   in</span></span><br><span class="line"><span class="comment">       &lt;sys/socket.h&gt;.  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">       On  success,  a file descriptor for the new socket is re‐</span></span><br><span class="line"><span class="comment">       turned.  On error, -1 is returned, and errno is  set  ap‐</span></span><br><span class="line"><span class="comment">       propriately.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">	 sd = socket(PF_INET, SOCK_DGRAM, 0);</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">	 int domain:  PF_INET 表示使用 IPv4 地址族，即套接字将使用 IPv4 地址。</span></span><br><span class="line"><span class="comment">	 int type:   SOCK_DGRAM 表示套接字类型是数据报套接字，这种类型的套接字用于支持 UDP 协议的通信，UDP 是无连接的、不可靠的传输协议。</span></span><br><span class="line"><span class="comment">     int protocol:   第三个参数 0 表示自动选择合适的协议，对于 SOCK_DGRAM 类型的套接字，通常会选择默认的 UDP 协议（在 PF_INET 地址族下）。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">[3][4]</span></span><br><span class="line"><span class="comment">	struct sockaddr_in 是一个标准的C语言结构体，它是POSIX和Berkeley套接字API的一部分，用于表示IPv4的套接字地址。在使用套接字编程时，这个结构体已经被操作系统或相关的网络库（如glibc）定义好，你只需要包含相应的头文件就可以直接使用。</span></span><br><span class="line"><span class="comment">	通常，在C语言程序中，为了使用struct sockaddr_in，你需要包含 &lt;sys/socket.h&gt; 和 &lt;netinet/in.h&gt; 头文件，这两个头文件中包含了定义该结构体及其相关宏和类型所需的信息。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	truct sockaddr_in &#123;</span></span><br><span class="line"><span class="comment">               sa_family_t    sin_family; 此字段标识套接字地址的地址族。对于IPv4，这个值应该是AF_INET，这是Internet协议版本4的地址族常量。</span></span><br><span class="line"><span class="comment">               in_port_t      sin_port;   这个字段存储端口号，它是16位无符号整数。端口号用于标识同一台主机上的不同服务或应用程序。在sockaddr_in结构体中，端口号以网络字节序（大端序）存储，这意味着在赋值之前可能需要用诸如htons()（主机到网络短整型）这样的函数转换端口号。</span></span><br><span class="line"><span class="comment">               struct in_addr sin_addr;   这是一个嵌套的结构体，用于存储IPv4的32位地址。</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">           struct in_addr &#123;</span></span><br><span class="line"><span class="comment">               uint32_t       s_addr;    这个结构体专门用于存储IPv4的互联网地址，它只有一个成员：</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">	laddr.sin_family = AF_INET;</span></span><br><span class="line"><span class="comment">    laddr.sin_port = htons(atoi(RCVPORT));</span></span><br><span class="line"><span class="comment">    inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;laddr.sin_addr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4][9]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       htonl,  htons, ntohl, ntohs - convert(转换) values between host（主机）</span></span><br><span class="line"><span class="comment">       and network byte order（网络字节序）</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">       uint32_t htonl(uint32_t hostlong);</span></span><br><span class="line"><span class="comment">       uint16_t htons(uint16_t hostshort);</span></span><br><span class="line"><span class="comment">       uint32_t ntohl(uint32_t netlong);</span></span><br><span class="line"><span class="comment">       uint16_t ntohs(uint16_t netshort);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The htonl() function converts the unsigned integer  hostlong（无符号长整型数） from host byte order to network byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  htons() function converts the unsigned short integer hostshort（无符号短整型数） from host byte order to network byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The ntohl() function converts the unsigned  integer  netlong from network byte order to host byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  ntohs() function converts the unsigned short integer netshort from network byte order to host byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       On the i386（x86） the host byte order is Least Significant Byte</span></span><br><span class="line"><span class="comment">       first, whereas the network byte order, as used on the In‐</span></span><br><span class="line"><span class="comment">       ternet, is Most Significant Byte first.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[5]</span></span><br><span class="line"><span class="comment">NAME：</span></span><br><span class="line"><span class="comment">       inet_pton  - convert IPv4 and IPv6 addresses from text（文本表示形式） to</span></span><br><span class="line"><span class="comment">       binary(二进制 网络地址结构) form</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS：</span></span><br><span class="line"><span class="comment">       #include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">       int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       This function converts the character string  src  into  a</span></span><br><span class="line"><span class="comment">       network  address structure in the af address family, then</span></span><br><span class="line"><span class="comment">       copies the network address structure to dst.  The af  argument  must be either AF_INET or AF_INET6.  dst is written in network byte order.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       inet_pton() returns 1 on  success  (network  address  was</span></span><br><span class="line"><span class="comment">       successfully  converted).   0 is returned if src does not</span></span><br><span class="line"><span class="comment">       contain a character string representing a  valid  network</span></span><br><span class="line"><span class="comment">       address  in the specified address family.  If af does not</span></span><br><span class="line"><span class="comment">       contain a valid（有效的） address family, -1 is returned and  errno</span></span><br><span class="line"><span class="comment">       is set to EAFNOSUPPORT.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">	inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;laddr.sin_addr);</span></span><br><span class="line"><span class="comment">	&quot;0.0.0.0&quot; 是一个特殊的IPv4地址，通常表示本机上的任意IP地址，当一个服务绑定到这个地址时，意味着它将在所有可用的网络接口上监听连接请求。</span></span><br><span class="line"><span class="comment">	指向laddr结构体中sin_addr字段的指针，该字段是一个struct in_addr类型，用于存储IPv4地址的32位二进制形式。</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[6]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       bind - bind(捆绑) a name to a socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;         </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">       int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       When  a  socket is created with socket(2), it exists in a</span></span><br><span class="line"><span class="comment">       name space (address family) but has no  address  assigned（分配）</span></span><br><span class="line"><span class="comment">       to  it.   bind() assigns the address specified by addr to</span></span><br><span class="line"><span class="comment">       the socket referred to by  the  file  descriptor  sockfd.</span></span><br><span class="line"><span class="comment">       addrlen  specifies  the  size,  in  bytes, of the address</span></span><br><span class="line"><span class="comment">       structure pointed to by addr.  Traditionally, this operation is called “assigning a name to a socket”.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       It  is normally necessary to assign a local address using</span></span><br><span class="line"><span class="comment">       bind() before a SOCK_STREAM socket  may  receive  connec‐</span></span><br><span class="line"><span class="comment">       tions (see accept(2)).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       On  success, zero is returned.  On error, -1 is returned,</span></span><br><span class="line"><span class="comment">       and errno is set appropriately.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">	bind(sd, (void *)&amp;laddr, sizeof(laddr)</span></span><br><span class="line"><span class="comment">	在套接字编程中将一个套接字（由文件描述符sd表示）绑定到一个特定的IP地址和端口上。</span></span><br><span class="line"><span class="comment">	(void *)&amp;laddr：这里，laddr应该是一个之前定义并初始化过的struct sockaddr_in结构体变量，包含了要绑定的IP地址和端口号信息。通过(void *)&amp;laddr，我们将这个结构体的地址强制转换为(void *)指针类型，因为bind()函数的第二个参数需要一个指向套接字地址结构的指针。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">[8]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       recv, recvfrom, recvmsg - receive a message from a socket</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS	</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span></span><br><span class="line"><span class="comment">                      		 	 struct sockaddr *src_addr, socklen_t *addrlen);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">recvfrom()</span></span><br><span class="line"><span class="comment">       recvfrom() places the received message  into  the  buffer</span></span><br><span class="line"><span class="comment">       buf.   The  caller must specify the size of the buffer in</span></span><br><span class="line"><span class="comment">       len.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If src_addr is not NULL, and the underlying protocol pro‐</span></span><br><span class="line"><span class="comment">       vides  the source address of the message, that source ad‐</span></span><br><span class="line"><span class="comment">       dress is placed in the buffer pointed to by src_addr.  In</span></span><br><span class="line"><span class="comment">       this  case,  addrlen  is a value-result argument.  Before</span></span><br><span class="line"><span class="comment">       the call, it should be initialized to  the  size  of  the</span></span><br><span class="line"><span class="comment">       buffer associated with src_addr.  Upon return, addrlen is</span></span><br><span class="line"><span class="comment">       updated to contain the actual size of the source address.</span></span><br><span class="line"><span class="comment">       The  returned address is truncated if the buffer provided</span></span><br><span class="line"><span class="comment">       is too small; in this case, addrlen will return  a  value</span></span><br><span class="line"><span class="comment">       greater than was supplied to the call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  the  caller  is not interested in the source address,</span></span><br><span class="line"><span class="comment">       src_addr and addrlen should be specified as NULL.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">	recvfrom(sd, &amp;rbuf, sizeof(rbuf),0, (void *)&amp;raddr, &amp;raddr_len);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="流式套接字"><a href="#流式套接字" class="headerlink" title="流式套接字"></a>流式套接字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*********************proto.h************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     SERVERPORT      <span class="string">&quot;1989&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     FMT_STAMP       <span class="string">&quot;%lld\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     IPSTRSIZE       40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     BUFSIZE         1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************server.c*********************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> sd)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP, (<span class="type">long</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(send(sd, buf, len, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> sd, newsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>, <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span><span class="comment">/*IPPROTO_TCP, IPPROTO_SCTP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) <span class="comment">//[1]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (<span class="type">void</span> *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sd, <span class="number">200</span>) &lt; <span class="number">0</span>)  <span class="comment">//[2]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newsd = accept(sd, (<span class="type">void</span> *)&amp;raddr, &amp;raddr_len); <span class="comment">//[3]</span></span><br><span class="line">        <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client:%s:%d\n&quot;</span> ,ipstr, ntohs(raddr.sin_port));</span><br><span class="line"></span><br><span class="line">        server_job(newsd);</span><br><span class="line">        close(newsd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************client.c*****************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stamp;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;user...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sd, (<span class="type">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>) <span class="comment">//[4]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fdopen(sd, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fdopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fscanf</span>(fp, FMT_STAMP, &amp;stamp) &lt; <span class="number">1</span>)  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;bad format\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;stamp = %lld\n&quot;</span>, stamp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       getsockopt, setsockopt - get and set options on sockets</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;          </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int getsockopt(int sockfd, int level, int optname,</span></span><br><span class="line"><span class="comment">                      void *optval, socklen_t *optlen);</span></span><br><span class="line"><span class="comment">       int setsockopt(int sockfd, int level, int optname,</span></span><br><span class="line"><span class="comment">                      const void *optval, socklen_t optlen);</span></span><br><span class="line"><span class="comment">                   </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       getsockopt()  and  setsockopt() manipulate(操作) options for the</span></span><br><span class="line"><span class="comment">       socket referred to by the file descriptor sockfd.  Options</span></span><br><span class="line"><span class="comment">       may  exist  at  multiple（多个）  protocol（协议） levels; they are always</span></span><br><span class="line"><span class="comment">       present（出现） at the uppermost（最上层） socket level.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       When manipulating socket options, the level at  which  the</span></span><br><span class="line"><span class="comment">       option  resides（存在）  and the name of the option must be specified.  To manipulate options at  the  sockets  API  level,level  is  specified as SOL_SOCKET.  To manipulate options at any other level the protocol number of the  appropriate（适当的）protocol controlling（管理） the option is supplied（被提供）.  For example, to indicate（表明） that an option is to be interpreted by the TCP</span></span><br><span class="line"><span class="comment">       protocol,  level  should  be set to the protocol number of</span></span><br><span class="line"><span class="comment">       TCP; see getprotoent(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The arguments optval and optlen are used to access  option</span></span><br><span class="line"><span class="comment">       values for setsockopt().  For getsockopt() they identify（确认） a</span></span><br><span class="line"><span class="comment">       buffer in which the value for the requested option(s)  are</span></span><br><span class="line"><span class="comment">       to  be  returned.  For getsockopt(), optlen is a value-result argument, initially containing the size of the buffer</span></span><br><span class="line"><span class="comment">       pointed  to  by optval, and modified（修改） on return to indicate（表明）</span></span><br><span class="line"><span class="comment">       the actual（真实的） size of the value returned.  If no option value</span></span><br><span class="line"><span class="comment">       is to be supplied（提供） or returned, optval may be NULL.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       Optname and any specified options are passed uninterpreted（未被解释）</span></span><br><span class="line"><span class="comment">       to the appropriate  protocol  module  for  interpretation.</span></span><br><span class="line"><span class="comment">       The  include  file &lt;sys/socket.h&gt; contains definitions for</span></span><br><span class="line"><span class="comment">       socket level options, described below.  Options  at  other</span></span><br><span class="line"><span class="comment">       protocol  levels  vary in format and name; consult the ap‐</span></span><br><span class="line"><span class="comment">       propriate entries in section 4 of the manual.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Most socket-level options utilize an int argument for opt‐</span></span><br><span class="line"><span class="comment">       val.   For setsockopt(), the argument should be nonzero to</span></span><br><span class="line"><span class="comment">       enable a boolean option, or zero if the option  is  to  be</span></span><br><span class="line"><span class="comment">       disabled.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       For  a  description  of  the  available socket options see</span></span><br><span class="line"><span class="comment">       socket(7) and the appropriate protocol man pages.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, zero is returned for the standard options.  On</span></span><br><span class="line"><span class="comment">       error, -1 is returned, and errno is set appropriately.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Netfilter  allows  the  programmer to define custom socket</span></span><br><span class="line"><span class="comment">       options with associated handlers; for  such  options,  the</span></span><br><span class="line"><span class="comment">       return  value on success is the value returned by the han‐</span></span><br><span class="line"><span class="comment">       dler.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       listen - listen for connections on a socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;         </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int listen(int sockfd, int backlog);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       listen()  marks（标记） the socket referred to by sockfd as a passive（被动的） socket, that is, as a socket that will be used to accept incoming connection requests using accept(2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  sockfd argument is a file descriptor that refers to a</span></span><br><span class="line"><span class="comment">       socket of type SOCK_STREAM or SOCK_SEQPACKET.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The backlog argument defines the maximum length  to  which</span></span><br><span class="line"><span class="comment">       the  queue of pending connections for sockfd may grow.  If</span></span><br><span class="line"><span class="comment">       a connection request arrives when the queue is  full,  the</span></span><br><span class="line"><span class="comment">       client may receive an error with an indication of ECONNRE‐</span></span><br><span class="line"><span class="comment">       FUSED or, if the underlying protocol supports  retransmis‐</span></span><br><span class="line"><span class="comment">       sion, the request may be ignored so that a later reattempt（重新尝试）</span></span><br><span class="line"><span class="comment">       at connection succeeds.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, zero is returned.  On error, -1  is  returned,</span></span><br><span class="line"><span class="comment">       and errno is set appropriately.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[3]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       accept, accept4 - accept a connection on a socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;         </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  accept()  system  call  is used with connection-based</span></span><br><span class="line"><span class="comment">       socket types (SOCK_STREAM, SOCK_SEQPACKET).   It  extracts（提取）</span></span><br><span class="line"><span class="comment">       the  first connection request on the queue of pending con‐</span></span><br><span class="line"><span class="comment">       nections for the listening socket, sockfd, creates  a  new</span></span><br><span class="line"><span class="comment">       connected socket, and returns a new file descriptor refer‐</span></span><br><span class="line"><span class="comment">       ring to that socket.  The newly created socket is  not  in</span></span><br><span class="line"><span class="comment">       the  listening state.  The original socket sockfd is unaffected（不受影响的） by this call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The argument sockfd is a socket that has been created with</span></span><br><span class="line"><span class="comment">       socket(2),  bound  to a local address with bind(2), and is</span></span><br><span class="line"><span class="comment">       listening for connections after a listen(2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The argument addr is a pointer to  a  sockaddr  structure.</span></span><br><span class="line"><span class="comment">       This  structure  is filled in with the address of the peer</span></span><br><span class="line"><span class="comment">       socket, as known to the communications layer.   The  exact</span></span><br><span class="line"><span class="comment">       format  of  the address returned addr is determined by the</span></span><br><span class="line"><span class="comment">       socket&#x27;s address family (see socket(2) and the  respective</span></span><br><span class="line"><span class="comment">       protocol man pages).  When addr is NULL, nothing is filled</span></span><br><span class="line"><span class="comment">       in; in this case, addrlen is not used, and should also  be</span></span><br><span class="line"><span class="comment">       NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  addrlen  argument  is  a  value-result  argument: the</span></span><br><span class="line"><span class="comment">       caller must initialize it to contain the size  (in  bytes)</span></span><br><span class="line"><span class="comment">       of  the  structure  pointed  to by addr; on return it will</span></span><br><span class="line"><span class="comment">       contain the actual size of the peer address.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The returned address is truncated if the  buffer  provided</span></span><br><span class="line"><span class="comment">       is  too  small;  in this case, addrlen will return a value</span></span><br><span class="line"><span class="comment">       greater than was supplied to the call.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">	   If no pending connections are present on  the  queue,  and</span></span><br><span class="line"><span class="comment">       the  socket  is not marked as nonblocking, accept() blocks</span></span><br><span class="line"><span class="comment">       the caller until a connection is present.  If  the  socket</span></span><br><span class="line"><span class="comment">       is  marked  nonblocking  and  no  pending  connections are</span></span><br><span class="line"><span class="comment">       present on the queue, accept() fails with the error EAGAIN</span></span><br><span class="line"><span class="comment">       or EWOULDBLOCK.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In  order  to  be  notified  of  incoming connections on a</span></span><br><span class="line"><span class="comment">       socket, you can use select(2), poll(2),  or  epoll(7).   A</span></span><br><span class="line"><span class="comment">       readable  event will be delivered when a new connection is</span></span><br><span class="line"><span class="comment">       attempted and you may then call accept() to get  a  socket</span></span><br><span class="line"><span class="comment">       for  that  connection.   Alternatively,  you  can  set the</span></span><br><span class="line"><span class="comment">       socket to deliver SIGIO when activity occurs on a  socket;</span></span><br><span class="line"><span class="comment">       see socket(7) for details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  flags  is  0,  then accept4() is the same as accept().</span></span><br><span class="line"><span class="comment">       The following values can be bitwise ORed in flags  to  ob‐</span></span><br><span class="line"><span class="comment">       tain different behavior:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       SOCK_NONBLOCK   Set the O_NONBLOCK file status flag on the</span></span><br><span class="line"><span class="comment">                       open file description  (see  open(2))  re‐</span></span><br><span class="line"><span class="comment">                       ferred to by the new file descriptor.  Us‐</span></span><br><span class="line"><span class="comment">                       ing this flag saves  extra  calls  to  fc‐</span></span><br><span class="line"><span class="comment">                       ntl(2) to achieve the same result.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on</span></span><br><span class="line"><span class="comment">                       the new file descriptor.  See the descrip‐</span></span><br><span class="line"><span class="comment">                       tion  of the O_CLOEXEC flag in open(2) for</span></span><br><span class="line"><span class="comment">                       reasons why this may be useful.</span></span><br><span class="line"><span class="comment">                      </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, these system calls return a nonnegative  inte‐</span></span><br><span class="line"><span class="comment">       ger that is a file descriptor for the accepted socket.  On</span></span><br><span class="line"><span class="comment">       error, -1 is returned, errno is set appropriately, and ad‐</span></span><br><span class="line"><span class="comment">       drlen is left unchanged.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       connect - initiate a connection on a socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;         </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int connect(int sockfd, const struct sockaddr *addr,</span></span><br><span class="line"><span class="comment">                   socklen_t addrlen);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  connect() system call connects the socket referred to</span></span><br><span class="line"><span class="comment">       by the file descriptor sockfd to the address specified  by</span></span><br><span class="line"><span class="comment">       addr.   The  addrlen  argument specifies the size of addr.</span></span><br><span class="line"><span class="comment">       The format of the address in addr is determined by the ad‐</span></span><br><span class="line"><span class="comment">       dress  space  of the socket sockfd; see socket(2) for fur‐</span></span><br><span class="line"><span class="comment">       ther details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If the socket sockfd is of type SOCK_DGRAM, then  addr  is</span></span><br><span class="line"><span class="comment">       the  address  to  which datagrams are sent by default, and</span></span><br><span class="line"><span class="comment">       the only address from which datagrams  are  received.   If</span></span><br><span class="line"><span class="comment">       the  socket is of type SOCK_STREAM or SOCK_SEQPACKET, this</span></span><br><span class="line"><span class="comment">       call attempts to make a connection to the socket  that  is</span></span><br><span class="line"><span class="comment">       bound to the address specified by addr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Generally,  connection-based protocol sockets may success‐</span></span><br><span class="line"><span class="comment">       fully connect() only once; connectionless protocol sockets</span></span><br><span class="line"><span class="comment">       may  use connect() multiple times to change their associa‐</span></span><br><span class="line"><span class="comment">       tion.  Connectionless sockets may dissolve the association</span></span><br><span class="line"><span class="comment">       by  connecting  to an address with the sa_family member of</span></span><br><span class="line"><span class="comment">       sockaddr set to AF_UNSPEC (supported on Linux since kernel</span></span><br><span class="line"><span class="comment">       2.2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       If  the  connection or binding succeeds, zero is returned.</span></span><br><span class="line"><span class="comment">       On error, -1 is returned, and errno is set appropriately.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="动态进程池"><a href="#动态进程池" class="headerlink" title="动态进程池"></a>动态进程池</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*********************************proto.h***********************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMEMAX 512-8-8<span class="comment">//(UDP推荐长度-UDP报头长度-结构体的长度)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMT_STAMP <span class="string">&quot;%lld\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERPORT <span class="string">&quot;2333&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************************client.c******************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span><span class="comment">//remote addr</span></span><br><span class="line"></span><br><span class="line">    sfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP*/</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sfd,(<span class="type">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fdopen(sfd,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stamp;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp,FMT_STAMP,&amp;stamp) &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Bad format\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,FMT_STAMP,stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************************server.c**************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_NOTIFY SIGUSR2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSPACESERVER 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSPACESERVER 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCLINETS     20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    STATE_IDLE=<span class="number">0</span>,  <span class="comment">// idle 空闲的</span></span><br><span class="line">    STATE_BUSY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">server_st</span>&#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">server_st</span> *<span class="title">serverpool</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> idle_count = <span class="number">0</span>,busy_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket相关全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sfd;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="type">int</span> newsd;</span><br><span class="line">    <span class="type">int</span> ppid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span><span class="comment">//remote addr</span></span><br><span class="line">    <span class="type">char</span> ip[IPSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    ppid = getppid();<span class="comment">//父进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        serverpool[pos].state = STATE_IDLE;</span><br><span class="line">        kill(ppid, SIG_NOTIFY);  <span class="comment">//[1]</span></span><br><span class="line"></span><br><span class="line">        newsd = accept(sfd, (<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);<span class="comment">//接收客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (newsd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR || errno == EAGAIN)</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverpool[pos].state = STATE_BUSY;</span><br><span class="line">        kill(ppid,SIG_NOTIFY);</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ip,IPSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">        <span class="type">int</span> pkglen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pkglen = <span class="built_in">sprintf</span>(buf,FMT_STAMP,(<span class="type">long</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (send(newsd,buf,pkglen,<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(newsd);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_one_server</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> slot;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idle_count + busy_count &gt;= MAXCLINETS)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(slot = <span class="number">0</span>;slot &lt; MAXCLINETS;slot++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (serverpool[slot].pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverpool[slot].state = STATE_IDLE;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        server_job(slot);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        serverpool[slot].pid = pid;</span><br><span class="line">        idle_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">del_one_server</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> slot;</span><br><span class="line">    <span class="keyword">if</span> (idle_count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(slot = <span class="number">0</span>;slot &lt; MAXCLINETS;slot++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (serverpool[slot].pid != <span class="number">-1</span> &amp;&amp; serverpool[slot].state == STATE_IDLE)&#123;</span><br><span class="line">            kill(serverpool[slot].pid,SIGTERM);</span><br><span class="line">            serverpool[slot].pid = <span class="number">-1</span>;</span><br><span class="line">            idle_count--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scan_pool</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> idle = <span class="number">0</span>,busy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAXCLINETS;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (serverpool[i].pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kill(serverpool[i].pid,<span class="number">0</span>))&#123;<span class="comment">//kill pid 0检测一个进程是否存在 如果进程不存在（返回非零），将 pid 置为 -1，表示该位置空闲</span></span><br><span class="line">            serverpool[i].pid =<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计进程池的状态</span></span><br><span class="line">        <span class="keyword">if</span>(serverpool[i].state == STATE_IDLE)</span><br><span class="line">          idle++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(serverpool[i].state == STATE_BUSY)</span><br><span class="line">          busy++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;未知状态!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    idle_count = idle;</span><br><span class="line">    busy_count = busy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>,<span class="title">osa</span>;</span></span><br><span class="line"></span><br><span class="line">    sa.sa_handler = SIG_IGN;<span class="comment">//忽略父进程的资源回收信号</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_NOCLDWAIT;<span class="comment">//让子进程结束后自行消亡,不会变成僵尸状态</span></span><br><span class="line">    sigaction(SIGCLD,&amp;sa,&amp;osa);</span><br><span class="line"></span><br><span class="line">    sa.sa_handler = handle;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIG_NOTIFY,&amp;sa,&amp;osa);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏蔽信号</span></span><br><span class="line">    <span class="type">sigset_t</span> sigset,oldsigset;</span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset,SIG_NOTIFY);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;sigset,&amp;oldsigset);</span><br><span class="line"></span><br><span class="line">    serverpool = mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> server_st)*MAXCLINETS,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>); <span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span> (serverpool == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化进程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAXCLINETS;i++)&#123;</span><br><span class="line">        serverpool[i].pid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP*/</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sfd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span><span class="comment">//local addr</span></span><br><span class="line">    laddr.sin_family = AF_INET;<span class="comment">//指定协议</span></span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));<span class="comment">//指定网络通信端口</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);<span class="comment">//IPv4点分式转二进制数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sfd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sfd,<span class="number">1024</span>) &lt; <span class="number">0</span>)&#123;<span class="comment">//全连接数量，listen 是服务器端 TCP 套接字编程中的关键步骤之一。它允许服务器准备好接受连接请求并处理客户端请求。如果没有调用 listen，服务器将无法接收客户端的连接请求。</span></span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MINSPACESERVER;i++)&#123;</span><br><span class="line">        add_one_server();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sigsuspend(&amp;oldsigset);</span><br><span class="line"></span><br><span class="line">        scan_pool();<span class="comment">//扫描进程池</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//管理进程池</span></span><br><span class="line">        <span class="keyword">if</span> (idle_count &gt; MAXSPACESERVER)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (idle_count-MAXSPACESERVER);i++)&#123;</span><br><span class="line">                del_one_server();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (idle_count &lt; MINSPACESERVER)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;削减server\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (MINSPACESERVER-idle_count);i++)&#123;</span><br><span class="line">                add_one_server();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print the pool</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAXCLINETS;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (serverpool[i].pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (serverpool[i].state == STATE_IDLE)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(serverpool[i].state == STATE_BUSY)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fflush(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sfd);</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oldsigset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">	kill(ppid, SIG_NOTIFY);</span></span><br><span class="line"><span class="comment">    kill 函数用于向指定进程发送信号。它的第一个参数是进程ID，第二个参数是要发送的信号.</span></span><br><span class="line"><span class="comment">    ppid 是父进程的进程ID。</span></span><br><span class="line"><span class="comment">    SIG_NOTIFY 是一个用户自定义信号，用于通知父进程某个事件已经发生。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    在父进程中，有一个信号处理函数 handle，它会在接收到 SIG_NOTIFY 信号时被调用：</span></span><br><span class="line"><span class="comment">    static void handle(int sig) &#123;</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	该信号处理函数目前只是一个空函数，即在接收到 SIG_NOTIFY 信号时不会进行任何操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       mmap, munmap - map（映射） or unmap files or devices(设备) into memory</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line"><span class="comment">                  int fd, off_t offset);</span></span><br><span class="line"><span class="comment">                  </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       mmap()  creates  a new mapping in the virtual（虚拟的） address space of the calling process（调用进程）.  The starting address for the new mapping is specified in addr.The length argument specifies the length  of  the mapping (which must be greater than 0).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  addr  is  NULL,  then  the kernel chooses the</span></span><br><span class="line"><span class="comment">       (page-aligned) address at  which  to  create  the</span></span><br><span class="line"><span class="comment">       mapping; this is the most portable（便携的） method of creating a new mapping.  If addr is not  NULL,  then the  kernel  takes  it  as  a hint（暗示） about where to place the mapping; on Linux, the kernel will pick a nearby page boundary (but always above or equal to the value specified by</span></span><br><span class="line"><span class="comment">       /proc/sys/vm/mmap_min_addr) and attempt to create</span></span><br><span class="line"><span class="comment">       the mapping there.  If  another  mapping  already</span></span><br><span class="line"><span class="comment">       exists there, the kernel picks a new address that</span></span><br><span class="line"><span class="comment">       may or may not depend on the hint.   The  address</span></span><br><span class="line"><span class="comment">       of  the  new mapping is returned as the result of</span></span><br><span class="line"><span class="comment">       the call.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       The contents of a file mapping (as opposed（相反的） to  an</span></span><br><span class="line"><span class="comment">       anonymous（匿名的）  mapping; see MAP_ANONYMOUS below), are</span></span><br><span class="line"><span class="comment">       initialized（初始化） using length bytes starting at offset（偏移量）</span></span><br><span class="line"><span class="comment">       offset  in the file (or other object) referred to</span></span><br><span class="line"><span class="comment">       by the file descriptor fd.  offset must be a multiple   of   the   page   size   as  returned  by sysconf(_SC_PAGE_SIZE).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the mmap() call has returned, the file  descriptor,  fd,  can be closed immediately without invalidating the mapping.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The prot argument describes  the  desired  memory</span></span><br><span class="line"><span class="comment">       protection  of the mapping (and must not conflict</span></span><br><span class="line"><span class="comment">       with the open mode of the file).   It  is  either</span></span><br><span class="line"><span class="comment">       PROT_NONE or the bitwise OR of one or more of the</span></span><br><span class="line"><span class="comment">       following flags:</span></span><br><span class="line"><span class="comment">           PROT_EXEC  Pages may be executed.</span></span><br><span class="line"><span class="comment">           PROT_READ  Pages may be read.</span></span><br><span class="line"><span class="comment">           PROT_WRITE Pages may be written.</span></span><br><span class="line"><span class="comment">           PROT_NONE  Pages may not be accessed.</span></span><br><span class="line"><span class="comment">           </span></span><br><span class="line"><span class="comment">           MAP_ANONYMOUS</span></span><br><span class="line"><span class="comment">              The mapping is not backed（支持） by any file; its contents are initialized to zero.  The  fd argument  is ignored; however, some implementations（实现）  require  fd  to   be   -1   if MAP_ANONYMOUS  (or MAP_ANON) is specified, and portable  applications  should  ensure this.  The offset argument should be zero. The use of  MAP_ANONYMOUS  in  conjunction（同时出现） with MAP_SHARED is supported on Linux only since kernel 2.4.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Areslucky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/24/Ubuntu/">http://example.com/2024/04/24/Ubuntu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Areslucky</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/./img/blog004.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="LVGL基础知识"><img class="cover" src="/img/lazyload.gif" data-original="/img/blog006.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LVGL基础知识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/lazyload.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/lazyload.gif'" alt="avatar"/></div><div class="author-info__name">Areslucky</div><div class="author-info__description">我以我心绘风景，风景迷人因我心。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ares629"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记忆是一种相会，遗忘是一种自由。</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/24/Ubuntu/" title="Ubuntu"><img src="/img/lazyload.gif" data-original="/./img/blog004.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu"/></a><div class="content"><a class="title" href="/2024/04/24/Ubuntu/" title="Ubuntu">Ubuntu</a><time datetime="2024-04-24T13:15:59.054Z" title="发表于 2024-04-24 21:15:59">2024-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="LVGL基础知识"><img src="/img/lazyload.gif" data-original="/img/blog006.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LVGL基础知识"/></a><div class="content"><a class="title" href="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="LVGL基础知识">LVGL基础知识</a><time datetime="2024-04-20T07:55:52.020Z" title="发表于 2024-04-20 15:55:52">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="c语言基础知识"><img src="/img/lazyload.gif" data-original="/img/blog001.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言基础知识"/></a><div class="content"><a class="title" href="/2024/04/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="c语言基础知识">c语言基础知识</a><time datetime="2024-04-01T09:30:27.272Z" title="发表于 2024-04-01 17:30:27">2024-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/30/Gcc%E7%BC%96%E8%AF%91%E4%B8%8EGdb%E8%B0%83%E8%AF%95/" title="GCC编译与GDB调试"><img src="/img/lazyload.gif" data-original="/img/blog006.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GCC编译与GDB调试"/></a><div class="content"><a class="title" href="/2024/03/30/Gcc%E7%BC%96%E8%AF%91%E4%B8%8EGdb%E8%B0%83%E8%AF%95/" title="GCC编译与GDB调试">GCC编译与GDB调试</a><time datetime="2024-03-30T03:53:25.442Z" title="发表于 2024-03-30 11:53:25">2024-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/29/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="C++基础知识"><img src="/img/lazyload.gif" data-original="/./img/blog004.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++基础知识"/></a><div class="content"><a class="title" href="/2024/03/29/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="C++基础知识">C++基础知识</a><time datetime="2024-03-29T09:30:37.527Z" title="发表于 2024-03-29 17:30:37">2024-03-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/blog004.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Areslucky</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="lucky,love,endeavor,brave" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>
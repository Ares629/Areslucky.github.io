<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ubuntu</title>
      <link href="/2024/04/24/Ubuntu/"/>
      <url>/2024/04/24/Ubuntu/</url>
      
        <content type="html"><![CDATA[<h5 id="安装ubuntu时，安装界面不全："><a href="#安装ubuntu时，安装界面不全：" class="headerlink" title="安装ubuntu时，安装界面不全："></a>安装ubuntu时，安装界面不全：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctrl+alt+t <span class="comment">//打开终端</span></span><br><span class="line">: xrandr  <span class="comment">//查看分辨率</span></span><br><span class="line">: xrandr -s <span class="number">1920</span>x1080_59<span class="number">.96</span> <span class="comment">//选择分辨率</span></span><br></pre></td></tr></table></figure><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加阿里源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="linux基础命令"><a href="#linux基础命令" class="headerlink" title="linux基础命令"></a>linux基础命令</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*安装c的时候，c依赖b，b又依赖a，这个时候会自动安装a和b</span></span><br><span class="line"><span class="comment">但是，如果c利用了b默认隐含a包的条件，直接调用了a中的api，而下次更新b包的时候，假如b不再依赖a，这个时候autoremove会删掉a包，使c包不可用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">于是当你sudo apt-get remove c 后，autoremove会删除a,b.</span><br><span class="line">sudo apt-get autoremove <span class="comment">//卸载所有自动安装且不再使用的软件包</span></span><br></pre></td></tr></table></figure><h2 id="vim-文本文档命令"><a href="#vim-文本文档命令" class="headerlink" title="vim &amp; 文本文档命令"></a>vim &amp; 文本文档命令</h2><h5 id="一般模式下的"><a href="#一般模式下的" class="headerlink" title="一般模式下的"></a>一般模式下的</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + f //向下一页</span><br><span class="line">ctrl + d //向下半页</span><br><span class="line">+ //光标移动到非空格符的下一行，此时需要按住shift 和 =  输出 +</span><br><span class="line">ctrl + b //向上一页</span><br><span class="line">ctrl + u //向上半页</span><br><span class="line">- //光标移动到非空格符的上一行，只需要按住-</span><br><span class="line">n&lt;space&gt; //光标会向右移动这一行的 n 个字符，如果超出这一行的长度会停留在最后一个字符</span><br><span class="line">0 //光标移动到这一行的第一个字符</span><br><span class="line">$ //光标移动到这一行的最后一个字符</span><br><span class="line">H //光标移动到这个屏幕的一个字符</span><br><span class="line">L //光标移动到这个屏幕的最后一个字符</span><br><span class="line">G //光标移动到这个档案的最后</span><br><span class="line">nG //n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</span><br><span class="line">gg //移动到这个档案的第一行</span><br><span class="line">n&lt;Enter&gt; //n 为数字。光标向下移动 n 行</span><br><span class="line">r //替换当前光标所处位置的一个字符</span><br><span class="line">R //从光标处开始替换直到ESC退出替换模式</span><br><span class="line">x //删除当前光标位置的一个字符</span><br><span class="line">X //删除光标前的一个字符</span><br><span class="line"></span><br><span class="line">//替换当前行第一个匹配的字符串</span><br><span class="line">:s/old_string/new_string/</span><br><span class="line">//替换当前行所有匹配的字符串：</span><br><span class="line">:s/old_string/new_string/g</span><br><span class="line">//替换当前文件中所有匹配的字符串</span><br><span class="line">:%s/old_string/new_string/g</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="gcc命令"><a href="#gcc命令" class="headerlink" title="gcc命令"></a>gcc命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc demo.c -E //对文件进行预处理  </span><br></pre></td></tr></table></figure><h2 id="eog命令"><a href="#eog命令" class="headerlink" title="eog命令"></a>eog命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eog  //查看图片文件</span><br></pre></td></tr></table></figure><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除空目录，可以使用 rmdir 命令,如果目录不为空，rmdir 将会报错</span><br><span class="line">rmdir directory_name</span><br><span class="line">//删除非空目录,要删除一个包含文件的非空目录，可以使用 rm 命令与 -r 选项（递归删除）</span><br><span class="line">rm -r directory_name</span><br></pre></td></tr></table></figure><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//更改文件名</span><br><span class="line">mv process_001 process_001.c</span><br></pre></td></tr></table></figure><h2 id="chmod权限设置"><a href="#chmod权限设置" class="headerlink" title="chmod权限设置"></a>chmod权限设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r（读取）：4</span><br><span class="line">w（写入）：2</span><br><span class="line">x（执行）：1</span><br><span class="line">用户权限：rwx -&gt; 4 + 2 + 1 = 7</span><br><span class="line">组权限：r-x -&gt; 4 + 0 + 1 = 5</span><br><span class="line">其他用户权限：r-x -&gt; 4 + 0 + 1 = 5</span><br><span class="line">755的权限模式表示文件所有者具有读、写、执行权限（7），而组和其他用户只有读和执行权限（5）。</span><br><span class="line">chmod +x hello.sh //为该文件的所有者添加执行权限</span><br><span class="line">chmod g+x hello.sh //为该文件的所属组添加执行权限</span><br><span class="line">chmod o+x hello.sh //为该文件的其他用户添加执行权限</span><br></pre></td></tr></table></figure><h2 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h2><ul><li><p>**<code>$0</code>**：显示脚本的名称（包含路径）。</p></li><li><p>**<code>$1</code> 和 <code>$2</code>**：显示传递给脚本的第一个和第二个参数。</p></li><li><p>**<code>$#</code>**：显示传递给脚本的参数数量。</p></li><li><p><code>$@</code> 和 <code>$*</code></p><p>：显示传递给脚本的所有参数。注意，它们的表现有所不同：</p><ul><li><code>&quot;$@&quot;</code> 将每个参数作为独立的字符串处理。</li><li><code>&quot;$*&quot;</code> 将所有参数作为一个单一的字符串处理。</li></ul></li><li><p>**<code>$?</code>**：显示上一个命令（<code>ls /nonexistent</code>）的退出状态，因为该目录不存在，所以退出状态为 2。</p></li><li><p>**<code>$$</code>**：显示当前脚本的进程 ID。</p></li><li><p>**<code>$!</code>**：显示最后一个后台进程的进程 ID（<code>sleep 5 &amp;</code>）</p></li></ul><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//grep的基本语法 grep [选项] 模式 文件名</span><br><span class="line">grep hello example.txt</span><br><span class="line"></span><br><span class="line">//搜索文件夹下的文件 grep -r pattern folder_name</span><br><span class="line">//搜索文件夹/home/user/documents下所有文件中包含单词&quot;world&quot;的行</span><br><span class="line">grep -r world /home/user/documents</span><br><span class="line"></span><br><span class="line">//搜索的内容不区分大小写 grep -i pattern file</span><br><span class="line">grep -i hello example.txt</span><br><span class="line"></span><br><span class="line">//输出匹配行数  grep -c pattern file</span><br><span class="line">grep -c hello example.txt</span><br><span class="line"></span><br><span class="line">//使用正则表达式进行更复杂的匹配 grep -E &quot;pattern&quot; file</span><br><span class="line">grep -E &quot;[a-zA-Z0-9]+&quot; example.txt</span><br><span class="line"></span><br><span class="line">//将grep输出结果导出到文件</span><br><span class="line">grep &quot;hello&quot; example.txt &gt; output.txt</span><br><span class="line"></span><br><span class="line">//使用grep进行递归搜索 通过使用-r选项，我们可以实现递归搜索。例如，以下命令将在文件夹documents中递归搜索包含字符串&quot;hello&quot;的行：</span><br><span class="line">grep -r &quot;hello&quot; documents</span><br><span class="line"></span><br><span class="line">//使用grep进行多关键词搜索 以下命令在文件example.txt中搜索同时包含&quot;hello&quot;和&quot;world&quot;的行：</span><br><span class="line">grep &quot;hello&quot; example.txt | grep &quot;world&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="管道操作符"><a href="#管道操作符" class="headerlink" title="| 管道操作符"></a>| 管道操作符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令 ./process_001 | wc -l 由两部分组成：一个可执行文件 process_001 和管道操作符 |，以及 wc -l。这个命令的作用是运行 process_001 并统计其输出的行数。</span><br><span class="line">|：管道操作符，用于将前一个命令的输出作为下一个命令的输入。</span><br></pre></td></tr></table></figure><h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//sed &#x27;s/原字符串/新字符串/&#x27; 文件名   </span><br><span class="line">sed &#x27;s/hello/world/&#x27; file.txt   //只替换每一行的一个符合的字符串</span><br><span class="line">sed &#x27;s/hello/world/g&#x27; file.txt  //替换每行的所有匹配项</span><br><span class="line"></span><br><span class="line">//使用-i选项可以直接修改文件内容</span><br><span class="line">sed -i &#x27;s/hello/world/g&#x27; file.txt</span><br></pre></td></tr></table></figure><h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//打印文件file.txt中的第二列</span><br><span class="line">awk &#x27;&#123;print $2&#125;&#x27; file.txt</span><br><span class="line"></span><br><span class="line">//如果文件以逗号分隔，可以使用-F选项指定分隔符</span><br><span class="line">awk -F &#x27;,&#x27; &#x27;&#123;print $2&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean #来声明伪目标,伪目标是一种不与文件系统中的实际文件相关联的目标，它们通常用来执行某些命令，而不是生成某个文件。它的作用1.避免文件名冲突 2.提高执行效率</span></span><br><span class="line"></span><br><span class="line">GCC=gcc <span class="comment">#定义变量</span></span><br><span class="line">EXE=main</span><br><span class="line"><span class="comment">#OBJS=text.o input.o calcu.o</span></span><br><span class="line">RM=rm</span><br><span class="line"><span class="comment">#CFLAGS+=-D_FILE_OFFSET_BITS=64  //预处理器宏定义的正确格式是 -D宏名=值，中间没有空格。CFLAGS 是编译器标志变量，使用 += 可以将新标志追加到现有的 CFLAGS 中</span></span><br><span class="line">SRCS=$&#123;wildcard *.c&#125;  <span class="comment">#*：通配符  wildcard</span></span><br><span class="line">OBJS=$&#123;patsubst %.c, %.o, $&#123;SRCS&#125;&#125; <span class="comment">#%：模式匹配符</span></span><br><span class="line"><span class="section">$&#123;EXE&#125;: $&#123;OBJS&#125;</span></span><br><span class="line">$&#123;GCC&#125; -o $&#123;EXE&#125; $&#123;OBJS&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">$&#123;GCC&#125; -c <span class="variable">$^</span></span><br><span class="line"><span class="comment">#text.o: text.c</span></span><br><span class="line"><span class="comment">#$&#123;GCC&#125; -c $^</span></span><br><span class="line"><span class="comment">#input.o: input.c</span></span><br><span class="line"><span class="comment">#$&#123;GCC&#125; -c $^</span></span><br><span class="line"><span class="comment">#calcu.o: calcu.c</span></span><br><span class="line"><span class="comment">#$&#123;GCC&#125; -c $^</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">$&#123;RM&#125; $&#123;OBJS&#125;</span><br><span class="line">$&#123;RM&#125; $&#123;EXE&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">I/O:stdio标准IO  <span class="comment">//FILE类型贯穿始终</span></span><br><span class="line">sysio系统调用IO(文件IO)</span><br><span class="line"><span class="comment">//在两种都能用的环境下，优先使用标准IO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo_stdio.c  实现打开关闭文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;demo_file&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen() failed! :%s\n&quot;</span>, strerror(errno));<span class="comment">//[2]</span></span><br><span class="line">        <span class="comment">//perror(&quot;fopen() failed!&quot;); //[3]与上面error相同 但无法使用格式化输出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    fclose(fp);<span class="comment">//[4]谁打开谁关闭</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen() failed! :%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">FILE *fopen(const char *pathname, const char *mode); //const只读，不会改变参数数据。 FILE类型存储在堆上</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">      r      Open text file for reading.  The stream（数据流） is positioned at the be‐</span></span><br><span class="line"><span class="comment">              ginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       r+     Open  for  reading and writing.  The stream is positioned at the</span></span><br><span class="line"><span class="comment">              beginning of the file.</span></span><br><span class="line"><span class="comment">使用r/r+打开不存在的文件会报错</span></span><br><span class="line"><span class="comment">       w      Truncate（截断） file to zero length or create text  file  for  writing.</span></span><br><span class="line"><span class="comment">              The stream is positioned at the beginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       w+     Open  for  reading  and writing.  The file is created if it does</span></span><br><span class="line"><span class="comment">              not exist, otherwise it is truncated.  The stream is  positioned</span></span><br><span class="line"><span class="comment">              at the beginning of the file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       a      Open  for  appending (writing at end of file).  The file is cre‐</span></span><br><span class="line"><span class="comment">              ated if it does not exist.  The stream is positioned at the  end</span></span><br><span class="line"><span class="comment">              of the file.</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">[2]#include &lt;stdio,h&gt;</span></span><br><span class="line"><span class="comment">   extern FILE *stdin;</span></span><br><span class="line"><span class="comment">       extern FILE *stdout;</span></span><br><span class="line"><span class="comment">       extern FILE *stderr;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">Under  normal circumstances（正常情况） every UNIX program has three streams opened</span></span><br><span class="line"><span class="comment">for it when it starts up, one for input, one for output,  and  one  for</span></span><br><span class="line"><span class="comment">printing diagnostic（诊断提示） or error messages.</span></span><br><span class="line"><span class="comment">The input stream is referred to as &quot;standard input（标准输入）&quot;; the output  stream</span></span><br><span class="line"><span class="comment">is  referred  to as &quot;standard output&quot;; and the error stream is referred</span></span><br><span class="line"><span class="comment">to as &quot;standard error&quot;.  These terms（术语） are abbreviated（缩写为） to form  the  sym‐</span></span><br><span class="line"><span class="comment">bols used to refer to these files, namely stdin, stdout, and stderr.</span></span><br><span class="line"><span class="comment">Each  of these symbols is a stdio(3) macro（宏） of type pointer to FILE, and</span></span><br><span class="line"><span class="comment">can be used with functions like fprintf(3) or fread(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"> void perror(const char *s);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment"> The  perror()  function produces a message on standard error describing</span></span><br><span class="line"><span class="comment">the last error encountered（在...中遇到的） during a call to a system or  library  func‐</span></span><br><span class="line"><span class="comment">tion.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">int fclose(FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">Upon（在...之上）  successful completion（完成）, 0 is returned.  Otherwise（否则）, EOF is returned</span></span><br><span class="line"><span class="comment">and errno is set to indicate the error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo_cp.c 实现文件的cp， </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"><span class="comment">//判断参数数量</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s open filed! :%s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fclose(fps);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s open filed! :%s\n&quot;</span>, argv[<span class="number">2</span>], strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用fgetc(),fputc()一个一个字符cp</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ch = fgetc(fps);<span class="comment">//[1] ch 如果是char类型 ，可能导致有些字符无法显示</span></span><br><span class="line">        <span class="keyword">if</span>(ch == EOF)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fputc(ch, fpd);<span class="comment">//[2]</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*使用fgets(), fputs()进行BUFFSIZE大小的读写的操作</span></span><br><span class="line"><span class="comment">#define BUFFSIZE 1024</span></span><br><span class="line"><span class="comment">char buff[BUFFSIZE];</span></span><br><span class="line"><span class="comment">    while(fgets(buff, BUFFSIZE, fps) != NULL)&#123;    [3]</span></span><br><span class="line"><span class="comment">        fputs(buff, fpd);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*使用fread(),fwrite()进行BUFFSIZE大小的读写操作</span></span><br><span class="line"><span class="comment">while(fread(buff,1,BUFFSIZE,fps) == BUFFSIZE)&#123; [4]</span></span><br><span class="line"><span class="comment">        fwrite(buff,1,BUFFSIZE,fpd);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fseek(fps, 0, SEEK_END);[5]</span></span><br><span class="line"><span class="comment">    fprintf(stdout, &quot;size:%ld&quot;, ftell(fps));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">int fgetc(FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">fgetc()  reads  the next character(字符) from stream and returns it as an un‐</span></span><br><span class="line"><span class="comment">signed char cast to an int, or EOF on end of file or error.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">fgetc(),  getc() and getchar() return the character read as an unsigned char cast to an int or EOF on end of file or error.</span></span><br><span class="line"><span class="comment">[2]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fputc(int c, FILE *stream);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">    fputc() writes the character c, cast to an unsigned char, to stream.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">    fputc(),  putc()  and  putchar() return the character written as an unsigned char cast to(转换类型) an int or EOF on error.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">char *fgets(char *s, int size, FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">fgets()  reads in at most one less than size characters（最多读入一个小于size大小的字符串） from stream and stores them into the buffer pointed to by s.  Reading  stops  after  anEOF  or a newline.  If a newline is read, it is stored into the buffer.A terminating null byte (&#x27;\0&#x27;) is stored after the  last  character  inthe buffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">fgets() returns s on success, and NULL on error or when end of file occurs while no characters have been read.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span></span><br><span class="line"><span class="comment">       size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">The  function  fread() reads nmemb items(项数) of data, each size bytes long,from the stream pointed to by stream,  storing（存储）  them  at  the  location given by ptr.</span></span><br><span class="line"><span class="comment">    The function fwrite() writes nmemb items of data, each size bytes long,to the stream pointed to by stream, obtaining them  from  the  location given by ptr.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">On  success,  fread()  and  fwrite() return the number of items read or written.  This number equals the number of bytes transferred only  when size  is 1.  If an error occurs, or the end of the file is reached, the return value is a short item count (or zero).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[5]include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment">       long ftell(FILE *stream);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  fseek()  function  sets the file position indicator(标志) for the stream pointed to by stream.  The new position, measured（测量） in bytes, is obtained（得到）by  adding offset（偏移量） bytes to the position specified（规定的） by whence（到原来的地方）.  If whence is set to SEEK_SET, SEEK_CUR, or SEEK_END, the offset  is  relative  to the  start of the file, the current position indicator, or end-of-file,respectively.  A successful call to the  fseek()  function  clears  the end-of-file  indicator  for  the  stream  and undoes any effects of the ungetc(3) function on the same stream.      </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       The ftell() function obtains the current value of the file position indicator for the stream pointed to by stream.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="标准IO与系统调用IO的区别"><a href="#标准IO与系统调用IO的区别" class="headerlink" title="标准IO与系统调用IO的区别"></a>标准IO与系统调用IO的区别</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">//标准IO [1] </span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>); <span class="comment">//系统调用IO [2]</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">//标准错误流  无缓冲</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;d&quot;</span>); <span class="comment">//标准输出流  行缓冲</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;e\n&quot;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//[3] </span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strace ./main  <span class="comment">//可以查看程序执行过程</span></span><br><span class="line"></span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0x5600efca1000</span></span><br><span class="line">brk(<span class="number">0x5600efcc2000</span>)                     = <span class="number">0x5600efcc2000</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>c)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;ade\n&quot;</span>, <span class="number">4</span>ade</span><br><span class="line">)                    = <span class="number">4</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>a)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1b</span>)                        = <span class="number">1</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>a)                        = <span class="number">1</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双引号用来表示字符串字面量（string literal）。</span></span><br><span class="line"><span class="comment">在大多数编程语言中，双引号内的内容被视为字符串，编译器或解释器会将其解析为字符串类型的数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">单引号用来表示字符字面量（character literal）。</span></span><br><span class="line"><span class="comment">在C语言中，字符值（Character value）的确是用整数类型来表示的，具体来说是使用 int 类型。</span></span><br><span class="line"><span class="comment">[1]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int putchar(int c);</span></span><br><span class="line"><span class="comment">    从函数原型可以看到，参数要求int类型,需要输入&#x27;a&#x27;  而不是&quot;a&quot;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">[2]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">ssize_t write(int __fd, const void *__buf, size_t __n)</span></span><br><span class="line"><span class="comment">从函数原型可以看到，参数要求类型,需要输入&quot;b&quot;  &quot;b&quot; 是一个字符串常量，它以 &#x27;\0&#x27; 结尾，or</span></span><br><span class="line"><span class="comment">char buff = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment">write(1, &amp;buff, 1);</span></span><br><span class="line"><span class="comment">以这种第二参数是指针也是可以的.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       int fflush(FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       For  output  streams,  fflush() forces a write of all</span></span><br><span class="line"><span class="comment">       user-space buffered data for the given output or  up‐</span></span><br><span class="line"><span class="comment">       date  stream  via the stream&#x27;s underlying(底层的) write func‐</span></span><br><span class="line"><span class="comment">       tion.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       For input  streams  associated（相关的）  with  seekable（可寻找的）  files</span></span><br><span class="line"><span class="comment">       (e.g.,  disk（磁盘）  files,  but  not  pipes  or terminals（终端）),</span></span><br><span class="line"><span class="comment">       fflush() discards（丢弃） any buffered（缓冲区）  data  that  has  been</span></span><br><span class="line"><span class="comment">       fetched（取出）  from  the  underlying file, but has not been</span></span><br><span class="line"><span class="comment">       consumed（深受影响的） by the application.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The open status of the stream is unaffected（不受影响的）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If the stream argument（参数） is NULL, fflush() flushes  all</span></span><br><span class="line"><span class="comment">       open output streams.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       Upon successful completion 0 is returned.  Otherwise,</span></span><br><span class="line"><span class="comment">       EOF is returned and errno is set to indicate the  error.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -axf命令在类Unix操作系统中用于显示当前正在运行的进程信息。查看进程关系。</span><br><span class="line"></span><br><span class="line">ps -axm 用于显示所有进程以及它们的线程信息</span><br><span class="line"></span><br><span class="line">ps ax -L 用于显示系统中所有进程及其线程的信息</span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_008$ ps ax -L</span><br><span class="line">    PID     LWP TTY      STAT   TIME COMMAND</span><br><span class="line">    PID：进程ID。</span><br><span class="line">    LWP：线程ID（轻量级进程ID）。</span><br><span class="line">    TTY：终端关联信息。</span><br><span class="line">    STAT：进程/线程状态。</span><br><span class="line">    TIME：占用CPU时间。</span><br><span class="line">    COMMAND：启动命令。</span><br><span class="line">    ps：显示活动进程的信息。</span><br><span class="line">    a：显示所有用户的进程。通常，ps只显示当前用户的进程。</span><br><span class="line">    x：显示没有控制终端的进程。</span><br><span class="line">    f：以树状格式显示进程，展示进程之间的层级关系。</span><br><span class="line">    下个进程的PID号其实是根据上个进程里线程的数量而增加的。比如</span><br><span class="line">    449     449 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    449     450 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    449     451 ?        Ssl    0:00 vmware-vmblock-fuse /run/vmblock-fuse -o rw</span><br><span class="line">    594     594 ?        I&lt;     0:00 [cryptd]</span><br><span class="line">    进程号 449-&gt;594 在此期间其他进程中的线程数量增长和消亡</span><br><span class="line">PROCESS STATE CODES</span><br><span class="line">       Here are the different values that the s,</span><br><span class="line">       stat and state output specifiers(详细) (header</span><br><span class="line">       &quot;STAT&quot; or &quot;S&quot;) will display to describe the</span><br><span class="line">       state of a process:</span><br><span class="line"></span><br><span class="line">               D    uninterruptible sleep (usually IO) //不可中断的睡眠态</span><br><span class="line">               I    Idle kernel thread</span><br><span class="line">               R    running or runnable (on run queue)</span><br><span class="line">               S    interruptible sleep (waiting for an event to complete)//可中断的睡眠态</span><br><span class="line">               T    stopped by job control signal</span><br><span class="line">               t    stopped by debugger during the tracing</span><br><span class="line">               W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">               X    dead (should never be seen)</span><br><span class="line">               Z    defunct (&quot;zombie&quot;)（僵尸态） process,terminated but not reaped by its parent</span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">异步事件的处理：查询法， 通知法</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>信号的概念</span><br><span class="line">    信号是软件中断。</span><br><span class="line">    信号的响应依赖于中断。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>signal();</span><br><span class="line"><span class="number">3.</span>信号的不可靠</span><br><span class="line"><span class="number">4.</span>可重入函数</span><br><span class="line"><span class="number">5.</span>信号的响应过程</span><br><span class="line"><span class="number">6.</span>常用函数</span><br><span class="line">    kill();</span><br><span class="line">raise();</span><br><span class="line">alarm();</span><br><span class="line">pause();</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">system();</span><br><span class="line">sleep();</span><br><span class="line"><span class="number">7.</span>信号集</span><br><span class="line"><span class="number">8.</span>信号屏蔽字/pending集的处理</span><br><span class="line"><span class="number">9.</span>扩展</span><br><span class="line">    sigsuspend();</span><br><span class="line">sigaction();</span><br><span class="line">setitimer();</span><br><span class="line"><span class="number">10.</span>实时信号</span><br></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fork();</span></span><br><span class="line"><span class="comment">理解关键字：duplicating，意味着拷贝，克隆，一模一样的含义。</span></span><br><span class="line"><span class="comment">fork后父子进程的区别：fork的返回值不一样，pid不同，ppid也不同，未决信号和文件锁不继承，资源利用量清0；</span></span><br><span class="line"><span class="comment">init进程：1号，是所有进程的祖先进程</span></span><br><span class="line"><span class="comment">调度器的调度策略来决定那个进程先运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process is starting!\n&quot;</span>); <span class="comment">//行缓冲</span></span><br><span class="line">    fflush(<span class="literal">NULL</span>); <span class="comment">//刷新全部缓冲区 [1]</span></span><br><span class="line">    pid = fork(); <span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]子进程 is working!\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] 父进程 is working!\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]//假设代码中没有fflush(NULL);</span></span><br><span class="line"><span class="comment">//输出到标准I0设备上，行缓冲</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_002</span></span><br><span class="line"><span class="comment">process is starting!  //只打印一次</span></span><br><span class="line"><span class="comment">[3507] 父进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment">[3508]子进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//通过重定向，输出到文件中，全缓冲</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_002 &gt; text</span></span><br><span class="line"><span class="comment">process is starting!//打印两次，\n在全缓冲中只是相当于文件的换行</span></span><br><span class="line"><span class="comment">[3574] 父进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment">process is starting!</span></span><br><span class="line"><span class="comment">[3575]子进程 is working!</span></span><br><span class="line"><span class="comment">End!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">   #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       pid_t fork(void);</span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       fork()  creates a new process by duplicating(克隆) the calling process（当前进程）.  The new process is referred to（被称为） as the child process.  The calling process  is  referred  to  as   the   parent process.</span></span><br><span class="line"><span class="comment">       The child process and the parent process run in separate memory spaces（独立的存储空间）.  At the  time  of fork() both memory spaces have the same content（内容. Memory writes, file mappings（映射(mmap(2)),  and  unmappings (munmap(2)) performed（解除映射） by one of the processes do not affect the other.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">       On success, the PID of the child process  is</span></span><br><span class="line"><span class="comment">       returned in the parent, and 0 is returned in</span></span><br><span class="line"><span class="comment">       the child.  On failure, -1  is  returned  in</span></span><br><span class="line"><span class="comment">       the parent, no child process is created, and</span></span><br><span class="line"><span class="comment">       errno is set appropriately（适当地）.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIFE   30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REIGHT 30000200</span></span><br><span class="line"><span class="comment">//多进程计算质数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">for</span>(i = LIFE; i &lt;= REIGHT; i++)&#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                mark = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % j  == <span class="number">0</span>)&#123;</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mark)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//sleep(1000);[1]</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//此处需要进行exit(0)不然子进程也要创建属于它的子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(1000);[2]</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ 30000001 is a primer!</span></span><br><span class="line"><span class="comment">30000037 is a primer!</span></span><br><span class="line"><span class="comment">30000041 is a primer!</span></span><br><span class="line"><span class="comment">30000109 is a primer!</span></span><br><span class="line"><span class="comment">30000023 is a primer!</span></span><br><span class="line"><span class="comment">30000163 is a primer!</span></span><br><span class="line"><span class="comment">30000133 is a primer!</span></span><br><span class="line"><span class="comment">30000193 is a primer!</span></span><br><span class="line"><span class="comment">30000049 is a primer!</span></span><br><span class="line"><span class="comment">30000059 is a primer!</span></span><br><span class="line"><span class="comment">30000083 is a primer!</span></span><br><span class="line"><span class="comment">30000071 is a primer!</span></span><br><span class="line"><span class="comment">30000169 is a primer!</span></span><br><span class="line"><span class="comment">30000079 is a primer!</span></span><br><span class="line"><span class="comment">30000167 is a primer!</span></span><br><span class="line"><span class="comment">30000199 is a primer!</span></span><br><span class="line"><span class="comment">30000137 is a primer!</span></span><br><span class="line"><span class="comment">30000149 is a primer!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">   4467 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4468 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4469 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4470 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4471 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4472 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">   4473 pts/0    S      0:00  \_ ./process_001</span></span><br><span class="line"><span class="comment">S 指的是可中断的睡眠态  \_ ./process_001 定格说明它的父进程是init进程。这是因为父进程已经执行结束，这些子进程成为孤儿进程，等待子进程sleep（1000）执行结束，由init进程回收资源</span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">   4726 pts/0    S+     0:00  |           \_ ./process_001</span></span><br><span class="line"><span class="comment">   4727 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4728 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4729 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4730 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment">   4731 pts/0    Z+     0:00  |               \_ [process_001] &lt;defunct&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Z 指的是僵尸态，僵尸态的进程只占用结构体的内存空间，但它占用这pid，pid是有上限的</span></span><br><span class="line"><span class="comment">sleep（1000）执行结束后，父进程执行exit(0)，子进程将变成孤儿进程，被init进程 1号进程接管</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!\n&quot;</span>);</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        execl(<span class="string">&quot;/bin/date&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;+%s&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//[1] </span></span><br><span class="line">        perror(<span class="string">&quot;execl()&quot;</span>);<span class="comment">//如果execl（）正常执行将跳转到另个程序，不会回来了。执行失败才会继续这行代码。</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);<span class="comment">//[2]</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ ./process_003 &gt;text</span><br><span class="line">yonglezhang@yonglezhang-virtual-machine:~/src/io/study_007$ cat text</span><br><span class="line"><span class="number">1716791563</span></span><br><span class="line">Begin!</span><br><span class="line">End!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       extern char **environ;</span></span><br><span class="line"><span class="comment">       int execl(const char *pathname, const char *arg, ...</span></span><br><span class="line"><span class="comment">                        (char  *) NULL );</span></span><br><span class="line"><span class="comment">       int execlp(const char *file, const char *arg, ...</span></span><br><span class="line"><span class="comment">                        (char  *) NULL );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">execl 是一个系统调用，用于在当前进程中执行另一个程序。它的原型定义如下：</span></span><br><span class="line"><span class="comment">int execl(const char *path, const char *arg, ..., NULL);</span></span><br><span class="line"><span class="comment">path：要执行的程序的路径。</span></span><br><span class="line"><span class="comment">arg：传递给程序的第一个参数（通常是程序名）。</span></span><br><span class="line"><span class="comment">...：后续的参数，直到一个空指针（NULL）为止，表示参数列表的结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">   #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment">       pid_t waitpid(pid_t pid, int *wstatus, int options);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       The wait() system call（系统调用） suspends（挂起） execution（执行） of the calling thread（线程） until one of its children terminates（终止）.   The  call  wait(&amp;wstatus)   is equivalent（等同于） to:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           waitpid(-1, &amp;wstatus, 0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The waitpid() system call suspends execution of the calling thread until a  child  specified （规定的） by pid argument（参数） has changed state.  By default（默认情况下）, waitpid() waits only for terminated children,  but  this  behavior（行为） is modifiable（可修改的）via（通过） the options argument, as  described  below（如下所述）.</span></span><br><span class="line"><span class="comment">       The value of pid can be:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       &lt; -1   meaning  wait  for  any child process</span></span><br><span class="line"><span class="comment">              whose process group ID  is  equal  to</span></span><br><span class="line"><span class="comment">              the absolute value of pid.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       -1     meaning wait for any child process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       0      meaning  wait  for  any child process</span></span><br><span class="line"><span class="comment">              whose process group ID  is  equal  to</span></span><br><span class="line"><span class="comment">              that  of  the  calling process at the</span></span><br><span class="line"><span class="comment">              time of the call to waitpid().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       &gt; 0    meaning  wait  for  the  child  whose</span></span><br><span class="line"><span class="comment">              process  ID  is equal to the value of</span></span><br><span class="line"><span class="comment">              pid.</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELIMS  <span class="string">&quot; \t\n&quot;</span><span class="comment">//DELIMS 定义了用于分割输入行的分隔符，这里是空格、制表符和换行符。</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">glob_t</span> globres;<span class="comment">//[1]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prompt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mysell-0.1$ &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">//如果不加这个也可以 因为标准库会在遇到换行符或等待输入前刷新缓冲区，想想曾经写的C语言程序，输入数据前，提示就输出在终端上。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse</span><span class="params">(<span class="type">char</span> *line, <span class="keyword">struct</span> cmd_st *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *tok;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tok = strsep(&amp;line, DELIMS);<span class="comment">//[2]</span></span><br><span class="line">        <span class="keyword">if</span>(tok == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(tok[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        glob(tok, GLOB_NOCHECK|GLOB_APPEND*i, <span class="literal">NULL</span>, &amp;res-&gt;globres);<span class="comment">//[3]</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> linebuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cmd_st</span> <span class="title">cmd</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prompt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getline(&amp;linebuf, &amp;linebuf_size, <span class="built_in">stdin</span>)&lt;<span class="number">0</span>)<span class="comment">//[4]</span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        </span><br><span class="line">        parse(linebuf, &amp;cmd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                execvp(cmd.globres.gl_pathv[<span class="number">0</span>], cmd.globres.gl_pathv);<span class="comment">//[5]</span></span><br><span class="line">                perror(<span class="string">&quot;execvp()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1][3]#include &lt;glob.h&gt;</span></span><br><span class="line"><span class="comment">       int glob(const char *pattern, int flags, int (*errfunc) (const char *epath, int eerrno),    glob_t *pglob);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The glob() function searches for all the pathnames matching(匹配)  pat‐</span></span><br><span class="line"><span class="comment">       tern  according to the rules used by the shell (see glob(7)).  No</span></span><br><span class="line"><span class="comment">       tilde expansion or parameter substitution is done（没有进行波浪展开或参数替换）;  if  you  want</span></span><br><span class="line"><span class="comment">       these, use wordexp(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The results of a glob() call are stored（被存储） in the structure（结构体）  pointed</span></span><br><span class="line"><span class="comment">       to  by  pglob.   This  structure  is  of type glob_t (declared in</span></span><br><span class="line"><span class="comment">       &lt;glob.h&gt;) and includes the following（下列的） elements（元素） defined by  POSIX.2</span></span><br><span class="line"><span class="comment">       (more may be present as an extension):</span></span><br><span class="line"><span class="comment">           typedef struct &#123;</span></span><br><span class="line"><span class="comment">               size_t   gl_pathc;     Count of paths matched so far  到目前为止匹配的路径的计数</span></span><br><span class="line"><span class="comment">               char   **gl_pathv;     List of matched pathnames.  匹配的路径名列表。</span></span><br><span class="line"><span class="comment">               size_t   gl_offs;      Slots（为...空位） to reserve（预留） in gl_pathv.  </span></span><br><span class="line"><span class="comment">           &#125; glob_t;</span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On  successful  completion,  glob() returns zero. </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[2]#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">       char *strsep(char **stringp, const char *delim);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> DESCRIPTION</span></span><br><span class="line"><span class="comment">       If *stringp is NULL, the strsep() function returns NULL and  does</span></span><br><span class="line"><span class="comment">       nothing  else.  Otherwise, this function finds the first token in</span></span><br><span class="line"><span class="comment">       the string *stringp, that is delimited(分隔符) by one of the bytes in the</span></span><br><span class="line"><span class="comment">       string delim（定界符）.  This token is terminated by overwriting the delim‐</span></span><br><span class="line"><span class="comment">       iter with a null byte (&#x27;\0&#x27;), and *stringp is  updated  to  point</span></span><br><span class="line"><span class="comment">       past  the  token.   In  case no delimiter was found, the token is</span></span><br><span class="line"><span class="comment">       taken to be the entire string  *stringp,  and  *stringp  is  made</span></span><br><span class="line"><span class="comment">       NULL.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       The strsep() function returns a pointer to the token, that is, it</span></span><br><span class="line"><span class="comment">       returns the original value of *stringp.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[4]#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">       ssize_t getline(char **lineptr, size_t *n, FILE *stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       getline() reads an entire line from stream, storing(存储)  the  address</span></span><br><span class="line"><span class="comment">       of  the  buffer containing the text into *lineptr.  The buffer is</span></span><br><span class="line"><span class="comment">       null-terminated and includes the newline character（换行符）,  if  one  was</span></span><br><span class="line"><span class="comment">       found.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  *lineptr is set to NULL and *n is set 0 before the call, then</span></span><br><span class="line"><span class="comment">       getline() will allocate（分配） a buffer for storing the line.  This buf‐</span></span><br><span class="line"><span class="comment">       fer should be freed by the user program even if getline() failed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Alternatively（或者）,  before  calling getline(), *lineptr can contain a</span></span><br><span class="line"><span class="comment">       pointer to a malloc(3)-allocated buffer *n bytes in size.  If the</span></span><br><span class="line"><span class="comment">       buffer is not large enough to hold the line, getline() resizes it</span></span><br><span class="line"><span class="comment">       with realloc(3), updating *lineptr and *n as necessary.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In either case（无论哪种情况下）, on a successful call, *lineptr and *n will be up‐</span></span><br><span class="line"><span class="comment">       dated  to  reflect（反应）  the buffer address and allocated（分配） size respec‐</span></span><br><span class="line"><span class="comment">       tively（分别地）.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, getline() and getdelim() return the number of charac‐</span></span><br><span class="line"><span class="comment">       ters read, including the delimiter character（分隔符）, but  not  including</span></span><br><span class="line"><span class="comment">       the terminating null byte (&#x27;\0&#x27;).  This value can be used to handle（处理） embedded（嵌入） null bytes in the line read.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Both functions return -1 on failure to  read  a  line  (including</span></span><br><span class="line"><span class="comment">       end-of-file  condition).   In the event of an error, errno is set</span></span><br><span class="line"><span class="comment">       to indicate the cause.       </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[5]#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">       extern char **environ;</span></span><br><span class="line"><span class="comment">       int execvp(const char *file, char *const argv[]);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo ufw disable <span class="comment">//关闭防火墙</span></span><br><span class="line">sudo ufw allow <span class="number">1989</span>/udp <span class="comment">//设置端口白名单</span></span><br></pre></td></tr></table></figure><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>线程的概念</span><br><span class="line">  一个正在运行的函数</span><br><span class="line">  posix线程是一套标准，而不是实现</span><br><span class="line">  openmp线程</span><br><span class="line">  现成标识：<span class="type">pthread_t</span> </span><br><span class="line">  同一进程中的多个线程有各自的调用栈（call <span class="built_in">stack</span>，我们称为线程栈），自己的寄存器环境（<span class="keyword">register</span> context）、自己的线程本地存储（thread-local storage）</span><br><span class="line">    在多线程应用程序中，通常一个进程中包括了多个线程，每个线程都可以参与系统调度、被CPU执行</span><br><span class="line">    线程具有以下一些特点：</span><br><span class="line">线程不单独存在、而是包含在进程中；</span><br><span class="line">线程是参与系统调度的基本单位；</span><br><span class="line">可并发执行。同一进程的多个线程之间可并发执行，在宏观上实现同时运行的效果；</span><br><span class="line">共享进程资源。同一进程中的各个线程，可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地 址空间），这意味着，线程可以访问该地址空间的每一个虚地址； 此外，还可以访问进程所拥有的已打开文件、定时器、信号量等等。</span><br><span class="line"><span class="number">2.</span>线程的创建</span><br><span class="line">  pthread_creat()</span><br><span class="line">  线程的调度取决于调度器的策略</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>线程的终止</span><br><span class="line"><span class="number">3</span>种方式：<span class="number">1</span>）线程从启动历程返回，返回值就是线程的退出码</span><br><span class="line"><span class="number">2</span>）线程可以被同一进程中的其他线程取消</span><br><span class="line"><span class="number">3</span>）线程调用pthread_exit()函数</span><br><span class="line">pthread_join --&gt;wait()</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>线程的取消选型</span><br><span class="line">    线程取消：pthread_cancel()</span><br><span class="line">    取消有<span class="number">2</span>种状态：允许和不允许</span><br><span class="line">    允许取消又分为：异步cancel,推迟cancel（默认）-&gt;推迟至cancel点再响应</span><br><span class="line">    cancel点：POSIX定义的cancel点，都是可能引发阻塞的系统调用</span><br><span class="line">    pthread_setcancelstate():设置是否允许取消</span><br><span class="line">    pthread_setcanceltype():设置取消方式</span><br><span class="line">    pthread_testcancel():本函数什么都不做，就是一个取消点 </span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>线程分离</span><br><span class="line">    pthread_detach();</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>线程同步</span><br><span class="line">    互斥量：<span class="type">pthread_mutex_t</span></span><br><span class="line">       <span class="title function_">pthread_mutex_init</span><span class="params">()</span>;</span><br><span class="line">   pthread_mutex_destroy();</span><br><span class="line">   pthread_mutex_lock();</span><br><span class="line">   pthread_mutex_trylock();</span><br><span class="line">   pthread_mutex_nulock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup_func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:1&quot;</span>);<span class="comment">//[1]</span></span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:2&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:3&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;push over!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);<span class="comment">//[2]</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//[3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);<span class="comment">//[4]</span></span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);<span class="comment">//[5]</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1][2]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       void pthread_cleanup_push(void (*routine)(void *), void *arg);</span></span><br><span class="line"><span class="comment">       void pthread_cleanup_pop(int execute);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       These functions manipulate(操作) the calling thread&#x27;s stack（栈）  of  thread（线程）-cancellation(取消) clean-up handlers（处理）.  A clean-up handler is a function that is automatically（自动地） executed（处理） when a thread is canceled (or in various other circumstances（在其他情况下）described  below); it might, for example, unlock a mutex（解锁互斥锁） so that it becomes available（可用的） to other threads in the process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The pthread_cleanup_push() function pushes routine（程序）  onto  the  top  of  the</span></span><br><span class="line"><span class="comment">       stack  of  clean-up  handlers.   When  routine is later invoked（当以后调用例程时）, it will be</span></span><br><span class="line"><span class="comment">       given arg as its argument（参数）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The pthread_cleanup_pop() function removes the routine at the  top  of  the</span></span><br><span class="line"><span class="comment">       stack  of  clean-up handlers, and optionally executes it if execute is nonzero.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[3]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       void pthread_exit(void *retval);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_exit()  function  terminates  the calling thread and returns a</span></span><br><span class="line"><span class="comment">       value via retval that (if the thread is joinable) is available  to  another</span></span><br><span class="line"><span class="comment">       thread in the same process that calls pthread_join(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Any  clean-up handlers established by pthread_cleanup_push(3) that have not</span></span><br><span class="line"><span class="comment">       yet been popped, are popped (in the reverse of the order in which they were</span></span><br><span class="line"><span class="comment">       pushed)  and  executed.   If the thread has any thread-specific data, then,</span></span><br><span class="line"><span class="comment">       after the clean-up handlers have been executed, the corresponding（相应的）  destructor functions are called, in an unspecified order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       When  a  thread terminates, process-shared resources (e.g., mutexes, condi‐</span></span><br><span class="line"><span class="comment">       tion variables, semaphores, and file descriptors)  are  not  released,  and</span></span><br><span class="line"><span class="comment">       functions registered using atexit(3) are not called.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the last thread in a process terminates, the process terminates as by</span></span><br><span class="line"><span class="comment">       calling exit(3) with an exit status of zero; thus, process-shared resources</span></span><br><span class="line"><span class="comment">       are released and functions registered using atexit(3) are called.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_create(pthread_t *thread, const pthread_attr_t *attr, </span></span><br><span class="line"><span class="comment">                            void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_create()  function starts a new thread in the calling process.</span></span><br><span class="line"><span class="comment">       The new thread starts execution(执行) by invoking start_routine(); arg（自变量） is  passed</span></span><br><span class="line"><span class="comment">       as the sole（唯一） argument of start_routine().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The new thread terminates in one of the following ways:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It  calls pthread_exit(3), specifying（指定） an exit（退出） status value that is available to another thread in the same process that calls pthread_join(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It  returns  from  start_routine().   This  is  equivalent（等同于）   to   calling</span></span><br><span class="line"><span class="comment">         pthread_exit(3) with the value supplied（为...提供） in the return statement.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * It is canceled (see pthread_cancel(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * Any  of the threads in the process calls exit(3), or the main thread per‐</span></span><br><span class="line"><span class="comment">         forms a return from main().  This causes the termination of  all  threads</span></span><br><span class="line"><span class="comment">         in the process.</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">        The  attr  argument points to a pthread_attr_t structure whose contents are</span></span><br><span class="line"><span class="comment">       used at thread creation time to determine（确定） attributes（属性） for  the  new  thread;</span></span><br><span class="line"><span class="comment">       this  structure is initialized（初始化） using pthread_attr_init(3) and related functions.  If attr is NULL, then  the  thread  is  created  with  default（默认的）  attributes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Before  returning,  a  successful call to pthread_create() stores（容纳） the ID of</span></span><br><span class="line"><span class="comment">       the new thread in the buffer pointed to by thread; this identifier（标识符） is  used</span></span><br><span class="line"><span class="comment">       to refer to the thread in subsequent（随后） calls to other pthreads functions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  new  thread  inherits（继承）  a  copy  of  the  creating thread&#x27;s signal mask</span></span><br><span class="line"><span class="comment">       (pthread_sigmask(3)).  The set of pending（待处理） signals for  the  new  thread  is</span></span><br><span class="line"><span class="comment">       empty  (sigpending(2)).   The  new  thread  does  not  inherit the creating</span></span><br><span class="line"><span class="comment">       thread&#x27;s alternate signal stack (sigaltstack(2)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The new thread inherits the  calling  thread&#x27;s  floating-point  environment</span></span><br><span class="line"><span class="comment">       (fenv(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The   initial   value  of  the  new  thread&#x27;s  CPU-time  clock  is  0  (see</span></span><br><span class="line"><span class="comment">       pthread_getcpuclockid(3)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Linux-specific details</span></span><br><span class="line"><span class="comment">       The new thread inherits copies of the calling thread&#x27;s capability sets (see</span></span><br><span class="line"><span class="comment">       capabilities(7)) and CPU affinity mask (see sched_setaffinity(2)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[5]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">       Compile and link with -pthread.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  pthread_join()  function  waits  for the thread specified(指定的) by thread to</span></span><br><span class="line"><span class="comment">       terminate.  If that thread has already terminated, then pthread_join()  returns immediately.  The thread specified by thread must be joinable(可接收的）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  retval（返回值）  is  not NULL, then pthread_join() copies the exit status of the</span></span><br><span class="line"><span class="comment">       target  thread  (i.e.,  the  value  that  the  target  thread  supplied（提供）  to</span></span><br><span class="line"><span class="comment">       pthread_exit(3))  into  the  location  pointed to by retval.  If the target</span></span><br><span class="line"><span class="comment">       thread was canceled,  then  PTHREAD_CANCELED  is  placed  in  the  location</span></span><br><span class="line"><span class="comment">       pointed to by retval.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  multiple（多个的）  threads  simultaneously（同时地） try to join with the same thread, the</span></span><br><span class="line"><span class="comment">       results are undefined（不明确的）.  If the thread calling pthread_join()  is  canceled,</span></span><br><span class="line"><span class="comment">       then  the  target  thread  will  remain  joinable (i.e., it will not be de‐</span></span><br><span class="line"><span class="comment">       tached).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT    30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT   30000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTRNUM  (RIGHT - LEFT +1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line">    <span class="type">pthread_t</span> tid[HTRNUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc() failed!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;n = i;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, p); <span class="comment">//[1]</span></span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i&lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT], &amp;ptr);<span class="comment">//[2]</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, mark;</span><br><span class="line">    i = ((<span class="keyword">struct</span> thr_arg_st *)p)-&gt;n;</span><br><span class="line"></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer\n&quot;</span>, i);</span><br><span class="line">    pthread_exit(p);<span class="comment">//[3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">err = pthread_create(tid+(i-LEFT), NULL, thr_prime, p);</span></span><br><span class="line"><span class="comment">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                          void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">pthread_t *thread                          </span></span><br><span class="line"><span class="comment">这是一个指向 pthread_t 类型变量的指针，用于存储新创建线程的线程ID。</span></span><br><span class="line"><span class="comment">当 i = LEFT 时，计算结果为 tid[0]，当 i = LEFT + 1 时，结果为 tid[1]，以此类推。这确保了每个线程ID都被存储在 tid 数组的不同位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const pthread_attr_t *attr</span></span><br><span class="line"><span class="comment">这是一个指向线程属性对象的指针。通过这个参数，你可以指定新线程的属性，例如是否为分离线程、栈大小等</span></span><br><span class="line"><span class="comment">如果传递 NULL，新线程将使用默认属性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void *(*start_routine) (void *)</span></span><br><span class="line"><span class="comment">这是一个指向函数的指针，新线程将从该函数开始执行</span></span><br><span class="line"><span class="comment">thr_prime 是你定义的线程函数，其签名必须匹配 void *(*start_routine) (void *)，即该函数接收一个 void * 类型的参数，并返回一个 void * 类型的结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void *arg</span></span><br><span class="line"><span class="comment">这是传递给线程函数的参数。它是一个 void * 类型的指针，可以指向任意类型的数据。一般情况下，需要将 arg 指向一个全局或堆变量，意思就是说 在线程的生命周期中，该arg指向的对象必须存在，否则如果线程中访问了该对象将会出现错</span></span><br><span class="line"><span class="comment">误。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">pthread_join(tid[i-LEFT], &amp;ptr);</span></span><br><span class="line"><span class="comment">int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">void **retval返回的是pthread_create()中 void *arg参数地址</span></span><br><span class="line"><span class="comment">[3]</span></span><br><span class="line"><span class="comment">pthread_exit(p);</span></span><br><span class="line"><span class="comment">void pthread_exit(void *retval);</span></span><br><span class="line"><span class="comment">void *retval返回的是在这个进程里参数的地址，void *retval指向一个全局或堆变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM  4</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mut[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n + <span class="number">1</span> == THRNUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)p;</span><br><span class="line">    <span class="type">int</span> c = <span class="string">&#x27;a&#x27;</span> + (<span class="type">int</span>)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mut+n);<span class="comment">//[1]</span></span><br><span class="line">        write(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        pthread_mutex_unlock(mut+next(n));<span class="comment">//[2]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err, i;</span><br><span class="line">    <span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mut+i, <span class="literal">NULL</span>);<span class="comment">//[3]</span></span><br><span class="line">        pthread_mutex_lock(mut+i);</span><br><span class="line"></span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_func, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(mut+<span class="number">0</span>);</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$sudo apt-get install manpages-posix manpages-posix-dev</span></span><br><span class="line"><span class="comment">获取posix手册</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[1][2]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">       int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       The mutex（互斥） object referenced by mutex shall be locked（将会被锁定） by a call</span></span><br><span class="line"><span class="comment">       to pthread_mutex_lock() that returns zero or [EOWNERDEAD].  If</span></span><br><span class="line"><span class="comment">       the  mutex  is  already  locked by another thread, the calling</span></span><br><span class="line"><span class="comment">       thread shall block（阻塞） until the mutex becomes available. This operation（操作） shall return with the mutex object referenced by mutex in the locked state with the calling thread as its owner. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       If  successful,  the  pthread_mutex_lock(), pthread_mutex_try‐</span></span><br><span class="line"><span class="comment">       lock(),  and  pthread_mutex_unlock()  functions  shall  return</span></span><br><span class="line"><span class="comment">       zero; otherwise, an error number shall be returned to indicate</span></span><br><span class="line"><span class="comment">       the error.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[3]#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">       int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span></span><br><span class="line"><span class="comment">       const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">       pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       pthread_mutex_t log_lock; //直接使用，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    由于是全局变量，编译后结构体成员默认值为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pthread_mutex_t log_lock = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这个宏实际定义为</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # define PTHREAD_MUTEX_INITIALIZER  &#123; &#123; 0, 0, 0, 0, 0, 0, &#123; 0, 0 &#125; &#125; &#125; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这个初始化函数没有仔细追代码，猜想也是初始化成员为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT    30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT   30000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM  4</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line">    <span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)<span class="comment">//创建线程，此时都等待线程池的数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=LEFT; i&lt;=RIGHT; i++)<span class="comment">//开始向线程池抛数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);<span class="comment">//先上锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)<span class="comment">//！= 说明其他线程还没处理num，又被主线程抢到了，这是要告诉调度代码让出内核</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        num = i;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);<span class="comment">//解锁， 线程开抢</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thr_prime</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, mark;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);<span class="comment">//多线程编程中，当一个线程在执行 pthread_mutex_lock(&amp;mut_num); 时，如果互斥锁 mut_num 已经被其他线程持有，该线程会被阻塞，直到获取到互斥锁为止。</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>; j&lt;i/<span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d]:%d is a primer\n&quot;</span>, (<span class="type">int</span>)p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************proto.h***********************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPATH <span class="string">&quot;/etc/services&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPROJ <span class="string">&#x27;g&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//************************snder.c***********************************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">   </span><br><span class="line">    key = ftok(KEYPATH, KEYPROJ);<span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key, <span class="number">0</span>);<span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sbuf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name, <span class="string">&quot;Alan&quot;</span>);<span class="comment">//[3]</span></span><br><span class="line">    sbuf.math = rand()%<span class="number">100</span>;<span class="comment">//[4]</span></span><br><span class="line">    sbuf.chinese = rand()%<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(msgsnd(msgid, &amp;sbuf, <span class="keyword">sizeof</span>(sbuf)-<span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>) &lt; <span class="number">0</span>)<span class="comment">//[5]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsnd()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//************************rcver.c***********************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    key = ftok(KEYPATH, KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key, IPC_CREAT|<span class="number">0600</span>);<span class="comment">//[6]</span></span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid, &amp;rbuf, <span class="keyword">sizeof</span>(rbuf)-<span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgrcv()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NAME = %s\n&quot;</span>, rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MATH = %d\n&quot;</span>, rbuf.math);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CHINESE = %d\n&quot;</span>, rbuf.chinese);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);<span class="comment">//[7]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先运行被动端（rcver.c），因为msgget（）在rcver.c创建，也在此文件销毁，遵循谁创建谁销毁的原则。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[1]#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">       key_t ftok(const char *pathname, int proj_id);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">NAME：</span></span><br><span class="line"><span class="comment">       ftok  -  convert(转换) a pathname and a project identifier（标识） to a System V</span></span><br><span class="line"><span class="comment">       IPC key</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       The ftok() function uses the identity of the  file  named  by  the</span></span><br><span class="line"><span class="comment">       given  pathname (which must refer to an existing, accessible（可使用的） file)</span></span><br><span class="line"><span class="comment">       and the least significant（相当数量） 8 bits of proj_id (which  must  be  non‐</span></span><br><span class="line"><span class="comment">       zero)  to generate（生成） a key_t type System V IPC key, suitable（合适的） for use</span></span><br><span class="line"><span class="comment">       with msgget(2), semget(2), or shmget(2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The resulting value is the same for all pathnames  that  name  the</span></span><br><span class="line"><span class="comment">       same  file, when the same value of proj_id is used.  The value returned should be  different  when  the  (simultaneously（同时地）  existing)files or the project IDs differ.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       On  success, the generated key_t value is returned.  On failure -1</span></span><br><span class="line"><span class="comment">       is returned, with errno indicating the error as  for  the  stat(2)</span></span><br><span class="line"><span class="comment">       system call.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">NAME:</span></span><br><span class="line"><span class="comment">       msgget - get a System V message queue identifier</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS:</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int msgget(key_t key, int msgflg);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       The  msgget() system call returns the System V message queue identifier associated with the value of the key argument.  It  may  be used  either to obtain（获得） the identifier of a previously(先前的) created message queue (when msgflg is zero and key does not  have  the  value IPC_PRIVATE), or to create a new set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       A new message queue is created if key has the value IPC_PRIVATE or</span></span><br><span class="line"><span class="comment">       key isn&#x27;t IPC_PRIVATE, no message queue with the given key key exists, and IPC_CREAT is specified（指定） in msgflg.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  msgflg  specifies  both  IPC_CREAT  and IPC_EXCL and a message</span></span><br><span class="line"><span class="comment">       queue already exists for key, then msgget() fails with  errno  set</span></span><br><span class="line"><span class="comment">       to  EEXIST.   (This  is analogous（类似的） to the effect of the combination</span></span><br><span class="line"><span class="comment">       O_CREAT | O_EXCL for open(2).)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Upon creation（在创建时）, the least significant bits of the  argument  msgflg</span></span><br><span class="line"><span class="comment">       define  the  permissions（权限）  of  the message queue.  These permission</span></span><br><span class="line"><span class="comment">       bits have the same format（格式） and semantics（语义） as the permissions  specified  for  the mode argument of open(2).  (The execute（执行） permissions are not used.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If a new message queue is created, then its associated（有关联） data structure msqid_ds (see msgctl(2)) is initialized（初始化） as follows:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_perm.cuid  and  msg_perm.uid  are  set to the effective</span></span><br><span class="line"><span class="comment">              user ID of the calling process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_perm.cgid and msg_perm.gid are  set  to  the  effective</span></span><br><span class="line"><span class="comment">              group ID of the calling process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              The  least  significant  9 bits of msg_perm.mode are set to</span></span><br><span class="line"><span class="comment">              the least significant 9 bits of msgflg.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_qnum, msg_lspid, msg_lrpid,  msg_stime,  and  msg_rtime</span></span><br><span class="line"><span class="comment">              are set to 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_ctime is set to the current time.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              msg_qbytes is set to the system limit MSGMNB.</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">       If  the message queue already exists the permissions are verified（核实）,</span></span><br><span class="line"><span class="comment">       and a check is made to see if it is marked（标记） for destruction（销毁）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       If successful, the return value will be the message queue  identifier  (a  nonnegative（非负的） integer), otherwise -1 with errno indicating the error.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[3]</span></span><br><span class="line"><span class="comment">NAME:</span></span><br><span class="line"><span class="comment">       strcpy, strncpy - copy a string</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS:</span></span><br><span class="line"><span class="comment">       #include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">       char *strcpy(char *dest, const char *src);</span></span><br><span class="line"><span class="comment">       char *strncpy(char *dest, const char *src, size_t n);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION:</span></span><br><span class="line"><span class="comment">       The strcpy() function copies the string pointed to by src, includ‐</span></span><br><span class="line"><span class="comment">       ing the terminating null byte (&#x27;\0&#x27;), to the buffer pointed to  by</span></span><br><span class="line"><span class="comment">       dest(对像）.   The  strings  may  not overlap（重叠）, and the destination（目标） string</span></span><br><span class="line"><span class="comment">       dest must be large enough to receive the copy.  Beware（当心）  of  buffer</span></span><br><span class="line"><span class="comment">       overruns!  (See BUGS.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  strncpy() function is similar, except that at most n bytes of</span></span><br><span class="line"><span class="comment">       src are copied.  Warning: If there is no null byte among the first</span></span><br><span class="line"><span class="comment">       n  bytes of src, the string placed in dest will not be null-termi‐</span></span><br><span class="line"><span class="comment">       nated.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[4]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       openssl-rand, rand - generate pseudo(假的）-random bytes</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       This command（命令） generates num random bytes using a cryptographically（秘密地）</span></span><br><span class="line"><span class="comment">       secure（安全的） pseudo random number generator (CSPRNG).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The random bytes are generated using the RAND_bytes(3) function,</span></span><br><span class="line"><span class="comment">       which provides a security level of 256 bits, provided it managed（管理）</span></span><br><span class="line"><span class="comment">       to seed itself successfully from a trusted（可靠的） operating（操作） system</span></span><br><span class="line"><span class="comment">       entropy source.  Otherwise, the command will fail with a nonzero</span></span><br><span class="line"><span class="comment">       error code.  For more details, see RAND_bytes(3), RAND(7), and</span></span><br><span class="line"><span class="comment">       RAND_DRBG(7).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[5]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       msgrcv, msgsnd - System V message queue operations</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/msg.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,</span></span><br><span class="line"><span class="comment">                      int msgflg);</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  msgsnd()  and msgrcv() system calls are used to send messages</span></span><br><span class="line"><span class="comment">       to, and receive messages from,  a  System V  message  queue.   The</span></span><br><span class="line"><span class="comment">       calling process must have write permission on the message queue in</span></span><br><span class="line"><span class="comment">       order to send a message, and read permission to receive a message.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The msgp argument is a pointer to a  caller-defined  structure  of</span></span><br><span class="line"><span class="comment">       the following general form:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           struct msgbuf &#123;</span></span><br><span class="line"><span class="comment">               long mtype;        message type, must be &gt; 0 </span></span><br><span class="line"><span class="comment">               char mtext[1];     message data </span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  mtext  field  is  an array(数组) (or other structure) whose size is</span></span><br><span class="line"><span class="comment">       specified by msgsz, a nonnegative（非负的） integer value.  Messages of zero</span></span><br><span class="line"><span class="comment">       length (i.e., no mtext field) are permitted.  The mtype field must</span></span><br><span class="line"><span class="comment">       have a strictly（严格的） positive（确切的） integer value.  This value can be used by</span></span><br><span class="line"><span class="comment">       the  receiving  process for message selection (see the description</span></span><br><span class="line"><span class="comment">       of msgrcv() below).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       msgsnd()</span></span><br><span class="line"><span class="comment">       The msgsnd() system call appends a copy of the message pointed  to</span></span><br><span class="line"><span class="comment">       by  msgp  to  the  message  queue whose identifier is specified by</span></span><br><span class="line"><span class="comment">       msqid.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If sufficient（充足的） space is available in the queue,  msgsnd()  succeeds</span></span><br><span class="line"><span class="comment">       immediately.   The  queue  capacity（容量）  is governed（管理） by the msg_qbytes</span></span><br><span class="line"><span class="comment">       field in the associated data  structure  for  the  message  queue.</span></span><br><span class="line"><span class="comment">       During  queue  creation this field is initialized to MSGMNB bytes,</span></span><br><span class="line"><span class="comment">       but this limit can be modified（修改的） using msgctl(2).  A  message  queue</span></span><br><span class="line"><span class="comment">       is  considered（认为） to be full if either of the following conditions（条件） is</span></span><br><span class="line"><span class="comment">       true:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * Adding a new message to the queue would cause the  total  number</span></span><br><span class="line"><span class="comment">         of  bytes  in  the queue to exceed（超出） the queue&#x27;s maximum size (the</span></span><br><span class="line"><span class="comment">         msg_qbytes field).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       * Adding another message to the queue would cause the total number</span></span><br><span class="line"><span class="comment">         of messages in the queue to exceed the queue&#x27;s maximum size (the</span></span><br><span class="line"><span class="comment">         msg_qbytes field).  This check is necessary to prevent（防止） an unlim‐</span></span><br><span class="line"><span class="comment">         ited  number  of zero-length messages being placed on the queue.</span></span><br><span class="line"><span class="comment">         Although such messages contain（包含） no data, they  nevertheless  consume（消耗 (locked) kernel memory（内核内存）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      msgrcv()</span></span><br><span class="line"><span class="comment">       The msgrcv() system call removes a message from the  queue  speci‐</span></span><br><span class="line"><span class="comment">       fied by msqid and places it in the buffer pointed to by msgp.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  argument  msgsz  specifies  the maximum size in bytes for the</span></span><br><span class="line"><span class="comment">       member mtext of the structure pointed to by the msgp argument.  If</span></span><br><span class="line"><span class="comment">       the  message text has length greater（较大的） than msgsz, then the behavior</span></span><br><span class="line"><span class="comment">       depends on whether MSG_NOERROR is specified in msgflg.  If MSG_NO‐</span></span><br><span class="line"><span class="comment">       ERROR  is  specified, then the message text will be truncated (and</span></span><br><span class="line"><span class="comment">       the truncated part will be lost); if MSG_NOERROR is not specified,</span></span><br><span class="line"><span class="comment">       then  the message isn&#x27;t removed from the queue and the system call</span></span><br><span class="line"><span class="comment">       fails returning -1 with errno set to E2BIG.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On failure both functions return -1 with errno indicating the  er‐</span></span><br><span class="line"><span class="comment">       ror,  otherwise msgsnd() returns 0 and msgrcv() returns the number</span></span><br><span class="line"><span class="comment">       of bytes actually copied into the mtext array.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="网络套接字"><a href="#网络套接字" class="headerlink" title="网络套接字"></a>网络套接字</h2><p>​</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">网络套接字socket</span><br><span class="line"><span class="number">1.</span> 字节序问题：</span><br><span class="line">大端：低地址处放高字节</span><br><span class="line">小端：低地址处放低字节</span><br><span class="line">主机字节序：host</span><br><span class="line">网络字节序：network</span><br><span class="line">解决：_to_ _ : htons, htonl, ntohs, ntohl</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 对齐：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">demo_001</span> //12字节</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="type">char</span> b;</span><br><span class="line">            <span class="type">float</span> c;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">demo_002</span>//24字节</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">int</span> d;</span><br><span class="line">            <span class="type">double</span> e;</span><br><span class="line">            <span class="type">char</span> f;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">demo_003</span>//9字节</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="type">char</span> b;</span><br><span class="line">            <span class="type">float</span> c;</span><br><span class="line">        &#125;__attribute__((packed));</span><br><span class="line">        解决： 不对齐</span><br><span class="line">        </span><br><span class="line">     <span class="number">3.</span> 类型长度问题：</span><br><span class="line">     <span class="type">int</span></span><br><span class="line">     <span class="type">char</span></span><br><span class="line">     解决: <span class="type">int32_t</span>, <span class="type">uint32_t</span>, <span class="type">int64_t</span>, <span class="type">int8_t</span>, <span class="type">uint8_t</span></span><br><span class="line">            </span><br><span class="line">  <span class="number">4.</span>报式套接字：</span><br><span class="line">            socket（）；</span><br><span class="line">            bind();</span><br><span class="line">sendto();</span><br><span class="line">rcvfrom();</span><br><span class="line">inet_pton();</span><br><span class="line">inet_ntop();</span><br><span class="line"></span><br><span class="line">多点通讯：广播（全网广播， 子网广播），多播/组播 </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">被动端（先运行）</span><br><span class="line"><span class="number">1.</span>取得socker</span><br><span class="line"><span class="number">2.</span>给socket取得地址</span><br><span class="line"><span class="number">3.</span>收/发消息</span><br><span class="line"><span class="number">4.</span>关闭socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主动端</span><br><span class="line"><span class="number">1.</span>取得socket</span><br><span class="line"><span class="number">2.</span>给socket取得地址（可省略）</span><br><span class="line"><span class="number">3.</span>收/发消息</span><br><span class="line"><span class="number">4.</span>关闭socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">netstat -anu   <span class="comment">//命令查看报式套接字</span></span><br><span class="line">netstat -ant  <span class="comment">//命令查看流式套接字</span></span><br></pre></td></tr></table></figure><h3 id="报式套接字"><a href="#报式套接字" class="headerlink" title="报式套接字"></a>报式套接字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//***************************proto.h*******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span>    <span class="comment">// 包含了 uint8_t 和 uint32_t 类型的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCVPORT         <span class="string">&quot;1989&quot;</span>   <span class="comment">// 接收端口号定义为字符串 &quot;1989&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE        11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSTRSIZE       40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">uint32_t</span> math;</span><br><span class="line">    <span class="type">uint32_t</span> chinese;</span><br><span class="line">&#125;__attribute__((packed));<span class="comment">//[1]  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************rcver.c*******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>, <span class="title">raddr</span>;</span>   <span class="comment">//[3] 本地地址和远程地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];             <span class="comment">// 存储 IP 地址的字符串</span></span><br><span class="line"></span><br><span class="line">    sd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">/*IPPROTO_UDP*/</span><span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));<span class="comment">//[4]</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;laddr.sin_addr);<span class="comment">//[5]  // 绑定的 IP 地址，监听所有地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (<span class="type">void</span> *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)<span class="comment">//[6]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*!!!*/</span></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);<span class="comment">//不加这个，第一次数据发送会失败，第二次后通信知道数据的长度后会成功。确保传递给 recvfrom 函数的地址结构体大小是正确的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        recvfrom(sd, &amp;rbuf, <span class="keyword">sizeof</span>(rbuf),<span class="number">0</span>, (<span class="type">void</span> *)&amp;raddr, &amp;raddr_len);<span class="comment">//[8]</span></span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);<span class="comment">//[9]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---MESSAGE FROM %s:%d---\n&quot;</span>, ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NAME = %s\n&quot;</span>, rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MATH = %d\n&quot;</span>, ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CHINESE = %d\n&quot;</span>, ntohl(rbuf.chinese));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************snder.c*******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> sd;                        <span class="comment">// socket 描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span>            <span class="comment">// 发送消息的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span>      <span class="comment">// 接收端地址结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage....\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);   <span class="comment">// 创建 UDP socket</span></span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);         <span class="comment">// 随机生成数学成绩，并转换为网络字节序（大端序）</span></span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;                     <span class="comment">// IPv4 地址族</span></span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT));          <span class="comment">// 目标端口号，从宏 RCVPORT 获取并转换为网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;raddr.sin_addr);   <span class="comment">// 将输入的目标 IP 地址转换为网络地址结构体中的地址</span></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd, &amp;sbuf, <span class="keyword">sizeof</span>(sbuf), <span class="number">0</span>, (<span class="type">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)<span class="comment">//[9]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">__attribute__((packed)) 是GCC和一些兼容的编译器扩展，用于告诉编译器结构体或联合体不需要进行字节对齐，而是按照定义顺序紧凑地排列成员，即按照成员声明的顺序连续地存放在内存中，没有填充字节。</span></span><br><span class="line"><span class="comment">在C语言中，默认情况下，编译器会为了优化访问速度而对结构体或联合体进行字节对齐，即按照某种规则在结构体成员之间插入一些填充字节，使得结构体成员的地址是对齐的。这种对齐可以提高访问结构体成员的效率，但会增加结构体的大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">NAME：</span></span><br><span class="line"><span class="comment">       socket - create an endpoint(端点) for communication</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS：</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;          </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">       int socket(int domain, int type, int protocol);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION：</span></span><br><span class="line"><span class="comment">       socket()  creates  an  endpoint for communication and returns a file descriptor that  refers  to  that  endpoint.</span></span><br><span class="line"><span class="comment">       The file descriptor returned by a successful call will be</span></span><br><span class="line"><span class="comment">       the lowest-numbered（编号最小的） file descriptor  not  currently（当前）  open</span></span><br><span class="line"><span class="comment">       for the process（过程）.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  domain（定义域）  argument  specifies  a communication domain;</span></span><br><span class="line"><span class="comment">       this selects the protocol family（协议族） which will be  used  for</span></span><br><span class="line"><span class="comment">       communication.     These    families   are   defined   in</span></span><br><span class="line"><span class="comment">       &lt;sys/socket.h&gt;.  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE：</span></span><br><span class="line"><span class="comment">       On  success,  a file descriptor for the new socket is re‐</span></span><br><span class="line"><span class="comment">       turned.  On error, -1 is returned, and errno is  set  ap‐</span></span><br><span class="line"><span class="comment">       propriately.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment"> sd = socket(PF_INET, SOCK_DGRAM, 0);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> int domain:  PF_INET 表示使用 IPv4 地址族，即套接字将使用 IPv4 地址。</span></span><br><span class="line"><span class="comment"> int type:   SOCK_DGRAM 表示套接字类型是数据报套接字，这种类型的套接字用于支持 UDP 协议的通信，UDP 是无连接的、不可靠的传输协议。</span></span><br><span class="line"><span class="comment">     int protocol:   第三个参数 0 表示自动选择合适的协议，对于 SOCK_DGRAM 类型的套接字，通常会选择默认的 UDP 协议（在 PF_INET 地址族下）。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">[3][4]</span></span><br><span class="line"><span class="comment">struct sockaddr_in 是一个标准的C语言结构体，它是POSIX和Berkeley套接字API的一部分，用于表示IPv4的套接字地址。在使用套接字编程时，这个结构体已经被操作系统或相关的网络库（如glibc）定义好，你只需要包含相应的头文件就可以直接使用。</span></span><br><span class="line"><span class="comment">通常，在C语言程序中，为了使用struct sockaddr_in，你需要包含 &lt;sys/socket.h&gt; 和 &lt;netinet/in.h&gt; 头文件，这两个头文件中包含了定义该结构体及其相关宏和类型所需的信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">truct sockaddr_in &#123;</span></span><br><span class="line"><span class="comment">               sa_family_t    sin_family; 此字段标识套接字地址的地址族。对于IPv4，这个值应该是AF_INET，这是Internet协议版本4的地址族常量。</span></span><br><span class="line"><span class="comment">               in_port_t      sin_port;   这个字段存储端口号，它是16位无符号整数。端口号用于标识同一台主机上的不同服务或应用程序。在sockaddr_in结构体中，端口号以网络字节序（大端序）存储，这意味着在赋值之前可能需要用诸如htons()（主机到网络短整型）这样的函数转换端口号。</span></span><br><span class="line"><span class="comment">               struct in_addr sin_addr;   这是一个嵌套的结构体，用于存储IPv4的32位地址。</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">           struct in_addr &#123;</span></span><br><span class="line"><span class="comment">               uint32_t       s_addr;    这个结构体专门用于存储IPv4的互联网地址，它只有一个成员：</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">laddr.sin_family = AF_INET;</span></span><br><span class="line"><span class="comment">    laddr.sin_port = htons(atoi(RCVPORT));</span></span><br><span class="line"><span class="comment">    inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;laddr.sin_addr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4][9]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       htonl,  htons, ntohl, ntohs - convert(转换) values between host（主机）</span></span><br><span class="line"><span class="comment">       and network byte order（网络字节序）</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">       uint32_t htonl(uint32_t hostlong);</span></span><br><span class="line"><span class="comment">       uint16_t htons(uint16_t hostshort);</span></span><br><span class="line"><span class="comment">       uint32_t ntohl(uint32_t netlong);</span></span><br><span class="line"><span class="comment">       uint16_t ntohs(uint16_t netshort);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The htonl() function converts the unsigned integer  hostlong（无符号长整型数） from host byte order to network byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  htons() function converts the unsigned short integer hostshort（无符号短整型数） from host byte order to network byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The ntohl() function converts the unsigned  integer  netlong from network byte order to host byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  ntohs() function converts the unsigned short integer netshort from network byte order to host byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       On the i386（x86） the host byte order is Least Significant Byte</span></span><br><span class="line"><span class="comment">       first, whereas the network byte order, as used on the In‐</span></span><br><span class="line"><span class="comment">       ternet, is Most Significant Byte first.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[5]</span></span><br><span class="line"><span class="comment">NAME：</span></span><br><span class="line"><span class="comment">       inet_pton  - convert IPv4 and IPv6 addresses from text（文本表示形式） to</span></span><br><span class="line"><span class="comment">       binary(二进制 网络地址结构) form</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS：</span></span><br><span class="line"><span class="comment">       #include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">       int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       This function converts the character string  src  into  a</span></span><br><span class="line"><span class="comment">       network  address structure in the af address family, then</span></span><br><span class="line"><span class="comment">       copies the network address structure to dst.  The af  argument  must be either AF_INET or AF_INET6.  dst is written in network byte order.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       inet_pton() returns 1 on  success  (network  address  was</span></span><br><span class="line"><span class="comment">       successfully  converted).   0 is returned if src does not</span></span><br><span class="line"><span class="comment">       contain a character string representing a  valid  network</span></span><br><span class="line"><span class="comment">       address  in the specified address family.  If af does not</span></span><br><span class="line"><span class="comment">       contain a valid（有效的） address family, -1 is returned and  errno</span></span><br><span class="line"><span class="comment">       is set to EAFNOSUPPORT.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;laddr.sin_addr);</span></span><br><span class="line"><span class="comment">&quot;0.0.0.0&quot; 是一个特殊的IPv4地址，通常表示本机上的任意IP地址，当一个服务绑定到这个地址时，意味着它将在所有可用的网络接口上监听连接请求。</span></span><br><span class="line"><span class="comment">指向laddr结构体中sin_addr字段的指针，该字段是一个struct in_addr类型，用于存储IPv4地址的32位二进制形式。</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[6]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       bind - bind(捆绑) a name to a socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;         </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">       int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       When  a  socket is created with socket(2), it exists in a</span></span><br><span class="line"><span class="comment">       name space (address family) but has no  address  assigned（分配）</span></span><br><span class="line"><span class="comment">       to  it.   bind() assigns the address specified by addr to</span></span><br><span class="line"><span class="comment">       the socket referred to by  the  file  descriptor  sockfd.</span></span><br><span class="line"><span class="comment">       addrlen  specifies  the  size,  in  bytes, of the address</span></span><br><span class="line"><span class="comment">       structure pointed to by addr.  Traditionally, this operation is called “assigning a name to a socket”.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       It  is normally necessary to assign a local address using</span></span><br><span class="line"><span class="comment">       bind() before a SOCK_STREAM socket  may  receive  connec‐</span></span><br><span class="line"><span class="comment">       tions (see accept(2)).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">RETURN VALUE:</span></span><br><span class="line"><span class="comment">       On  success, zero is returned.  On error, -1 is returned,</span></span><br><span class="line"><span class="comment">       and errno is set appropriately.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">bind(sd, (void *)&amp;laddr, sizeof(laddr)</span></span><br><span class="line"><span class="comment">在套接字编程中将一个套接字（由文件描述符sd表示）绑定到一个特定的IP地址和端口上。</span></span><br><span class="line"><span class="comment">(void *)&amp;laddr：这里，laddr应该是一个之前定义并初始化过的struct sockaddr_in结构体变量，包含了要绑定的IP地址和端口号信息。通过(void *)&amp;laddr，我们将这个结构体的地址强制转换为(void *)指针类型，因为bind()函数的第二个参数需要一个指向套接字地址结构的指针。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[8]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       recv, recvfrom, recvmsg - receive a message from a socket</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span></span><br><span class="line"><span class="comment">                        struct sockaddr *src_addr, socklen_t *addrlen);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">recvfrom()</span></span><br><span class="line"><span class="comment">       recvfrom() places the received message  into  the  buffer</span></span><br><span class="line"><span class="comment">       buf.   The  caller must specify the size of the buffer in</span></span><br><span class="line"><span class="comment">       len.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If src_addr is not NULL, and the underlying protocol pro‐</span></span><br><span class="line"><span class="comment">       vides  the source address of the message, that source ad‐</span></span><br><span class="line"><span class="comment">       dress is placed in the buffer pointed to by src_addr.  In</span></span><br><span class="line"><span class="comment">       this  case,  addrlen  is a value-result argument.  Before</span></span><br><span class="line"><span class="comment">       the call, it should be initialized to  the  size  of  the</span></span><br><span class="line"><span class="comment">       buffer associated with src_addr.  Upon return, addrlen is</span></span><br><span class="line"><span class="comment">       updated to contain the actual size of the source address.</span></span><br><span class="line"><span class="comment">       The  returned address is truncated if the buffer provided</span></span><br><span class="line"><span class="comment">       is too small; in this case, addrlen will return  a  value</span></span><br><span class="line"><span class="comment">       greater than was supplied to the call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  the  caller  is not interested in the source address,</span></span><br><span class="line"><span class="comment">       src_addr and addrlen should be specified as NULL.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">demo:</span></span><br><span class="line"><span class="comment">recvfrom(sd, &amp;rbuf, sizeof(rbuf),0, (void *)&amp;raddr, &amp;raddr_len);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="流式套接字"><a href="#流式套接字" class="headerlink" title="流式套接字"></a>流式套接字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*********************proto.h************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     SERVERPORT      <span class="string">&quot;1989&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     FMT_STAMP       <span class="string">&quot;%lld\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     IPSTRSIZE       40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     BUFSIZE         1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************server.c*********************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> sd)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP, (<span class="type">long</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(send(sd, buf, len, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> sd, newsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>, <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="type">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span><span class="comment">/*IPPROTO_TCP, IPPROTO_SCTP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) <span class="comment">//[1]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (<span class="type">void</span> *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sd, <span class="number">200</span>) &lt; <span class="number">0</span>)  <span class="comment">//[2]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newsd = accept(sd, (<span class="type">void</span> *)&amp;raddr, &amp;raddr_len); <span class="comment">//[3]</span></span><br><span class="line">        <span class="keyword">if</span>(newsd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client:%s:%d\n&quot;</span> ,ipstr, ntohs(raddr.sin_port));</span><br><span class="line"></span><br><span class="line">        server_job(newsd);</span><br><span class="line">        close(newsd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************client.c*****************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stamp;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;user...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sd, (<span class="type">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>) <span class="comment">//[4]</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fdopen(sd, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fdopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fscanf</span>(fp, FMT_STAMP, &amp;stamp) &lt; <span class="number">1</span>)  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;bad format\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;stamp = %lld\n&quot;</span>, stamp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       getsockopt, setsockopt - get and set options on sockets</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;          </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int getsockopt(int sockfd, int level, int optname,</span></span><br><span class="line"><span class="comment">                      void *optval, socklen_t *optlen);</span></span><br><span class="line"><span class="comment">       int setsockopt(int sockfd, int level, int optname,</span></span><br><span class="line"><span class="comment">                      const void *optval, socklen_t optlen);</span></span><br><span class="line"><span class="comment">                   </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       getsockopt()  and  setsockopt() manipulate(操作) options for the</span></span><br><span class="line"><span class="comment">       socket referred to by the file descriptor sockfd.  Options</span></span><br><span class="line"><span class="comment">       may  exist  at  multiple（多个）  protocol（协议） levels; they are always</span></span><br><span class="line"><span class="comment">       present（出现） at the uppermost（最上层） socket level.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       When manipulating socket options, the level at  which  the</span></span><br><span class="line"><span class="comment">       option  resides（存在）  and the name of the option must be specified.  To manipulate options at  the  sockets  API  level,level  is  specified as SOL_SOCKET.  To manipulate options at any other level the protocol number of the  appropriate（适当的）protocol controlling（管理） the option is supplied（被提供）.  For example, to indicate（表明） that an option is to be interpreted by the TCP</span></span><br><span class="line"><span class="comment">       protocol,  level  should  be set to the protocol number of</span></span><br><span class="line"><span class="comment">       TCP; see getprotoent(3).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The arguments optval and optlen are used to access  option</span></span><br><span class="line"><span class="comment">       values for setsockopt().  For getsockopt() they identify（确认） a</span></span><br><span class="line"><span class="comment">       buffer in which the value for the requested option(s)  are</span></span><br><span class="line"><span class="comment">       to  be  returned.  For getsockopt(), optlen is a value-result argument, initially containing the size of the buffer</span></span><br><span class="line"><span class="comment">       pointed  to  by optval, and modified（修改） on return to indicate（表明）</span></span><br><span class="line"><span class="comment">       the actual（真实的） size of the value returned.  If no option value</span></span><br><span class="line"><span class="comment">       is to be supplied（提供） or returned, optval may be NULL.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       Optname and any specified options are passed uninterpreted（未被解释）</span></span><br><span class="line"><span class="comment">       to the appropriate  protocol  module  for  interpretation.</span></span><br><span class="line"><span class="comment">       The  include  file &lt;sys/socket.h&gt; contains definitions for</span></span><br><span class="line"><span class="comment">       socket level options, described below.  Options  at  other</span></span><br><span class="line"><span class="comment">       protocol  levels  vary in format and name; consult the ap‐</span></span><br><span class="line"><span class="comment">       propriate entries in section 4 of the manual.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Most socket-level options utilize an int argument for opt‐</span></span><br><span class="line"><span class="comment">       val.   For setsockopt(), the argument should be nonzero to</span></span><br><span class="line"><span class="comment">       enable a boolean option, or zero if the option  is  to  be</span></span><br><span class="line"><span class="comment">       disabled.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       For  a  description  of  the  available socket options see</span></span><br><span class="line"><span class="comment">       socket(7) and the appropriate protocol man pages.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, zero is returned for the standard options.  On</span></span><br><span class="line"><span class="comment">       error, -1 is returned, and errno is set appropriately.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Netfilter  allows  the  programmer to define custom socket</span></span><br><span class="line"><span class="comment">       options with associated handlers; for  such  options,  the</span></span><br><span class="line"><span class="comment">       return  value on success is the value returned by the han‐</span></span><br><span class="line"><span class="comment">       dler.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       listen - listen for connections on a socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;         </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int listen(int sockfd, int backlog);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       listen()  marks（标记） the socket referred to by sockfd as a passive（被动的） socket, that is, as a socket that will be used to accept incoming connection requests using accept(2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  sockfd argument is a file descriptor that refers to a</span></span><br><span class="line"><span class="comment">       socket of type SOCK_STREAM or SOCK_SEQPACKET.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The backlog argument defines the maximum length  to  which</span></span><br><span class="line"><span class="comment">       the  queue of pending connections for sockfd may grow.  If</span></span><br><span class="line"><span class="comment">       a connection request arrives when the queue is  full,  the</span></span><br><span class="line"><span class="comment">       client may receive an error with an indication of ECONNRE‐</span></span><br><span class="line"><span class="comment">       FUSED or, if the underlying protocol supports  retransmis‐</span></span><br><span class="line"><span class="comment">       sion, the request may be ignored so that a later reattempt（重新尝试）</span></span><br><span class="line"><span class="comment">       at connection succeeds.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, zero is returned.  On error, -1  is  returned,</span></span><br><span class="line"><span class="comment">       and errno is set appropriately.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">[3]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       accept, accept4 - accept a connection on a socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;         </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  accept()  system  call  is used with connection-based</span></span><br><span class="line"><span class="comment">       socket types (SOCK_STREAM, SOCK_SEQPACKET).   It  extracts（提取）</span></span><br><span class="line"><span class="comment">       the  first connection request on the queue of pending con‐</span></span><br><span class="line"><span class="comment">       nections for the listening socket, sockfd, creates  a  new</span></span><br><span class="line"><span class="comment">       connected socket, and returns a new file descriptor refer‐</span></span><br><span class="line"><span class="comment">       ring to that socket.  The newly created socket is  not  in</span></span><br><span class="line"><span class="comment">       the  listening state.  The original socket sockfd is unaffected（不受影响的） by this call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The argument sockfd is a socket that has been created with</span></span><br><span class="line"><span class="comment">       socket(2),  bound  to a local address with bind(2), and is</span></span><br><span class="line"><span class="comment">       listening for connections after a listen(2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The argument addr is a pointer to  a  sockaddr  structure.</span></span><br><span class="line"><span class="comment">       This  structure  is filled in with the address of the peer</span></span><br><span class="line"><span class="comment">       socket, as known to the communications layer.   The  exact</span></span><br><span class="line"><span class="comment">       format  of  the address returned addr is determined by the</span></span><br><span class="line"><span class="comment">       socket&#x27;s address family (see socket(2) and the  respective</span></span><br><span class="line"><span class="comment">       protocol man pages).  When addr is NULL, nothing is filled</span></span><br><span class="line"><span class="comment">       in; in this case, addrlen is not used, and should also  be</span></span><br><span class="line"><span class="comment">       NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The  addrlen  argument  is  a  value-result  argument: the</span></span><br><span class="line"><span class="comment">       caller must initialize it to contain the size  (in  bytes)</span></span><br><span class="line"><span class="comment">       of  the  structure  pointed  to by addr; on return it will</span></span><br><span class="line"><span class="comment">       contain the actual size of the peer address.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The returned address is truncated if the  buffer  provided</span></span><br><span class="line"><span class="comment">       is  too  small;  in this case, addrlen will return a value</span></span><br><span class="line"><span class="comment">       greater than was supplied to the call.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">   If no pending connections are present on  the  queue,  and</span></span><br><span class="line"><span class="comment">       the  socket  is not marked as nonblocking, accept() blocks</span></span><br><span class="line"><span class="comment">       the caller until a connection is present.  If  the  socket</span></span><br><span class="line"><span class="comment">       is  marked  nonblocking  and  no  pending  connections are</span></span><br><span class="line"><span class="comment">       present on the queue, accept() fails with the error EAGAIN</span></span><br><span class="line"><span class="comment">       or EWOULDBLOCK.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In  order  to  be  notified  of  incoming connections on a</span></span><br><span class="line"><span class="comment">       socket, you can use select(2), poll(2),  or  epoll(7).   A</span></span><br><span class="line"><span class="comment">       readable  event will be delivered when a new connection is</span></span><br><span class="line"><span class="comment">       attempted and you may then call accept() to get  a  socket</span></span><br><span class="line"><span class="comment">       for  that  connection.   Alternatively,  you  can  set the</span></span><br><span class="line"><span class="comment">       socket to deliver SIGIO when activity occurs on a  socket;</span></span><br><span class="line"><span class="comment">       see socket(7) for details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  flags  is  0,  then accept4() is the same as accept().</span></span><br><span class="line"><span class="comment">       The following values can be bitwise ORed in flags  to  ob‐</span></span><br><span class="line"><span class="comment">       tain different behavior:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       SOCK_NONBLOCK   Set the O_NONBLOCK file status flag on the</span></span><br><span class="line"><span class="comment">                       open file description  (see  open(2))  re‐</span></span><br><span class="line"><span class="comment">                       ferred to by the new file descriptor.  Us‐</span></span><br><span class="line"><span class="comment">                       ing this flag saves  extra  calls  to  fc‐</span></span><br><span class="line"><span class="comment">                       ntl(2) to achieve the same result.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on</span></span><br><span class="line"><span class="comment">                       the new file descriptor.  See the descrip‐</span></span><br><span class="line"><span class="comment">                       tion  of the O_CLOEXEC flag in open(2) for</span></span><br><span class="line"><span class="comment">                       reasons why this may be useful.</span></span><br><span class="line"><span class="comment">                      </span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       On success, these system calls return a nonnegative  inte‐</span></span><br><span class="line"><span class="comment">       ger that is a file descriptor for the accepted socket.  On</span></span><br><span class="line"><span class="comment">       error, -1 is returned, errno is set appropriately, and ad‐</span></span><br><span class="line"><span class="comment">       drlen is left unchanged.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[4]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       connect - initiate a connection on a socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/types.h&gt;         </span></span><br><span class="line"><span class="comment">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       int connect(int sockfd, const struct sockaddr *addr,</span></span><br><span class="line"><span class="comment">                   socklen_t addrlen);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       The  connect() system call connects the socket referred to</span></span><br><span class="line"><span class="comment">       by the file descriptor sockfd to the address specified  by</span></span><br><span class="line"><span class="comment">       addr.   The  addrlen  argument specifies the size of addr.</span></span><br><span class="line"><span class="comment">       The format of the address in addr is determined by the ad‐</span></span><br><span class="line"><span class="comment">       dress  space  of the socket sockfd; see socket(2) for fur‐</span></span><br><span class="line"><span class="comment">       ther details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If the socket sockfd is of type SOCK_DGRAM, then  addr  is</span></span><br><span class="line"><span class="comment">       the  address  to  which datagrams are sent by default, and</span></span><br><span class="line"><span class="comment">       the only address from which datagrams  are  received.   If</span></span><br><span class="line"><span class="comment">       the  socket is of type SOCK_STREAM or SOCK_SEQPACKET, this</span></span><br><span class="line"><span class="comment">       call attempts to make a connection to the socket  that  is</span></span><br><span class="line"><span class="comment">       bound to the address specified by addr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Generally,  connection-based protocol sockets may success‐</span></span><br><span class="line"><span class="comment">       fully connect() only once; connectionless protocol sockets</span></span><br><span class="line"><span class="comment">       may  use connect() multiple times to change their associa‐</span></span><br><span class="line"><span class="comment">       tion.  Connectionless sockets may dissolve the association</span></span><br><span class="line"><span class="comment">       by  connecting  to an address with the sa_family member of</span></span><br><span class="line"><span class="comment">       sockaddr set to AF_UNSPEC (supported on Linux since kernel</span></span><br><span class="line"><span class="comment">       2.2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RETURN VALUE</span></span><br><span class="line"><span class="comment">       If  the  connection or binding succeeds, zero is returned.</span></span><br><span class="line"><span class="comment">       On error, -1 is returned, and errno is set appropriately.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="动态进程池"><a href="#动态进程池" class="headerlink" title="动态进程池"></a>动态进程池</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*********************************proto.h***********************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMEMAX 512-8-8<span class="comment">//(UDP推荐长度-UDP报头长度-结构体的长度)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMT_STAMP <span class="string">&quot;%lld\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVERPORT <span class="string">&quot;2333&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************************client.c******************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span><span class="comment">//remote addr</span></span><br><span class="line"></span><br><span class="line">    sfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP*/</span>);</span><br><span class="line"></span><br><span class="line">    raddr.sin_family = AF_INET;</span><br><span class="line">    raddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;raddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sfd,(<span class="type">void</span> *)&amp;raddr,<span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fdopen(sfd,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stamp;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp,FMT_STAMP,&amp;stamp) &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Bad format\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,FMT_STAMP,stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************************server.c**************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_NOTIFY SIGUSR2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSPACESERVER 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSPACESERVER 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCLINETS     20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    STATE_IDLE=<span class="number">0</span>,  <span class="comment">// idle 空闲的</span></span><br><span class="line">    STATE_BUSY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">server_st</span>&#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">server_st</span> *<span class="title">serverpool</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> idle_count = <span class="number">0</span>,busy_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket相关全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sfd;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">server_job</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="type">int</span> newsd;</span><br><span class="line">    <span class="type">int</span> ppid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span><span class="comment">//remote addr</span></span><br><span class="line">    <span class="type">char</span> ip[IPSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line"></span><br><span class="line">    ppid = getppid();<span class="comment">//父进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        serverpool[pos].state = STATE_IDLE;</span><br><span class="line">        kill(ppid, SIG_NOTIFY);  <span class="comment">//[1]</span></span><br><span class="line"></span><br><span class="line">        newsd = accept(sfd, (<span class="type">void</span> *)&amp;raddr,&amp;raddr_len);<span class="comment">//接收客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (newsd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR || errno == EAGAIN)</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverpool[pos].state = STATE_BUSY;</span><br><span class="line">        kill(ppid,SIG_NOTIFY);</span><br><span class="line">        inet_ntop(AF_INET,&amp;raddr.sin_addr,ip,IPSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">        <span class="type">int</span> pkglen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pkglen = <span class="built_in">sprintf</span>(buf,FMT_STAMP,(<span class="type">long</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (send(newsd,buf,pkglen,<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;send()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(newsd);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_one_server</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> slot;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idle_count + busy_count &gt;= MAXCLINETS)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(slot = <span class="number">0</span>;slot &lt; MAXCLINETS;slot++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (serverpool[slot].pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverpool[slot].state = STATE_IDLE;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        server_job(slot);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        serverpool[slot].pid = pid;</span><br><span class="line">        idle_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">del_one_server</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> slot;</span><br><span class="line">    <span class="keyword">if</span> (idle_count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(slot = <span class="number">0</span>;slot &lt; MAXCLINETS;slot++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (serverpool[slot].pid != <span class="number">-1</span> &amp;&amp; serverpool[slot].state == STATE_IDLE)&#123;</span><br><span class="line">            kill(serverpool[slot].pid,SIGTERM);</span><br><span class="line">            serverpool[slot].pid = <span class="number">-1</span>;</span><br><span class="line">            idle_count--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scan_pool</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> idle = <span class="number">0</span>,busy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAXCLINETS;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (serverpool[i].pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kill(serverpool[i].pid,<span class="number">0</span>))&#123;<span class="comment">//kill pid 0检测一个进程是否存在 如果进程不存在（返回非零），将 pid 置为 -1，表示该位置空闲</span></span><br><span class="line">            serverpool[i].pid =<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计进程池的状态</span></span><br><span class="line">        <span class="keyword">if</span>(serverpool[i].state == STATE_IDLE)</span><br><span class="line">          idle++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(serverpool[i].state == STATE_BUSY)</span><br><span class="line">          busy++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;未知状态!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    idle_count = idle;</span><br><span class="line">    busy_count = busy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>,<span class="title">osa</span>;</span></span><br><span class="line"></span><br><span class="line">    sa.sa_handler = SIG_IGN;<span class="comment">//忽略父进程的资源回收信号</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_NOCLDWAIT;<span class="comment">//让子进程结束后自行消亡,不会变成僵尸状态</span></span><br><span class="line">    sigaction(SIGCLD,&amp;sa,&amp;osa);</span><br><span class="line"></span><br><span class="line">    sa.sa_handler = handle;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIG_NOTIFY,&amp;sa,&amp;osa);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏蔽信号</span></span><br><span class="line">    <span class="type">sigset_t</span> sigset,oldsigset;</span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset,SIG_NOTIFY);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;sigset,&amp;oldsigset);</span><br><span class="line"></span><br><span class="line">    serverpool = mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> server_st)*MAXCLINETS,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>); <span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span> (serverpool == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化进程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAXCLINETS;i++)&#123;</span><br><span class="line">        serverpool[i].pid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span><span class="comment">/*IPPROTO_TCP*/</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sfd,SOL_SOCKET,SO_REUSEADDR,&amp;val,<span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span><span class="comment">//local addr</span></span><br><span class="line">    laddr.sin_family = AF_INET;<span class="comment">//指定协议</span></span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));<span class="comment">//指定网络通信端口</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;0.0.0.0&quot;</span>,&amp;laddr.sin_addr);<span class="comment">//IPv4点分式转二进制数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sfd,(<span class="type">void</span> *)&amp;laddr,<span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sfd,<span class="number">1024</span>) &lt; <span class="number">0</span>)&#123;<span class="comment">//全连接数量，listen 是服务器端 TCP 套接字编程中的关键步骤之一。它允许服务器准备好接受连接请求并处理客户端请求。如果没有调用 listen，服务器将无法接收客户端的连接请求。</span></span><br><span class="line">        perror(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MINSPACESERVER;i++)&#123;</span><br><span class="line">        add_one_server();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sigsuspend(&amp;oldsigset);</span><br><span class="line"></span><br><span class="line">        scan_pool();<span class="comment">//扫描进程池</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//管理进程池</span></span><br><span class="line">        <span class="keyword">if</span> (idle_count &gt; MAXSPACESERVER)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (idle_count-MAXSPACESERVER);i++)&#123;</span><br><span class="line">                del_one_server();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (idle_count &lt; MINSPACESERVER)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;削减server\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (MINSPACESERVER-idle_count);i++)&#123;</span><br><span class="line">                add_one_server();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print the pool</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAXCLINETS;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (serverpool[i].pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (serverpool[i].state == STATE_IDLE)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(serverpool[i].state == STATE_BUSY)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fflush(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sfd);</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oldsigset,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1]</span></span><br><span class="line"><span class="comment">kill(ppid, SIG_NOTIFY);</span></span><br><span class="line"><span class="comment">    kill 函数用于向指定进程发送信号。它的第一个参数是进程ID，第二个参数是要发送的信号.</span></span><br><span class="line"><span class="comment">    ppid 是父进程的进程ID。</span></span><br><span class="line"><span class="comment">    SIG_NOTIFY 是一个用户自定义信号，用于通知父进程某个事件已经发生。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    在父进程中，有一个信号处理函数 handle，它会在接收到 SIG_NOTIFY 信号时被调用：</span></span><br><span class="line"><span class="comment">    static void handle(int sig) &#123;</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">该信号处理函数目前只是一个空函数，即在接收到 SIG_NOTIFY 信号时不会进行任何操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2]</span></span><br><span class="line"><span class="comment">NAME</span></span><br><span class="line"><span class="comment">       mmap, munmap - map（映射） or unmap files or devices(设备) into memory</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">       #include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line"><span class="comment">                  int fd, off_t offset);</span></span><br><span class="line"><span class="comment">                  </span></span><br><span class="line"><span class="comment">DESCRIPTION</span></span><br><span class="line"><span class="comment">       mmap()  creates  a new mapping in the virtual（虚拟的） address space of the calling process（调用进程）.  The starting address for the new mapping is specified in addr.The length argument specifies the length  of  the mapping (which must be greater than 0).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If  addr  is  NULL,  then  the kernel chooses the</span></span><br><span class="line"><span class="comment">       (page-aligned) address at  which  to  create  the</span></span><br><span class="line"><span class="comment">       mapping; this is the most portable（便携的） method of creating a new mapping.  If addr is not  NULL,  then the  kernel  takes  it  as  a hint（暗示） about where to place the mapping; on Linux, the kernel will pick a nearby page boundary (but always above or equal to the value specified by</span></span><br><span class="line"><span class="comment">       /proc/sys/vm/mmap_min_addr) and attempt to create</span></span><br><span class="line"><span class="comment">       the mapping there.  If  another  mapping  already</span></span><br><span class="line"><span class="comment">       exists there, the kernel picks a new address that</span></span><br><span class="line"><span class="comment">       may or may not depend on the hint.   The  address</span></span><br><span class="line"><span class="comment">       of  the  new mapping is returned as the result of</span></span><br><span class="line"><span class="comment">       the call.</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       The contents of a file mapping (as opposed（相反的） to  an</span></span><br><span class="line"><span class="comment">       anonymous（匿名的）  mapping; see MAP_ANONYMOUS below), are</span></span><br><span class="line"><span class="comment">       initialized（初始化） using length bytes starting at offset（偏移量）</span></span><br><span class="line"><span class="comment">       offset  in the file (or other object) referred to</span></span><br><span class="line"><span class="comment">       by the file descriptor fd.  offset must be a multiple   of   the   page   size   as  returned  by sysconf(_SC_PAGE_SIZE).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the mmap() call has returned, the file  descriptor,  fd,  can be closed immediately without invalidating the mapping.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The prot argument describes  the  desired  memory</span></span><br><span class="line"><span class="comment">       protection  of the mapping (and must not conflict</span></span><br><span class="line"><span class="comment">       with the open mode of the file).   It  is  either</span></span><br><span class="line"><span class="comment">       PROT_NONE or the bitwise OR of one or more of the</span></span><br><span class="line"><span class="comment">       following flags:</span></span><br><span class="line"><span class="comment">           PROT_EXEC  Pages may be executed.</span></span><br><span class="line"><span class="comment">           PROT_READ  Pages may be read.</span></span><br><span class="line"><span class="comment">           PROT_WRITE Pages may be written.</span></span><br><span class="line"><span class="comment">           PROT_NONE  Pages may not be accessed.</span></span><br><span class="line"><span class="comment">           </span></span><br><span class="line"><span class="comment">           MAP_ANONYMOUS</span></span><br><span class="line"><span class="comment">              The mapping is not backed（支持） by any file; its contents are initialized to zero.  The  fd argument  is ignored; however, some implementations（实现）  require  fd  to   be   -1   if MAP_ANONYMOUS  (or MAP_ANON) is specified, and portable  applications  should  ensure this.  The offset argument should be zero. The use of  MAP_ANONYMOUS  in  conjunction（同时出现） with MAP_SHARED is supported on Linux only since kernel 2.4.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL基础知识</title>
      <link href="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="LVGL"><a href="#LVGL" class="headerlink" title="LVGL"></a>LVGL</h1><h1 id="English："><a href="#English：" class="headerlink" title="English："></a>English：</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pivot <span class="comment">//旋转</span></span><br><span class="line">rotation <span class="comment">//转动</span></span><br><span class="line">scale <span class="comment">//比例</span></span><br></pre></td></tr></table></figure><h4 id="创建对象框"><a href="#创建对象框" class="headerlink" title="创建对象框"></a>创建对象框</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">demo_obj</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//得到当前活跃屏幕</span></span><br><span class="line">  <span class="type">lv_obj_t</span>* screen = lv_scr_act();</span><br><span class="line">  <span class="comment">//在当前屏幕显示一个对象</span></span><br><span class="line">  <span class="type">lv_obj_t</span>* obj = lv_obj_create(screen);</span><br><span class="line"></span><br><span class="line">  lv_obj_set_size(obj, <span class="number">100</span>, <span class="number">50</span>); <span class="comment">// 设置对象的大小为 100x50 像素</span></span><br><span class="line">  lv_obj_set_pos(obj, <span class="number">100</span>, <span class="number">0</span>); <span class="comment">// 默认左上角为原点, 设置对象位置</span></span><br><span class="line">  </span><br><span class="line">  lv_obj_set_style_bg_color(obj, lv_palette_main(LV_PALETTE_LIGHT_BLUE), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">demo_style</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//得到当前活跃屏幕</span></span><br><span class="line">  <span class="type">lv_obj_t</span>* screen = lv_scr_act();</span><br><span class="line">  <span class="comment">//在当前屏幕显示一个对象</span></span><br><span class="line">  <span class="type">lv_obj_t</span>* obj = lv_obj_create(screen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过样式修改对象</span></span><br><span class="line">  <span class="type">static</span> <span class="type">lv_style_t</span> style;</span><br><span class="line">  lv_style_init(&amp;style);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//lv_style_set_width(&amp;style, 100);</span></span><br><span class="line">  <span class="comment">//lv_style_set_height(&amp;style, 100);</span></span><br><span class="line">  lv_style_set_size(&amp;style,<span class="number">100</span>); <span class="comment">//样式是个正方形</span></span><br><span class="line">  lv_style_set_radius(&amp;style, <span class="number">40</span>); <span class="comment">//样式的圆角</span></span><br><span class="line">  lv_style_set_x(&amp;style, <span class="number">50</span>);</span><br><span class="line">  lv_style_set_y(&amp;style, <span class="number">100</span>);</span><br><span class="line">  lv_style_set_pad_bottom(&amp;style, <span class="number">100</span>); <span class="comment">//使按钮文本与按钮边界之间有一个固定的空白区域</span></span><br><span class="line">  lv_style_set_bg_color(&amp;style, lv_palette_main(LV_PALETTE_LIGHT_BLUE));<span class="comment">//样式的颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将样式与对象联系起来</span></span><br><span class="line">  lv_obj_add_style(obj, &amp;style, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">demo_label</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">lv_obj_t</span>* screen = lv_scr_act();<span class="comment">//获取当前活跃屏幕</span></span><br><span class="line">  <span class="type">lv_obj_t</span>* label = lv_label_create(screen);<span class="comment">//创建文本对象</span></span><br><span class="line"></span><br><span class="line">  lv_label_set_text(label, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  lv_obj_align(label,LV_ALIGN_BOTTOM_MID,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  lv_obj_set_style_text_color(label,lv_palette_main(LV_PALETTE_LIGHT_BLUE),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SquareLine-Studio"><a href="#SquareLine-Studio" class="headerlink" title="SquareLine Studio"></a>SquareLine Studio</h1><h2 id="screen"><a href="#screen" class="headerlink" title="screen:"></a>screen:</h2><p><img src="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" alt="image-20240422165046286"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Flags:</span><br><span class="line">Clickable <span class="comment">//可以被触摸</span></span><br><span class="line">    Checkable <span class="comment">//可以被切换</span></span><br></pre></td></tr></table></figure><h2 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE:"></a>LABLE:</h2><p><img src="/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" alt="image-20240422170853213"></p>]]></content>
      
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言基础知识</title>
      <link href="/2024/04/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/04/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言基础知识"><a href="#C语言基础知识" class="headerlink" title="C语言基础知识"></a>C语言基础知识</h1><h2 id="volatile："><a href="#volatile：" class="headerlink" title="volatile："></a>volatile：</h2><p>​在当前线程内，当读取一个变量时，为了提高读取速度编译器会先把变量读取到一个寄存器中，再读取变量时就会直接从寄存器读取，当变量在本次线程改变时，会把改变后的变量值copy到该寄存器中，保持一致，当变量因为别的线程值发生改变，寄存器的值不会相应的改变，从而照成程序读取的值和实际变量值不一样，<br>volatile的作用就是不将变量读取到寄存器中，或者说每一次读取都是从内存中读取变量值，牺牲了一定的效率，但提升了正确率。</p><h2 id="子函数变量地址："><a href="#子函数变量地址：" class="headerlink" title="子函数变量地址："></a>子函数变量地址：</h2><h3 id="个人发现："><a href="#个人发现：" class="headerlink" title="个人发现："></a>个人发现：</h3><p>有趣的发现：我在int Max_Arr(int arr[][4]); int Min_Arr(int arr[][4]);都定义了临时变量int line, row；由于数组特殊导致求最小值的时候if(min&gt;arr[i][j])逻辑表达式一直为false，if的语句块从未执行。变量line, row未被赋值。但实际输出居然和最大值的line， row值相同。</p><p>经过我的测试由于int Max_Arr(int arr[][4]);int Max_Arr(int arr[][4]);的临时变量数量相同，在Max_Arr()创建释放的line,row变量，在Min_Arr()创建变量时地址和Max_Arr()里的line, row地址一样。然而在int Min_Arr(int arr[][4])加入int a, b, c, d&#x3D;0;等无关变量后 line row地址改变。</p><h3 id="ChatGPT解释"><a href="#ChatGPT解释" class="headerlink" title="ChatGPT解释:"></a>ChatGPT解释:</h3><p>​在C语言中，函数内的变量通常存储在栈上。栈是一种后进先出（LIFO）的数据结构，用于存储函数调用时的局部变量、函数参数和返回地址等信息。当函数被调用时，系统会为该函数的局部变量在栈上分配内存空间。当函数返回时，这些局部变量所占用的栈空间会被释放，以便给后续的函数调用使用。因此，函数内的变量地址通常是相对于栈顶的偏移量。需要注意的是，栈是一种自动管理的内存区域，其生命周期与函数调用的生命周期相关联。因此，函数内的变量在函数返回后就不再有效，对它们的地址进行访问可能会导致未定义的行为。另外，有些编译器可能会对程序进行优化，可能会将某些局部变量存储在寄存器中，而不是栈上。这取决于编译器的实现和编译器优化选项。</p><p>​在典型的栈数据结构中，栈底通常具有较低的内存地址，而栈顶具有较高的内存地址。因此，栈底的变量地址通常比栈顶的变量地址要小。如果要打印栈底和栈顶的变量地址，通常情况下，栈底的变量地址会较小，而栈顶的变量地址会较大。这是因为栈的存储方式是后进先出（LIFO），新的变量被推入栈顶，而栈顶的变量地址是最大的。反之，栈底的变量地址则是最小的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Printf_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Max_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Max_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Double_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> arr[][<span class="number">4</span>] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">Printf_Arr(arr);</span><br><span class="line">Sum_Arr(arr);</span><br><span class="line">Max_Arr(arr);</span><br><span class="line">Min_Arr(arr);</span><br><span class="line">Double_Arr(arr);</span><br><span class="line">Printf_Arr(arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Printf_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">sum += arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Max_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line"><span class="type">int</span> max = arr[<span class="number">0</span>][<span class="number">0</span>], line, row;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(max&lt;arr[i][j])&#123;</span><br><span class="line">line = i+<span class="number">1</span>;</span><br><span class="line">row = j+<span class="number">1</span>;</span><br><span class="line">max = arr[i][j];&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d line:%d, adress:%d, row:%d, adress:%d\n&quot;</span>,max, line,&amp;line, row,&amp;row);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Min_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> min = arr[<span class="number">0</span>][<span class="number">0</span>], line, row;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(min&gt;arr[i][j])&#123;</span><br><span class="line">line = i+<span class="number">1</span>;</span><br><span class="line">row = j+<span class="number">1</span>;</span><br><span class="line">min = arr[i][j];&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d line:%d, adress:%d, row:%d, adress:%d\n&quot;</span>,min, line,&amp;line, row,&amp;row);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Double_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">arr[i][j] *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符数组："><a href="#字符数组：" class="headerlink" title="字符数组："></a>字符数组：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">//字面量写法 相当于 char arr[6] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27;&#125;;‘\0’也要占一个char的字节</span></span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">char</span>); <span class="comment">//length=6 说明字面量书写字符数组默认占一个&#x27;\0&#x27;字节（终止符）</span></span><br></pre></td></tr></table></figure><p>当我试图以此法用指针更改字符串，却收到了报错：”world”的类型是 const char *,说明它是只读的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="type">char</span> *ptr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">*ptr = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*ptr);</span><br><span class="line"><span class="comment">//在C语言中，字符串字面值（例如：&quot;world&quot;）在定义时会被编译器存储在常量区，这意味着它们是不可修改的字符常量。当你使用一个指针指向字符串字面值时，你实际上是让指针指向常量区中的字符串常量，因此试图修改这些字符串是非法的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line"><span class="comment">//这个数组会在栈上或堆上分配空间，并且将字符串内容复制到这个数组中。因此，现在你有一个可修改的字符数组，而不是指向字符串常量的指针。在这种情况下，你可以安全地修改数组中的字符，因为它们是可修改的。</span></span><br></pre></td></tr></table></figure><p>如果用字符数组存储中文，因为中文占两个字节，需要连续输出两个字节才能显示一个中文。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">10</span>] = <span class="string">&quot;张永乐&quot;</span>;</span><br><span class="line"><span class="type">char</span> name1[<span class="number">10</span>] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>, name[<span class="number">2</span>], name[<span class="number">3</span>]);<span class="comment">//永</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>, name1[<span class="number">2</span>], name1[<span class="number">3</span>]);<span class="comment">//cd</span></span><br></pre></td></tr></table></figure><h2 id="二维数组："><a href="#二维数组：" class="headerlink" title="二维数组："></a>二维数组：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> arr[<span class="number">3</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,arr[i]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rows = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//直指本质：二维数组就是多个一维数组，arr表示二维数组，arr[i]表示一维数组</span></span><br><span class="line"><span class="type">int</span> cols = <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//arr[i][j]表示一个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;rows:%d\ncols:%d\n&quot;</span>,rows,cols);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="情况1（输入字符串均小于字符数组长度）"><a href="#情况1（输入字符串均小于字符数组长度）" class="headerlink" title="情况1（输入字符串均小于字符数组长度）"></a>情况1（输入字符串均小于字符数组长度）</h4><p>输入:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esp</span><br><span class="line">rtc</span><br><span class="line">rtos</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">row:<span class="number">3</span>  <span class="comment">//定义二维数组就初始好的，不会改变</span></span><br><span class="line">cols:<span class="number">6</span> <span class="comment">//定义二维数组就初始好的，不会改变</span></span><br><span class="line">esp  </span><br><span class="line">rtc</span><br><span class="line">rtos  <span class="comment">//输出符合预期</span></span><br></pre></td></tr></table></figure><h4 id="情况2（输入字符串有个别一维数组超出长度）"><a href="#情况2（输入字符串有个别一维数组超出长度）" class="headerlink" title="情况2（输入字符串有个别一维数组超出长度）"></a>情况2（输入字符串有个别一维数组超出长度）</h4><p>输入：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">freertos</span><br><span class="line">rtc</span><br><span class="line">esp</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rows:<span class="number">3</span>                   |        |</span><br><span class="line">cols:<span class="number">6</span>                   |  esp   |&lt;<span class="number">-0062F</span>DFC</span><br><span class="line">freertrtc                |  rtc   |  <span class="number">0062F</span>DF6 <span class="comment">//rtc后面填充了3个\0</span></span><br><span class="line">rtc                      |freert  |  <span class="number">0062F</span>DF0 <span class="comment">//只能存储前六个字符</span></span><br><span class="line">esp                      |————————|</span><br><span class="line"><span class="comment">//指针指向栈低，输出freert 由于没有终止符\0，指针向栈顶移动，移动到地址为0062FDF6，继续输出该指针指向的内容，由于在该内容存在终止符，于是停止输出，最终结果为freertrtc</span></span><br></pre></td></tr></table></figure><h4 id="代码改进："><a href="#代码改进：" class="headerlink" title="代码改进："></a>代码改进：</h4><p> <code>scanf(&quot;%5s&quot;, arr[i]);</code> 替换程序中的 <code>scanf(&quot;%s&quot;, arr[i]);</code>每个字符串将被截断为最多5个字符（不包括结尾的空字符<code>\0</code>），因为 <code>%5s</code> 限制了每个输入字符串的最大长度为5。</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freertos   //敲击回车键（Enter键）会被视为输入结束的终止符</span><br><span class="line">rtc       //回车后就结束输入了   freer  tos\0  rtc\0   被截断填充到下一个字符数组中</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">freer  <span class="number">000000000062F</span>DF0</span><br><span class="line">tos  <span class="number">000000000062F</span>DF6</span><br><span class="line">rtc  <span class="number">000000000062F</span>DFC</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freertosrtcespabcd</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">freer  <span class="number">000000000062F</span>DF0</span><br><span class="line">tosrt  <span class="number">000000000062F</span>DF6</span><br><span class="line">cespa  <span class="number">000000000062F</span>DFC      <span class="comment">//说明%5s是将字符串截断，剩余的放到下一个字符数组中。保留一个字节存放终止符。</span></span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针:"></a>指针:</h1><p><strong>大佬之作</strong>：<a href="https://blog.csdn.net/soonfly/article/details/51131141">让你不再害怕指针——C指针详解(经典,非常详细)_c语言指针-CSDN博客</a></p><h2 id="指针基本类型："><a href="#指针基本类型：" class="headerlink" title="指针基本类型："></a>指针基本类型：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span></span><br><span class="line"><span class="type">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span></span><br><span class="line"><span class="type">int</span> *(*p(<span class="type">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure><h2 id="指针与数组："><a href="#指针与数组：" class="headerlink" title="指针与数组："></a>指针与数组：</h2><h3 id="指针与一维数组："><a href="#指针与一维数组：" class="headerlink" title="指针与一维数组："></a>指针与一维数组：</h3><h4 id="指针的初始化："><a href="#指针的初始化：" class="headerlink" title="指针的初始化："></a>指针的初始化：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指向已有变量的地址：</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;num; <span class="comment">// 指向已有变量num的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指向数组元素：</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr; <span class="comment">// 指向数组arr的第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配内存：</span></span><br><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配一个int大小的内存空间，并将指针ptr指向该空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指向空（NULL）：</span></span><br><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>; <span class="comment">// 将指针ptr初始化为空指针</span></span><br></pre></td></tr></table></figure><h4 id="P-P-P的含义"><a href="#P-P-P的含义" class="headerlink" title="*P,  P,  &amp;P的含义:"></a>*P,  P,  &amp;P的含义:</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> arr=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line">    <span class="type">int</span> *p1=arr;<span class="comment">//效果与*p1=&amp;arr[0],*p1=&amp;arr相同，但*p1=&amp;arr不推荐使用,会有waring.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  %p\n&quot;</span>, a, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  %p  %p\n&quot;</span>, *p, p, &amp;p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>  <span class="number">000000000062F</span>E1C</span><br><span class="line"><span class="number">10</span>  <span class="number">000000000062F</span>E1C  <span class="number">000000000062F</span>E10 </span><br><span class="line"><span class="comment">//*p:指针p所指向的int变量的值，即a的值。</span></span><br><span class="line"><span class="comment">// p:指针p所存储的地址，即变量a的地址。</span></span><br><span class="line"><span class="comment">//&amp;p:指针p本身的地址。</span></span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h4 id="指针算术"><a href="#指针算术" class="headerlink" title="指针算术"></a>指针算术</h4><p>数组名本身就是指向数组第一个指针与元素的指针  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr1 = numbers; <span class="comment">// 指向数组第一个元素的指针 </span></span><br><span class="line"><span class="type">int</span> *ptr2 = numbers + <span class="number">3</span>; <span class="comment">// 指向数组中的第四个元素的指针</span></span><br></pre></td></tr></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,arr[i],*(p+i),*(arr+i),p[i]);<span class="comment">//7 7 7 7以此法不会改变指针p指向的变量，但p++会指向下一个内存地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后缀是先使用后加加，后缀是先加加后使用</p><h4 id="p"><a href="#p" class="headerlink" title="*p++"></a>*p++</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;原*p的值: %d\n&quot;</span>, *p);  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">/// 后置++的优先级高于*,即 先p++ 后*p  但是后置++ 是先使用后++</span></span><br><span class="line"><span class="comment">/// 所以先使用 p 此时p为首元素地址 解引用p得到 1 赋给 a ,p使用完后++, p为第二个元素地址</span></span><br><span class="line"><span class="type">int</span> a = *p++; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, *p = %d\n&quot;</span>, a, *p); <span class="comment">// 1  4</span></span><br></pre></td></tr></table></figure><h4 id="p-1"><a href="#p-1" class="headerlink" title="*p++"></a>*p++</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;原*p的值: %d\n&quot;</span>, *p);  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">/// 和前面一样先 p++ 后 *p 但是后置++ 是先使用后++</span></span><br><span class="line"><span class="type">int</span> b = *(p++);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d: *p = %d\n&quot;</span>, b, *p); <span class="comment">// 1 4</span></span><br></pre></td></tr></table></figure><h4 id="p-2"><a href="#p-2" class="headerlink" title="(*p)++"></a>(*p)++</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;原*p的值: %d\n&quot;</span>, *p);  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 括号的优先级高于 后置++，所以先 *p 后++</span></span><br><span class="line"><span class="comment">// 后置++ 是先使用后++，*p 得到值 1 先使用赋给 c 然后++， *p变为 2，则arr[0]也变为2</span></span><br><span class="line"><span class="type">int</span> c = (*p)++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %d: *p = %d\n&quot;</span>, c, *p); <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure><h4 id="p-3"><a href="#p-3" class="headerlink" title="*++p"></a>*++p</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="comment">// 前置++的优先级高于*，先++p 后 *p</span></span><br><span class="line"><span class="comment">// 与第一个不同的是  前置++ 是 先++ 后使用</span></span><br><span class="line"><span class="comment">// 所以 p加加后指向arr第二个元素，即p存放第二个元素地址，解引用得到 4 赋给 d</span></span><br><span class="line"><span class="type">int</span> d = *++p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d: %d   *p = %d\n&quot;</span>, d, *p); <span class="comment">// 4  4</span></span><br></pre></td></tr></table></figure><h4 id="p-4"><a href="#p-4" class="headerlink" title="++*p"></a>++*p</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="type">int</span> e = ++ * p;  <span class="comment">// 等价于 ++（*p）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;e = %d  *p = %d\n&quot;</span>, e, *p); <span class="comment">// 2 2</span></span><br></pre></td></tr></table></figure><h3 id="指针与二维数组："><a href="#指针与二维数组：" class="headerlink" title="指针与二维数组："></a>指针与二维数组：</h3><p>具体见解请看<a href="https://blog.csdn.net/Zero__two_/article/details/120922718">https://blog.csdn.net/Zero__two_/article/details/120922718</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">借助指针进行传址操作只能改变当前指针指向的内容，并不能改变同级的实参 的值，所以并没打破 ”形参的改变不会影响实参“ 的准则。</span><br><span class="line">要想通过函数改变主函数中一级指针的指向，就必须借助二级指针的帮助。</span><br></pre></td></tr></table></figure><h4 id="指针二维数组初始化："><a href="#指针二维数组初始化：" class="headerlink" title="指针二维数组初始化："></a>指针二维数组初始化：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = matrix;  <span class="comment">//指针初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">sum += *(*(p+i)+j); <span class="comment">//访问第i行第j列， 二维数组指针访问格式 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(p + i)：这是一个指针运算，将指针 p 向后移动了 i 个元素的距离，使得它指向了二维数组中的第 i 行。</span></span><br><span class="line"><span class="comment">//*(p + i)：这是对指针进行解引用，即获取指针 p 移动后所指向的地址的值。在这里，它指向了二维数组中第 i 行的起始地址，也就是一个指向该行第一个元素的指针。</span></span><br><span class="line"><span class="comment">//*(p + i) + j：这一步再次进行指针运算，将指向第 i 行的指针偏移了 j 个元素的大小。这样就得到了指向第 i 行第 j 列元素的指针。</span></span><br><span class="line"><span class="comment">//*(*(p + i) + j)：最后，通过 * 解引用这个指针，就得到了第 i 行第 j 列元素的值。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,matrix, p, matrix[<span class="number">0</span>], &amp;matrix);<span class="comment">//62FDE0 62FDE0 62FDE0 62FDE0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p %p&quot;</span>,*matrix[<span class="number">1</span>], *(p+<span class="number">1</span>), matrix[<span class="number">1</span>]);<span class="comment">//5 62FDF0 62FDF0</span></span><br><span class="line"><span class="comment">//对于指针p可以p++改变指针P指向的方向</span></span><br><span class="line"><span class="comment">//对于数组matrix不可以使用递增/减操作符，matrix始终指向数组起始地址。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针与二级指针，三级指针"><a href="#指针与二级指针，三级指针" class="headerlink" title="指针与二级指针，三级指针"></a>指针与二级指针，三级指针</h3><p>使用二级指针&amp;三级指针遍历二维数组：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Two_Ptr</span><span class="params">(<span class="type">int</span> **p)</span>;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">Three_Ptr</span><span class="params">(<span class="type">int</span> ***p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">20</span>, <span class="number">24</span>, <span class="number">4</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)arr;<span class="comment">//将二维数组的地址转化为int*，并将地址赋值给ptr，为二级指针传参做准备</span></span><br><span class="line"><span class="type">int</span> **ptc = &amp;ptr;<span class="comment">//将int*类型的ptr地址赋值给二级指针ptc，为三级指针传参做准备</span></span><br><span class="line">Two_Ptr(&amp;ptr);</span><br><span class="line">Three_Ptr(&amp;ptc);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Two_Ptr</span><span class="params">(<span class="type">int</span> **p)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(*p+i*<span class="number">4</span>+j));<span class="comment">//*p：首先解引用一级指针 p，得到一个指针，它指向一个一维数组。*(*p+i*4+j)：在第一级指针解引用的基础上，加上 i*4+j 个偏移量，得到所需元素的地址，然后再次解引用，得到该地址处的元素值。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">Three_Ptr</span><span class="params">(<span class="type">int</span> ***p)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(**p+i*<span class="number">4</span>+j));<span class="comment">//**p：首先解引用二级指针 p，得到一个一级指针，它指向一个一维数组。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组作为形参传递不同点："><a href="#数组作为形参传递不同点：" class="headerlink" title="数组作为形参传递不同点："></a>数组作为形参传递不同点：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="comment">// 地址传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *arr)</span>;</span><br></pre></td></tr></table></figure><h3 id="int-salary-与-int-arr-作为形参传入函数的不同点："><a href="#int-salary-与-int-arr-作为形参传入函数的不同点：" class="headerlink" title="int salary 与 int arr[]作为形参传入函数的不同点："></a>int salary 与 int arr[]作为形参传入函数的不同点：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">demo</span><span class="params">(<span class="type">int</span> *num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> salary, arr[<span class="number">5</span>];</span><br><span class="line">    demo(&amp;salary); <span class="comment">//此时需要取地址</span></span><br><span class="line">    demo(arr);<span class="comment">//不需要取地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针和函数的关系"><a href="#指针和函数的关系" class="headerlink" title="指针和函数的关系"></a>指针和函数的关系</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">inta;</span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line">a=fun(str);</span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;;)</span><br><span class="line">    &#123;</span><br><span class="line">        num+=*s;s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str首地址传递给了s，s 所指向的地址就和str 所指向的地址一致。</span></span><br></pre></td></tr></table></figure><h3 id="两数交换代码例子"><a href="#两数交换代码例子" class="headerlink" title="两数交换代码例子"></a>两数交换代码例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   data = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = data;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;swap函数中a = %d b = %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;           </span><br><span class="line">   <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line">   swap(a,b);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;main函数中a = %d b = %d\n&quot;</span>,a,b);</span><br><span class="line">   system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>​从上面代码运行结果可以知道，在swap函数中将a、b的值已经交换了，但是在main函数中调用swap函数后a、b的值并没有交换。<br>这是因为swap函数的生存周期为调用swap函数那一刻到swap函数执行完这一时间段，swap函数中的a和b是在调用时临时开辟的空间swap执行完空间就释放了，什么都没有了，就算在swap函数中将形式参数a、b的值交换了，但是main函数中的值并没有交换。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   data = *a;</span><br><span class="line">   *a = *b;</span><br><span class="line">   *b = data;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;swap函数中a = %d b = %d\n&quot;</span>,*a,*b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;           </span><br><span class="line">   <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line">   swap(&amp;a,&amp;b);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;main函数中a = %d b = %d\n&quot;</span>,a,b);</span><br><span class="line">   system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从运行结果可以看出main函数和swap函数的a和b的值都已经交换了，这是为什么呢？<br>从代码中可以看出调用swap函数时实际参数传递的是a和b的地址，形式参数为两个int型的指针变量a和b，分别指向实际参数a和b的地址,在swap函数中进行的交换操作是直接访问的main函数中的a和b的值，所以就算swap函数的空间释放了main函数中a和b的值已经通过swap函数进行交换了。<br>即通过指针可以在子函数中改变main函数的值</p><p>原文链接：<a href="https://blog.csdn.net/qq_48458789/article/details/112743244">https://blog.csdn.net/qq_48458789/article/details/112743244</a></p><h3 id="教学例子"><a href="#教学例子" class="headerlink" title="教学例子"></a>教学例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  THRESHOLD_FIRST *Salary-*Salary*0.2 -3500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  THRESHOLD_SECOND *Salary-7662*0.2-3500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  BOUNDARY 7662</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Tax</span><span class="params">(<span class="type">int</span> *Salary, <span class="type">int</span> *tax)</span>;<span class="comment">//此次主要是想求出个税tax，只传入已知的Salary那么只能通过Tax（）函数的return获取tax，再加一个变量传入tax的地址，函数Tax（）释放后，主函数内的tax值已被修改。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Salary, tax;  <span class="comment">//Salary税前薪资， tax个税</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您的工资数额:&quot;</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Salary);</span><br><span class="line">Tax(&amp;Salary,&amp;tax); <span class="comment">//传入Salary,tax的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n您因缴纳的个税为%d&quot;</span>,tax);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Tax</span><span class="params">(<span class="type">int</span> *Salary,<span class="type">int</span> *tax)</span>&#123;</span><br><span class="line"><span class="type">int</span> Five_One;</span><br><span class="line">Five_One = *Salary&lt;BOUNDARY ? THRESHOLD_FIRST : THRESHOLD_SECOND;</span><br><span class="line"><span class="keyword">if</span>(Five_One&lt;=<span class="number">1500</span>)&#123;</span><br><span class="line">*tax = Five_One*<span class="number">0.03</span> - <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Five_One&lt;=<span class="number">4500</span>)&#123;</span><br><span class="line">*tax = Five_One*<span class="number">0.1</span> <span class="number">-105</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Five_One&lt;=<span class="number">9000</span>)&#123;</span><br><span class="line">*tax = Five_One*<span class="number">0.2</span> <span class="number">-555</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *tax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Remove_Space</span><span class="params">(<span class="type">char</span> *arr)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(arr) ==<span class="number">0</span> || arr == <span class="literal">NULL</span>)&#123;   <span class="comment">//strlen()即便是在子函数传入的字符数组也能求出字符串长度，而sizeof（）只会把arr当做地址，求出长度为1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数据未初始化&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *first_ptr = arr;</span><br><span class="line"><span class="type">char</span> *second_ptr = arr;</span><br><span class="line"><span class="keyword">while</span>(*first_ptr != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(*first_ptr != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">*second_ptr = *first_ptr;</span><br><span class="line"> second_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">first_ptr++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">*second_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Printf_Arr</span><span class="params">(<span class="type">char</span> *arr)</span>&#123;</span><br><span class="line"><span class="comment">//while(*arr != &#x27;\0&#x27;)&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;%c&quot;,*arr++);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,arr); <span class="comment">//跟strlen（）一样检测到终止符才结束</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Change_Arr</span><span class="params">(<span class="type">char</span> *arr)</span>&#123;</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">strlen</span>(arr);</span><br><span class="line"><span class="type">char</span> *first_ptr = arr;</span><br><span class="line"><span class="type">char</span> *end_ptr = &amp;arr[length<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">while</span>(end_ptr &gt;= first_ptr)&#123;</span><br><span class="line"><span class="type">char</span> temp = *first_ptr;</span><br><span class="line">*first_ptr = *end_ptr;</span><br><span class="line">*end_ptr = temp;</span><br><span class="line">first_ptr++;</span><br><span class="line">end_ptr--;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char *temp = first_ptr; </span></span><br><span class="line"><span class="comment">*first_ptr = *end_ptr;</span></span><br><span class="line"><span class="comment">*end_ptr = *temp;</span></span><br><span class="line"><span class="comment">first_ptr++;</span></span><br><span class="line"><span class="comment">end_ptr--;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//在上述注释代码中，运行结果为*first_ptr与*end_ptr值相等，引起此原因是定义了返回类型为char的temp指针并指向first_ptr所指向的地址,当*first_ptr = *end_ptr，同时改变了指向first_ptr的temp的值。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Data_Printf</span><span class="params">(<span class="keyword">struct</span> Person *Person_Data)</span>; <span class="comment">//这里需要加上struct,不然会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line">&#125;Date;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>]; <span class="comment">//不能以char *name定义.</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    Date* birthday;</span><br><span class="line">&#125;Person;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Date birth = &#123;<span class="number">2002</span>, <span class="number">04</span>, <span class="number">07</span>&#125;;</span><br><span class="line">Person student = &#123;<span class="string">&quot;阿萨德&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;m&#x27;</span>, &amp;birth&#125;;<span class="comment">//不能&quot;m&quot;赋值，&quot;&quot;用于字符串，使用&quot;&quot;会是字符&#x27;m&#x27;转化为字符串. </span></span><br><span class="line">Date other_birth = &#123;<span class="number">2001</span>, <span class="number">10</span>, <span class="number">29</span>&#125;;</span><br><span class="line">Person other_student = &#123;<span class="string">&quot;苏德霞&quot;</span>, <span class="number">19</span>, <span class="string">&#x27;f&#x27;</span>, &amp;other_birth&#125;;</span><br><span class="line">   Data_Printf(&amp;student);</span><br><span class="line">   Data_Printf(&amp;other_student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Data_Printf</span><span class="params">(Person *Person_Data)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,Person_Data-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Person_Data-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,Person_Data-&gt;sex==<span class="string">&#x27;m&#x27;</span>?<span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span>);<span class="comment">//想要输出汉字需要用%s输出，这种写法很新奇 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d\n&quot;</span>,Person_Data-&gt;birthday-&gt;year,Person_Data-&gt;birthday-&gt;month,Person_Data-&gt;birthday-&gt;day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH sizeof(Student)/sizeof(Student[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASCENDING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESCENDING 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> sex;</span><br><span class="line"><span class="type">float</span> height;</span><br><span class="line">&#125;Person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Init</span><span class="params">(Person *Student, <span class="type">void</span> *arr[], <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Printf</span><span class="params">(<span class="type">void</span> *arr[], <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Sort</span><span class="params">(<span class="type">void</span> *arr[], <span class="type">int</span> length, <span class="type">int</span> option)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Message_Change_Height</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b, <span class="type">int</span> option)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Person Student[<span class="number">3</span>]=&#123;</span><br><span class="line">&#123;<span class="string">&quot;发萨斯&quot;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">171.4</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;阿西尔&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">175.2</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;约旦&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">182</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> *arr[LENGTH];</span><br><span class="line">Message_Init(Student, arr, LENGTH);</span><br><span class="line">Message_Printf(arr, LENGTH);</span><br><span class="line">Message_Sort(arr, LENGTH, ASCENDING);</span><br><span class="line">Message_Printf(arr, LENGTH);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Init</span><span class="params">(Person *Student, <span class="type">void</span> *arr[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length &lt;= <span class="number">0</span> || Student == <span class="literal">NULL</span> || arr == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结构体数组不能为空&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">arr[i] = Student+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Printf</span><span class="params">(<span class="type">void</span> *arr[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %.1f\n&quot;</span>, ((Person *)arr[i])-&gt;name, ((Person *)arr[i])-&gt;sex==<span class="string">&#x27;f&#x27;</span> ? <span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span>,((Person *)arr[i])-&gt;height);<span class="comment">//不能写成(arr+i)-&gt;name;因为使用 (arr + i)-&gt;name 时，实际上是在尝试将整个 Person* 指针（arr[i]）视为一个结构体 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Sort</span><span class="params">(<span class="type">void</span> *arr[], <span class="type">int</span> length, <span class="type">int</span> option)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Message_Change_Height(arr[i],arr[i+<span class="number">1</span>],option) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">void</span> *temp = arr[i];</span><br><span class="line">arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">arr[i+<span class="number">1</span>] = temp;</span><br><span class="line"><span class="comment">//arr[i]是一个地址，不能相加（四字节的地址相加可能会导致地址溢出，但可以进行指针算术相减（相减结果为步长）  </span></span><br><span class="line"><span class="comment">/*arr[i] = arr[i] + arr[i+1];  </span></span><br><span class="line"><span class="comment">arr[i+1] = arr[i] - arr[i+1];</span></span><br><span class="line"><span class="comment">arr[i] = arr[i] - arr[i+1];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">Message_Change_Height</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b, <span class="type">int</span> option)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> option ? ((Person *)a)-&gt;height&lt;((Person *)b)-&gt;height : ((Person *)a)-&gt;height&gt;((Person *)b)-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC编译与GDB调试</title>
      <link href="/2024/03/30/Gcc%E7%BC%96%E8%AF%91%E4%B8%8EGdb%E8%B0%83%E8%AF%95/"/>
      <url>/2024/03/30/Gcc%E7%BC%96%E8%AF%91%E4%B8%8EGdb%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="GCC编译与GDB调试"><a href="#GCC编译与GDB调试" class="headerlink" title="GCC编译与GDB调试"></a>GCC编译与GDB调试</h1><h2 id="一-gcc"><a href="#一-gcc" class="headerlink" title="一.gcc"></a>一.gcc</h2><h3 id="1-gcc简介："><a href="#1-gcc简介：" class="headerlink" title="1.gcc简介："></a>1.gcc简介：</h3><p>​gcc命令使用GNU推出的基于C&#x2F;C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。</p><p>​gcc是GNU编译器套件（GNU Compiler Collection），它包括了C、C++、Objective-C、Fortran、Java、Ada、Go语言和D语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。</p><h3 id="2-gcc编译链接过程"><a href="#2-gcc编译链接过程" class="headerlink" title="2.gcc编译链接过程"></a>2.gcc编译链接过程</h3><p>（1）预编译：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`gcc -e main.c -o main.i <span class="comment">//-o选项用来指定输出文件的文件名 </span></span><br></pre></td></tr></table></figure><p>（2）编译：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -s main.i -o main.s</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc test001.c test002.c -o test  <span class="comment">//将test001.c和test002.c分别编译后连接成test可执行文件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础知识</title>
      <link href="/2024/03/29/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/03/29/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h1><h4 id="构造函数-析构函数-拷贝构造函数-静态函数"><a href="#构造函数-析构函数-拷贝构造函数-静态函数" class="headerlink" title="构造函数-析构函数-拷贝构造函数-静态函数"></a>构造函数-析构函数-拷贝构造函数-静态函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************student.h******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STUDENT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STUDENT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; </span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> state;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;<span class="comment">//在C++中，对于类的静态成员变量，必须在类的外部进行初始化。告诉编译器为静态成员变量分配内存空间，并且可以给它一个初始值。这样做可以确保在程序的任何地方都能正确地使用静态成员变量，并且只有一个实例。</span></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 构造函数声明</span></span><br><span class="line">    Student(<span class="type">int</span> id, <span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="type">char</span> sex, <span class="type">int</span> age, <span class="type">float</span> height);</span><br><span class="line">    ~Student(); </span><br><span class="line">    Student(<span class="type">const</span> Student &amp;S1);<span class="comment">//为了防止递归引用,拷贝构造函数必须是引用传递，不能是值传递</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************student.cpp*******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">Student::Student(<span class="type">int</span> id, <span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="type">char</span> sex, <span class="type">int</span> age, <span class="type">float</span> height) :id(id), state(<span class="string">&quot;已调用&quot;</span>) &#123;</span><br><span class="line">    this-&gt;age = age;</span><br><span class="line">    this-&gt;name = name;</span><br><span class="line">    this-&gt;sex = sex;</span><br><span class="line">    this-&gt;height = height;</span><br><span class="line">    ptr = new <span class="type">char</span>[name.length() + <span class="number">1</span>]; <span class="comment">// 为字符串长度加上终止符 &#x27;\0&#x27; 分配内存</span></span><br><span class="line">    strcpy_s(ptr, name.length() + <span class="number">1</span>, name.c_str());  <span class="comment">// 将字符串复制到分配的内存中，使用 name.c_str() 来获取 std::string 对象 name 中存储的字符序列，并将其传递给 std::strcpy() 函数，以将其复制到 ptr 指向的内存中。因为 std::strcpy() 函数需要一个以 null 结尾的 C 字符串作为参数，所以我们需要使用 c_str() 函数来获取相应的 C 字符串</span></span><br><span class="line">    strncpy_s(ptr, <span class="keyword">sizeof</span>(ptr), name, length); <span class="comment">//如果ptr是数组类型，那么返回的是数组长度。如果ptr是指针类型，那么sizeof(ptr) 返回的是指针的大小（通常是 4 或 8 字节），而不是字符串的长度。</span></span><br><span class="line">    Student::count++;</span><br><span class="line">    Student::count++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造函数已调用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::~Student()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数已调用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">Student::count--;</span><br><span class="line">delete[] ptr;</span><br><span class="line">    ptr = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。</span></span><br><span class="line">Student::Student(<span class="type">const</span> Student &amp;S1):id(S1.id)&#123;</span><br><span class="line">ptr = new <span class="type">char</span>[S1.name.length() + <span class="number">1</span>]; <span class="comment">//+1是为了存入&#x27;\0&#x27;</span></span><br><span class="line">strcpy_s(ptr, S1.name.length() + <span class="number">1</span>, S1.name.c_str());</span><br><span class="line">this-&gt;name = S1.name; <span class="comment">//这时传入的参数是S1，需要指定S1.name</span></span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数已调用&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> Student::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*************************student_main.cpp**************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">Student *S1 = new Student(<span class="number">341222</span>,<span class="string">&quot;阿瑞尔&quot;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">18</span>,<span class="number">181.1f</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;默认参数id:&quot;</span> &lt;&lt;S1-&gt;id&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;字符数组：&quot;</span>&lt;&lt;S1-&gt;ptr&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt;S1-&gt;count&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">Student *S2 = new Student(*S1); </span><br><span class="line">    <span class="comment">//Student S2 = *S1;   可以调用拷贝构造函数</span></span><br><span class="line">    <span class="comment">//Student *S2 = S1;   不可以调用拷贝构造函数，在C++中，可以写成 Student *S2 = S1;，但这并不是复制对象的行为，而是将 S2 指针指向与 S1 相同的对象。这样做会导致 S1 和 S2 指向同一个对象，而不是创建一个新的对象。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt;S1-&gt;count&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;默认参数id:&quot;</span> &lt;&lt;S2-&gt;id&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">delete S1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt;S1-&gt;count&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">delete S2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt;S1-&gt;count&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//********************************printf***************************************</span></span><br><span class="line">有参构造函数已调用</span><br><span class="line">默认参数id:<span class="number">341222</span></span><br><span class="line">字符数组：阿瑞尔</span><br><span class="line">count:<span class="number">1</span></span><br><span class="line">拷贝构造函数已调用</span><br><span class="line">count:<span class="number">2</span></span><br><span class="line">默认参数id:<span class="number">341222</span></span><br><span class="line">析构函数已调用</span><br><span class="line">count:<span class="number">1</span></span><br><span class="line">析构函数已调用</span><br><span class="line">count:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line">Process exited after <span class="number">0.02544</span> seconds with <span class="keyword">return</span> value <span class="number">0</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h4 id="封装-模板函数-面向过程"><a href="#封装-模板函数-面向过程" class="headerlink" title="封装-模板函数-面向过程"></a>封装-模板函数-面向过程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  MYARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  MYARRAY_H</span></span><br><span class="line"></span><br><span class="line">template&lt;typename  E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span>   len; <span class="comment">// 数组容量</span></span><br><span class="line">    E* p;  <span class="comment">// 数组指针</span></span><br><span class="line">    <span class="type">int</span>   size;<span class="comment">// 数组尺寸 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">resetLen</span><span class="params">()</span> &#123;</span><br><span class="line">        E* temp = new E[len * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            temp[i] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete[] p;</span><br><span class="line">        p = temp;</span><br><span class="line">        len = len * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyArray(<span class="type">int</span> len = <span class="number">10</span>) :len(len), size(<span class="number">0</span>) &#123;</span><br><span class="line">        p = new E[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>  <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= len) &#123;</span><br><span class="line">            resetLen();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; index - <span class="number">1</span>; i--) &#123;</span><br><span class="line">            p[i + <span class="number">1</span>] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p[index] = data;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span>  <span class="title function_">add</span><span class="params">(E  data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= len) &#123;</span><br><span class="line">            resetLen();</span><br><span class="line">        &#125;</span><br><span class="line">        p[size] = data;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>   <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            p[i] = p[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> index, E data)</span> &#123;</span><br><span class="line">        p[index] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*void  sort(auto  aaa) &#123;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; size - i; j++) &#123;</span></span><br><span class="line"><span class="comment">                if (aaa(p[j], p[j + 1]) &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">                    E  temp = p[j];</span></span><br><span class="line"><span class="comment">                    p[j] = p[j + 1];</span></span><br><span class="line"><span class="comment">                    p[j + 1] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    E  <span class="title function_">getData</span><span class="params">(<span class="type">int</span>  index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  p[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>  <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyArray() &#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP-S3的智能手环</title>
      <link href="/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/"/>
      <url>/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="资料准备："><a href="#资料准备：" class="headerlink" title="资料准备："></a>资料准备：</h1><h4 id="SPI-LCD详解："><a href="#SPI-LCD详解：" class="headerlink" title="SPI LCD详解："></a>SPI LCD详解：</h4><p><a href="https://docs.espressif.com/projects/esp-iot-solution/zh_CN/latest/display/lcd/spi_lcd.html">SPI LCD 详解 - - — ESP-IoT-Solution latest 文档 (espressif.com)</a></p><h4 id="ESP-IDF编程指南："><a href="#ESP-IDF编程指南：" class="headerlink" title="ESP-IDF编程指南："></a>ESP-IDF编程指南：</h4><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/index.html">ESP-IDF 编程指南 - ESP32 - — ESP-IDF 编程指南 latest 文档 (espressif.com)</a></p><h4 id="屏幕技术手册（P169H002-："><a href="#屏幕技术手册（P169H002-：" class="headerlink" title="屏幕技术手册（P169H002)："></a>屏幕技术手册（P169H002)：</h4><h4 id="屏幕驱动IC的技术手册-ST7789V-："><a href="#屏幕驱动IC的技术手册-ST7789V-：" class="headerlink" title="屏幕驱动IC的技术手册(ST7789V)："></a>屏幕驱动IC的技术手册(ST7789V)：</h4><h4 id="触摸IC的技术手册-CST816D-："><a href="#触摸IC的技术手册-CST816D-：" class="headerlink" title="触摸IC的技术手册(CST816D)："></a>触摸IC的技术手册(CST816D)：</h4><h4 id="屏幕原厂提供的配置设置："><a href="#屏幕原厂提供的配置设置：" class="headerlink" title="屏幕原厂提供的配置设置："></a>屏幕原厂提供的配置设置：</h4><h4 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h4><p>ESP-IDF –V5.1.1</p><p>LVGL –8.3.9</p><h4 id="硬件环境："><a href="#硬件环境：" class="headerlink" title="硬件环境："></a>硬件环境：</h4><p>ESP-S3-DevKitC-1WPOOM-1</p><p>FPC转接板</p><p>3.7V锂电池</p><p>P169H002电容触摸屏</p><h1 id="知识收获"><a href="#知识收获" class="headerlink" title="知识收获"></a>知识收获</h1><p>nvs非易失性存储  </p><p>ESP32是SPI  Flash</p><p>0x1000 &#x3D; 4K      0x100000 &#x3D; 1M</p><h1 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h1><p>当使用 <code>UART0</code> 管脚下载固件时，需要满足以下接线条件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VDD     -&gt; 3V3</span><br><span class="line">GND     -&gt; GND   (与供电板“共地”)</span><br><span class="line">EN      -&gt; 拉高   (用于上电启动、不可浮空)</span><br><span class="line">GPIO0   -&gt; 拉低   (进入下载模式)</span><br><span class="line">GPIO46  -&gt; 拉低</span><br><span class="line">TXD0(GPIO43)    -&gt; RX</span><br><span class="line">RXD0(GPIO44)    -&gt; TX</span><br></pre></td></tr></table></figure><p><img src="/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF" alt="KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK"></p><h4 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h4><p>检测导通用万用表，红笔接地不动。</p><p><img src="/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF" alt="image-20240411193142332"></p><table><thead><tr><th>FPC转接板</th><th>引脚</th></tr></thead><tbody><tr><td>PIN_3</td><td>3.3V</td></tr><tr><td>PIN_4</td><td>3.3V</td></tr><tr><td>PIN_17</td><td>3.3V</td></tr><tr><td>PIN_1</td><td>GND</td></tr><tr><td>PIN_2</td><td>GND</td></tr><tr><td>PIN_5</td><td>GND</td></tr><tr><td>PIN_6</td><td>GND</td></tr><tr><td>PIN_18</td><td>GND</td></tr><tr><td>PIN_12</td><td>GND</td></tr><tr><td>7</td><td>G9</td></tr><tr><td>8</td><td>G10</td></tr><tr><td>9</td><td>G11</td></tr><tr><td>10</td><td>G12</td></tr><tr><td>11</td><td>G13</td></tr><tr><td>13</td><td>G4</td></tr><tr><td>14</td><td>G5</td></tr><tr><td>15</td><td>G6</td></tr><tr><td>16</td><td>G7</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="SPI屏幕驱动IDF-组件注册表-—-IDF-Component-Registry-espressif-com"><a href="#SPI屏幕驱动IDF-组件注册表-—-IDF-Component-Registry-espressif-com" class="headerlink" title="SPI屏幕驱动IDF 组件注册表 — IDF Component Registry (espressif.com)"></a>SPI屏幕驱动<a href="https://components.espressif.com/components/espressif/esp_lcd_ili9341">IDF 组件注册表 — IDF Component Registry (espressif.com)</a></h4><p><img src="/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF" alt="image-20240411193536757"></p><p>3线spi和4线spi 的主要区别在于是否使用 D&#x2F;C 信号线。</p><h1 id="屏幕驱动"><a href="#屏幕驱动" class="headerlink" title="屏幕驱动"></a>屏幕驱动</h1><p>在main文件夹下的CMakeList.txt中修改为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Add sources from ui directory</span><br><span class="line">file(GLOB_RECURSE SRC_UI $&#123;CMAKE_SOURCE_DIR&#125; &quot;ui/*.c&quot;)</span><br><span class="line"></span><br><span class="line">idf_component_register(SRCS &quot;main.c&quot; $&#123;SRC_UI&#125;</span><br><span class="line">                    INCLUDE_DIRS &quot;.&quot; &quot;ui&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在main文件下创建idf_component.yml修改为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  lvgl/lvgl: &quot;==8.3.9&quot;</span><br><span class="line">  ## Required IDF version</span><br><span class="line">  idf:</span><br><span class="line">    version: &quot;&gt;=5.1.0&quot;</span><br><span class="line"></span><br><span class="line">  espressif/esp_lcd_ili9341: &quot;^1.2.0&quot;</span><br><span class="line"></span><br><span class="line">  espressif/esp_lcd_touch_cst816s: &quot;^1.0.3&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI"></a>WIFI</h1><p>在项目根目录下创建sdkconfig.defaults添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_EXAMPLE_WIFI_SSID=&quot;esp&quot;</span><br><span class="line">CONFIG_EXAMPLE_WIFI_PASSWORD=&quot;12345678&quot;</span><br></pre></td></tr></table></figure><p>在项目根目录下的CMakeLists.txt中添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(EXTRA_COMPONENT_DIRS $ENV&#123;IDF_PATH&#125;/examples/common_components/protocol_examples_common)</span><br></pre></td></tr></table></figure><h4 id="天气信息与lvgl交互"><a href="#天气信息与lvgl交互" class="headerlink" title="天气信息与lvgl交互"></a>天气信息与lvgl交互</h4><p>1.lvgl任务只能使用被完全解析的天气信息</p><p>2.lvgl任务要在json数据被释放之前完成读取</p><p>在ui.c中添加头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注释掉ui.c 中777-780行的代码</span></span><br><span class="line">sunday_Animation(ui_sun, <span class="number">0</span>);</span><br><span class="line">cloud_Animation(ui_cloud1, <span class="number">0</span>);</span><br><span class="line">cloud2_Animation(ui_cloud2, <span class="number">0</span>);</span><br><span class="line">cloud_Animation(ui_cloud3, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//注释掉ui.c 中855行的代码</span></span><br><span class="line">sec_Animation(ui_Sec, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////event_call//////////////////</span></span><br><span class="line"><span class="type">uint8_t</span> wodder_num = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> wodder_str[<span class="number">10</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">wodder_add</span><span class="params">(<span class="type">lv_event_t</span> *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(wodder_num &lt; <span class="number">20</span>)&#123;</span><br><span class="line">        wodder_num++;</span><br><span class="line">        <span class="built_in">snprintf</span>(wodder_str, <span class="keyword">sizeof</span>(wodder_str), <span class="string">&quot;%d&quot;</span>, wodder_num);</span><br><span class="line">        lv_label_set_text_fmt(ui_Label5, <span class="string">&quot;%s&quot;</span>, wodder_str);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lv_label_set_text_fmt(ui_Label5, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;圆满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> time_num = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> water_time_long = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">water_call</span><span class="params">(<span class="type">lv_event_t</span> *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int8_t</span> water_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int8_t</span> updata_num = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int16_t</span> water_num_all = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int16_t</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ESP_LOGI(TAG, &quot;饮水量1 %d&quot;, (int16_t)ui_Water_Chart_series_1_array[1]);</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;flag %d&quot;</span>, water_flag);</span><br><span class="line">    <span class="keyword">if</span> (water_flag == <span class="number">0</span>)&#123;</span><br><span class="line">        lv_obj_clear_flag(ui_Panel3, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_Panel4, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        water_flag = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lv_obj_clear_flag(ui_Panel4, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_Panel3, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        <span class="type">char</span> *text = lv_label_get_text(ui_Label6);</span><br><span class="line">        <span class="keyword">if</span>(*(text+<span class="number">2</span>) != <span class="string">&#x27;m&#x27;</span>)&#123;</span><br><span class="line">            num += (*(text+<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">100</span>;</span><br><span class="line">            num += (*(text+<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span>;</span><br><span class="line">            num += *(text+<span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num += (*(text+<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span>;</span><br><span class="line">            num += *(text+<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">static</span> <span class="type">lv_coord_t</span> ui_Water_Chart_series_1_array_second[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span>(updata_num &lt; <span class="number">9</span>)&#123;</span><br><span class="line">            ui_Water_Chart_series_1_array_second[updata_num] = num;</span><br><span class="line">            water_num_all += num;</span><br><span class="line">            time_num = water_time_long;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            updata_num = <span class="number">1</span>;</span><br><span class="line">            water_num_all = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lv_label_set_text_fmt(ui_water_all, <span class="string">&quot;今日饮水总量：%dml&quot;</span>, water_num_all);</span><br><span class="line">        lv_chart_set_ext_y_array(ui_Water_Chart, ui_Water_Chart_series_1, ui_Water_Chart_series_1_array_second);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;饮水量4 %d&quot;</span>, num);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;饮水量5 %s&quot;</span>, text);</span><br><span class="line">        water_flag = <span class="number">0</span>;</span><br><span class="line">        updata_num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">water_time</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int16_t</span> water_time_num = water_time_long - time_num;</span><br><span class="line">    lv_label_set_text_fmt(ui_water_time, <span class="string">&quot;距离上次饮水已过%d分钟&quot;</span>, water_time_num/<span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////weather_if//////////////////</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Weather_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;天气 %s&quot;</span>, my_text);</span><br><span class="line">    <span class="keyword">if</span>(Weather_Judge(my_text, <span class="string">&quot;晴&quot;</span>))&#123;</span><br><span class="line">        lv_obj_clear_flag(ui_sunday, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_cloudy, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_rain, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        sunday_Animation(ui_sun, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Weather_Judge(my_text, <span class="string">&quot;多云&quot;</span>))&#123;</span><br><span class="line">        lv_obj_clear_flag(ui_cloudy, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_sunday, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_rain, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        cloud_Animation(ui_cloud1, <span class="number">0</span>);</span><br><span class="line">        cloud2_Animation(ui_cloud2, <span class="number">0</span>);</span><br><span class="line">        cloud_Animation(ui_cloud3, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Weather_Judge(my_text, <span class="string">&quot;阴&quot;</span>))&#123;</span><br><span class="line">        lv_obj_clear_flag(ui_cloudy, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_sun2, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_sunday, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_rain, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        cloud_Animation(ui_cloud1, <span class="number">0</span>);</span><br><span class="line">        cloud2_Animation(ui_cloud2, <span class="number">0</span>);</span><br><span class="line">        cloud_Animation(ui_cloud3, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Weather_Judge(my_text, <span class="string">&quot;雨&quot;</span>))&#123;</span><br><span class="line">        lv_obj_clear_flag(ui_rain, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_sunday, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_add_flag(ui_cloudy, LV_OBJ_FLAG_HIDDEN);</span><br><span class="line">        lv_obj_move_foreground(ui_temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Weather_Judge</span><span class="params">(<span class="type">char</span> my_text[], <span class="type">char</span> *search_word)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> i = <span class="number">0</span>, j = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(my_text) &amp;&amp; j &lt; <span class="built_in">strlen</span>(search_word) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(my_text+i) == *(search_word+j))</span><br><span class="line">        &#123; </span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>; </span><br><span class="line">            j = <span class="number">0</span>;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">strlen</span>(search_word))</span><br><span class="line">        &#123;             </span><br><span class="line">            flag = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////wifi_call//////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wifi_call</span><span class="params">(<span class="type">lv_event_t</span> *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    http_rest_with_url();</span><br><span class="line">    lv_label_set_text_fmt(ui_temp, <span class="string">&quot;%d&quot;</span>, my_temp);</span><br><span class="line">    lv_label_set_text_fmt(ui_rh, <span class="string">&quot;%d&quot;</span>, my_rh);</span><br><span class="line">    lv_label_set_text_fmt(ui_wind_class, <span class="string">&quot;%s&quot;</span>, my_wind_class);</span><br><span class="line">    lv_label_set_text_fmt(ui_text, <span class="string">&quot;%s&quot;</span>, my_text);</span><br><span class="line">    lv_label_set_text_fmt(ui_name, <span class="string">&quot;%s&quot;</span>, my_name);</span><br><span class="line">    Weather_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////time_init///////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span> =</span> &#123;</span><br><span class="line">    .tv_sec = <span class="number">0</span>,</span><br><span class="line">    .tv_usec = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">timeinfo</span>;</span></span><br><span class="line"><span class="type">char</span> My_Clock_Flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ui_clock_update</span><span class="params">(<span class="type">lv_timer_t</span> *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> current_time = (<span class="type">time_t</span>)(time_long / <span class="number">1000</span> - My_Clock_Flag);</span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(My_Clock_Flag == <span class="number">0</span>)&#123;</span><br><span class="line">        current_time -= tv.tv_sec; </span><br><span class="line">        My_Clock_Flag = tv.tv_sec;</span><br><span class="line">    &#125;</span><br><span class="line">    tv.tv_sec += current_time;</span><br><span class="line">    water_time_long = tv.tv_sec;</span><br><span class="line">    setenv(<span class="string">&quot;TZ&quot;</span>, <span class="string">&quot;CST-8&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    tzset();</span><br><span class="line">    timeinfo = localtime(&amp;tv.tv_sec);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> time_str[<span class="number">9</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(time_str, <span class="string">&quot;%02d:%02d:%02d&quot;</span>, timeinfo-&gt;tm_hour, timeinfo-&gt;tm_min, timeinfo-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> date_str[<span class="number">20</span>]; <span class="comment">// 假设月份和日期都是两位数，加上斜杠和字符串结束符</span></span><br><span class="line">    <span class="built_in">sprintf</span>(date_str, <span class="string">&quot;%04d/%02d/%02d&quot;</span>, timeinfo-&gt;tm_year, timeinfo-&gt;tm_mon+<span class="number">1</span>, timeinfo-&gt;tm_mday);</span><br><span class="line"></span><br><span class="line">    lv_img_set_angle(ui_Sec, timeinfo-&gt;tm_sec * <span class="number">60</span>);</span><br><span class="line">    lv_img_set_angle(ui_Min, timeinfo-&gt;tm_min * <span class="number">60</span>);</span><br><span class="line">    lv_img_set_angle(ui_Hour, timeinfo-&gt;tm_hour * <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lv_label_set_text_fmt(ui_Clock_Number, <span class="string">&quot;%s&quot;</span>, time_str);</span><br><span class="line">    lv_label_set_text_fmt(ui_Date, <span class="string">&quot;%s&quot;</span>, date_str);</span><br><span class="line">    water_time();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ui_time_init</span><span class="params">()</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">lv_timer_t</span> *time_clock = lv_timer_create(ui_clock_update, <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">    ui_clock_update(time_clock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在ui.h的19添加以下代码</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wodder_add</span><span class="params">(<span class="type">lv_event_t</span> *e)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">water_call</span><span class="params">(<span class="type">lv_event_t</span> *e)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">water_time</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">http_rest_with_url</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> my_temp;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> my_name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> my_text[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> my_wind_class[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> my_rh;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *clock_timer;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *TAG;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">long</span> <span class="type">long</span> time_long;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">lv_chart_series_t</span> * ui_Water_Chart_series_1;</span><br><span class="line"><span class="comment">//extern lv_coord_t ui_Water_Chart_series_1_array[];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ui_time_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ui_clock_update</span><span class="params">(<span class="type">lv_timer_t</span> *timer)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Weather_Judge</span><span class="params">(<span class="type">char</span> my_text[], <span class="type">char</span> *search_word)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Weather_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">lv_obj_add_flag(ui_Label5, LV_OBJ_FLAG_HIDDEN);<span class="comment">//隐藏对象</span></span><br><span class="line"></span><br><span class="line"> lv_obj_clear_flag(user_obj, LV_OBJ_FLAG_HIDDEN);<span class="comment">//取消隐藏</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP-S3 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++基础知识</title>
    <url>/2024/03/29/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h1><h4 id="构造函数-析构函数-拷贝构造函数-静态函数"><a href="#构造函数-析构函数-拷贝构造函数-静态函数" class="headerlink" title="构造函数-析构函数-拷贝构造函数-静态函数"></a>构造函数-析构函数-拷贝构造函数-静态函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************student.h******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STUDENT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STUDENT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">	<span class="type">int</span> <span class="type">const</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; </span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> state;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;<span class="comment">//在C++中，对于类的静态成员变量，必须在类的外部进行初始化。告诉编译器为静态成员变量分配内存空间，并且可以给它一个初始值。这样做可以确保在程序的任何地方都能正确地使用静态成员变量，并且只有一个实例。</span></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 构造函数声明</span></span><br><span class="line">    Student(<span class="type">int</span> id, <span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="type">char</span> sex, <span class="type">int</span> age, <span class="type">float</span> height);</span><br><span class="line">    ~Student(); </span><br><span class="line">    Student(<span class="type">const</span> Student &amp;S1);<span class="comment">//为了防止递归引用,拷贝构造函数必须是引用传递，不能是值传递</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************student.cpp*******************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">Student::Student(<span class="type">int</span> id, <span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="type">char</span> sex, <span class="type">int</span> age, <span class="type">float</span> height) :id(id), state(<span class="string">&quot;已调用&quot;</span>) &#123;</span><br><span class="line">    this-&gt;age = age;</span><br><span class="line">    this-&gt;name = name;</span><br><span class="line">    this-&gt;sex = sex;</span><br><span class="line">    this-&gt;height = height;</span><br><span class="line">    ptr = new <span class="type">char</span>[name.length() + <span class="number">1</span>]; <span class="comment">// 为字符串长度加上终止符 &#x27;\0&#x27; 分配内存</span></span><br><span class="line">    strcpy_s(ptr, name.length() + <span class="number">1</span>, name.c_str());  <span class="comment">// 将字符串复制到分配的内存中，使用 name.c_str() 来获取 std::string 对象 name 中存储的字符序列，并将其传递给 std::strcpy() 函数，以将其复制到 ptr 指向的内存中。因为 std::strcpy() 函数需要一个以 null 结尾的 C 字符串作为参数，所以我们需要使用 c_str() 函数来获取相应的 C 字符串</span></span><br><span class="line">    strncpy_s(ptr, <span class="keyword">sizeof</span>(ptr), name, length); <span class="comment">//如果ptr是数组类型，那么返回的是数组长度。如果ptr是指针类型，那么sizeof(ptr) 返回的是指针的大小（通常是 4 或 8 字节），而不是字符串的长度。</span></span><br><span class="line">    Student::count++;</span><br><span class="line">    Student::count++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造函数已调用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::~Student()&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数已调用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	Student::count--;</span><br><span class="line">	delete[] ptr;</span><br><span class="line">    ptr = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。</span></span><br><span class="line">Student::Student(<span class="type">const</span> Student &amp;S1):id(S1.id)&#123;</span><br><span class="line">	ptr = new <span class="type">char</span>[S1.name.length() + <span class="number">1</span>]; <span class="comment">//+1是为了存入&#x27;\0&#x27;</span></span><br><span class="line">	strcpy_s(ptr, S1.name.length() + <span class="number">1</span>, S1.name.c_str());</span><br><span class="line">	this-&gt;name = S1.name; <span class="comment">//这时传入的参数是S1，需要指定S1.name</span></span><br><span class="line">	count++;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数已调用&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> Student::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*************************student_main.cpp**************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Student *S1 = new Student(<span class="number">341222</span>,<span class="string">&quot;阿瑞尔&quot;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">18</span>,<span class="number">181.1f</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;默认参数id:&quot;</span> &lt;&lt;S1-&gt;id&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;字符数组：&quot;</span>&lt;&lt;S1-&gt;ptr&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt;S1-&gt;count&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	Student *S2 = new Student(*S1); </span><br><span class="line">    <span class="comment">//Student S2 = *S1;   可以调用拷贝构造函数</span></span><br><span class="line">    <span class="comment">//Student *S2 = S1;   不可以调用拷贝构造函数，在C++中，可以写成 Student *S2 = S1;，但这并不是复制对象的行为，而是将 S2 指针指向与 S1 相同的对象。这样做会导致 S1 和 S2 指向同一个对象，而不是创建一个新的对象。</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt;S1-&gt;count&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;默认参数id:&quot;</span> &lt;&lt;S2-&gt;id&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	delete S1;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt;S1-&gt;count&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	delete S2;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt;S1-&gt;count&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//********************************printf***************************************</span></span><br><span class="line">有参构造函数已调用</span><br><span class="line">默认参数id:<span class="number">341222</span></span><br><span class="line">字符数组：阿瑞尔</span><br><span class="line">count:<span class="number">1</span></span><br><span class="line">拷贝构造函数已调用</span><br><span class="line">count:<span class="number">2</span></span><br><span class="line">默认参数id:<span class="number">341222</span></span><br><span class="line">析构函数已调用</span><br><span class="line">count:<span class="number">1</span></span><br><span class="line">析构函数已调用</span><br><span class="line">count:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line">Process exited after <span class="number">0.02544</span> seconds with <span class="keyword">return</span> value <span class="number">0</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<h4 id="封装-模板函数-面向过程"><a href="#封装-模板函数-面向过程" class="headerlink" title="封装-模板函数-面向过程"></a>封装-模板函数-面向过程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  MYARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  MYARRAY_H</span></span><br><span class="line"></span><br><span class="line">template&lt;typename  E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span>   len; <span class="comment">// 数组容量</span></span><br><span class="line">    E* p;  <span class="comment">// 数组指针</span></span><br><span class="line">    <span class="type">int</span>   size;<span class="comment">// 数组尺寸 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">resetLen</span><span class="params">()</span> &#123;</span><br><span class="line">        E* temp = new E[len * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            temp[i] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete[] p;</span><br><span class="line">        p = temp;</span><br><span class="line">        len = len * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyArray(<span class="type">int</span> len = <span class="number">10</span>) :len(len), size(<span class="number">0</span>) &#123;</span><br><span class="line">        p = new E[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>  <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= len) &#123;</span><br><span class="line">            resetLen();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; index - <span class="number">1</span>; i--) &#123;</span><br><span class="line">            p[i + <span class="number">1</span>] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p[index] = data;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span>  <span class="title function_">add</span><span class="params">(E  data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= len) &#123;</span><br><span class="line">            resetLen();</span><br><span class="line">        &#125;</span><br><span class="line">        p[size] = data;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>   <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            p[i] = p[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> index, E data)</span> &#123;</span><br><span class="line">        p[index] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*void  sort(auto  aaa) &#123;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; size - i; j++) &#123;</span></span><br><span class="line"><span class="comment">                if (aaa(p[j], p[j + 1]) &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">                    E  temp = p[j];</span></span><br><span class="line"><span class="comment">                    p[j] = p[j + 1];</span></span><br><span class="line"><span class="comment">                    p[j + 1] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    E  <span class="title function_">getData</span><span class="params">(<span class="type">int</span>  index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  p[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>  <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyArray() &#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言基础知识</title>
    <url>/2024/04/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="C语言基础知识"><a href="#C语言基础知识" class="headerlink" title="C语言基础知识"></a>C语言基础知识</h1><h2 id="volatile："><a href="#volatile：" class="headerlink" title="volatile："></a>volatile：</h2><p>​	在当前线程内，当读取一个变量时，为了提高读取速度编译器会先把变量读取到一个寄存器中，再读取变量时就会直接从寄存器读取，当变量在本次线程改变时，会把改变后的变量值copy到该寄存器中，保持一致，当变量因为别的线程值发生改变，寄存器的值不会相应的改变，从而照成程序读取的值和实际变量值不一样，<br>volatile的作用就是不将变量读取到寄存器中，或者说每一次读取都是从内存中读取变量值，牺牲了一定的效率，但提升了正确率。</p>
<h2 id="子函数变量地址："><a href="#子函数变量地址：" class="headerlink" title="子函数变量地址："></a>子函数变量地址：</h2><h3 id="个人发现："><a href="#个人发现：" class="headerlink" title="个人发现："></a>个人发现：</h3><p>有趣的发现：我在int Max_Arr(int arr[][4]); int Min_Arr(int arr[][4]);都定义了临时变量int line, row；由于数组特殊导致求最小值的时候if(min&gt;arr[i][j])逻辑表达式一直为false，if的语句块从未执行。变量line, row未被赋值。但实际输出居然和最大值的line， row值相同。</p>
<p>经过我的测试由于int Max_Arr(int arr[][4]);int Max_Arr(int arr[][4]);的临时变量数量相同，在Max_Arr()创建释放的line,row变量，在Min_Arr()创建变量时地址和Max_Arr()里的line, row地址一样。然而在int Min_Arr(int arr[][4])加入int a, b, c, d&#x3D;0;等无关变量后 line row地址改变。</p>
<h3 id="ChatGPT解释"><a href="#ChatGPT解释" class="headerlink" title="ChatGPT解释:"></a>ChatGPT解释:</h3><p>​	在C语言中，函数内的变量通常存储在栈上。栈是一种后进先出（LIFO）的数据结构，用于存储函数调用时的局部变量、函数参数和返回地址等信息。当函数被调用时，系统会为该函数的局部变量在栈上分配内存空间。当函数返回时，这些局部变量所占用的栈空间会被释放，以便给后续的函数调用使用。因此，函数内的变量地址通常是相对于栈顶的偏移量。需要注意的是，栈是一种自动管理的内存区域，其生命周期与函数调用的生命周期相关联。因此，函数内的变量在函数返回后就不再有效，对它们的地址进行访问可能会导致未定义的行为。另外，有些编译器可能会对程序进行优化，可能会将某些局部变量存储在寄存器中，而不是栈上。这取决于编译器的实现和编译器优化选项。</p>
<p>​	在典型的栈数据结构中，栈底通常具有较低的内存地址，而栈顶具有较高的内存地址。因此，栈底的变量地址通常比栈顶的变量地址要小。如果要打印栈底和栈顶的变量地址，通常情况下，栈底的变量地址会较小，而栈顶的变量地址会较大。这是因为栈的存储方式是后进先出（LIFO），新的变量被推入栈顶，而栈顶的变量地址是最大的。反之，栈底的变量地址则是最小的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Printf_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Max_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Max_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Double_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">	&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	Printf_Arr(arr);</span><br><span class="line">	Sum_Arr(arr);</span><br><span class="line">	Max_Arr(arr);</span><br><span class="line">	Min_Arr(arr);</span><br><span class="line">	Double_Arr(arr);</span><br><span class="line">	Printf_Arr(arr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Printf_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">			sum += arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Max_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line">	<span class="type">int</span> max = arr[<span class="number">0</span>][<span class="number">0</span>], line, row;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(max&lt;arr[i][j])&#123;</span><br><span class="line">				line = i+<span class="number">1</span>;</span><br><span class="line">				row = j+<span class="number">1</span>;</span><br><span class="line">				max = arr[i][j];&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d line:%d, adress:%d, row:%d, adress:%d\n&quot;</span>,max, line,&amp;line, row,&amp;row);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Min_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b, c, d=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> min = arr[<span class="number">0</span>][<span class="number">0</span>], line, row;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(min&gt;arr[i][j])&#123;</span><br><span class="line">				line = i+<span class="number">1</span>;</span><br><span class="line">				row = j+<span class="number">1</span>;</span><br><span class="line">				min = arr[i][j];&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d line:%d, adress:%d, row:%d, adress:%d\n&quot;</span>,min, line,&amp;line, row,&amp;row);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Double_Arr</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>])</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">			arr[i][j] *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符数组："><a href="#字符数组：" class="headerlink" title="字符数组："></a>字符数组：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">//字面量写法 相当于 char arr[6] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27;&#125;;‘\0’也要占一个char的字节</span></span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">char</span>); <span class="comment">//length=6 说明字面量书写字符数组默认占一个&#x27;\0&#x27;字节（终止符）</span></span><br></pre></td></tr></table></figure>

<p>当我试图以此法用指针更改字符串，却收到了报错：”world”的类型是 const char *,说明它是只读的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="type">char</span> *ptr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">*ptr = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*ptr);</span><br><span class="line"><span class="comment">//在C语言中，字符串字面值（例如：&quot;world&quot;）在定义时会被编译器存储在常量区，这意味着它们是不可修改的字符常量。当你使用一个指针指向字符串字面值时，你实际上是让指针指向常量区中的字符串常量，因此试图修改这些字符串是非法的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line"><span class="comment">//这个数组会在栈上或堆上分配空间，并且将字符串内容复制到这个数组中。因此，现在你有一个可修改的字符数组，而不是指向字符串常量的指针。在这种情况下，你可以安全地修改数组中的字符，因为它们是可修改的。</span></span><br></pre></td></tr></table></figure>



<h2 id="二维数组："><a href="#二维数组：" class="headerlink" title="二维数组："></a>二维数组：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> arr[<span class="number">3</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,arr[i]); </span><br><span class="line">		&#125;</span><br><span class="line">	<span class="type">int</span> rows = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//直指本质：二维数组就是多个一维数组，arr表示二维数组，arr[i]表示一维数组</span></span><br><span class="line">	<span class="type">int</span> cols = <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//arr[i][j]表示一个字符</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rows:%d\ncols:%d\n&quot;</span>,rows,cols);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="情况1（输入字符串均小于字符数组长度）"><a href="#情况1（输入字符串均小于字符数组长度）" class="headerlink" title="情况1（输入字符串均小于字符数组长度）"></a>情况1（输入字符串均小于字符数组长度）</h4><p>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esp</span><br><span class="line">rtc</span><br><span class="line">rtos</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">row:<span class="number">3</span>  <span class="comment">//定义二维数组就初始好的，不会改变</span></span><br><span class="line">cols:<span class="number">6</span> <span class="comment">//定义二维数组就初始好的，不会改变</span></span><br><span class="line">esp  </span><br><span class="line">rtc</span><br><span class="line">rtos  <span class="comment">//输出符合预期</span></span><br></pre></td></tr></table></figure>



<h4 id="情况2（输入字符串有个别一维数组超出长度）"><a href="#情况2（输入字符串有个别一维数组超出长度）" class="headerlink" title="情况2（输入字符串有个别一维数组超出长度）"></a>情况2（输入字符串有个别一维数组超出长度）</h4><p>输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">freertos</span><br><span class="line">rtc</span><br><span class="line">esp</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rows:<span class="number">3</span>                   |        |</span><br><span class="line">cols:<span class="number">6</span>                   |  esp   |&lt;<span class="number">-0062F</span>DFC</span><br><span class="line">freertrtc                |  rtc   |  <span class="number">0062F</span>DF6 <span class="comment">//rtc后面填充了3个\0</span></span><br><span class="line">rtc                      |freert  |  <span class="number">0062F</span>DF0 <span class="comment">//只能存储前六个字符</span></span><br><span class="line">esp                      |————————|</span><br><span class="line"><span class="comment">//指针指向栈低，输出freert 由于没有终止符\0，指针向栈顶移动，移动到地址为0062FDF6，继续输出该指针指向的内容，由于在该内容存在终止符，于是停止输出，最终结果为freertrtc</span></span><br></pre></td></tr></table></figure>

<h4 id="代码改进："><a href="#代码改进：" class="headerlink" title="代码改进："></a>代码改进：</h4><p> <code>scanf(&quot;%5s&quot;, arr[i]);</code> 替换程序中的 <code>scanf(&quot;%s&quot;, arr[i]);</code>每个字符串将被截断为最多5个字符（不包括结尾的空字符<code>\0</code>），因为 <code>%5s</code> 限制了每个输入字符串的最大长度为5。</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freertos   //敲击回车键（Enter键）会被视为输入结束的终止符</span><br><span class="line">rtc       //回车后就结束输入了   freer  tos\0  rtc\0   被截断填充到下一个字符数组中</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">freer  <span class="number">000000000062F</span>DF0</span><br><span class="line">tos  <span class="number">000000000062F</span>DF6</span><br><span class="line">rtc  <span class="number">000000000062F</span>DFC</span><br></pre></td></tr></table></figure>

<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freertosrtcespabcd</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">freer  <span class="number">000000000062F</span>DF0</span><br><span class="line">tosrt  <span class="number">000000000062F</span>DF6</span><br><span class="line">cespa  <span class="number">000000000062F</span>DFC      <span class="comment">//说明%5s是将字符串截断，剩余的放到下一个字符数组中。保留一个字节存放终止符。</span></span><br></pre></td></tr></table></figure>



<h1 id="指针"><a href="#指针" class="headerlink" title="指针:"></a>指针:</h1><p><strong>大佬之作</strong>：<a href="https://blog.csdn.net/soonfly/article/details/51131141">让你不再害怕指针——C指针详解(经典,非常详细)_c语言指针-CSDN博客</a></p>
<h2 id="指针基本类型："><a href="#指针基本类型：" class="headerlink" title="指针基本类型："></a>指针基本类型：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span></span><br><span class="line"><span class="type">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span></span><br><span class="line"><span class="type">int</span> *(*p(<span class="type">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure>



<h2 id="指针与数组："><a href="#指针与数组：" class="headerlink" title="指针与数组："></a>指针与数组：</h2><h3 id="指针与一维数组："><a href="#指针与一维数组：" class="headerlink" title="指针与一维数组："></a>指针与一维数组：</h3><h4 id="指针的初始化："><a href="#指针的初始化：" class="headerlink" title="指针的初始化："></a>指针的初始化：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指向已有变量的地址：</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;num; <span class="comment">// 指向已有变量num的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指向数组元素：</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr; <span class="comment">// 指向数组arr的第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配内存：</span></span><br><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配一个int大小的内存空间，并将指针ptr指向该空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指向空（NULL）：</span></span><br><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>; <span class="comment">// 将指针ptr初始化为空指针</span></span><br></pre></td></tr></table></figure>



<h4 id="P-P-P的含义"><a href="#P-P-P的含义" class="headerlink" title="*P,  P,  &amp;P的含义:"></a>*P,  P,  &amp;P的含义:</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> arr=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>&#125;</span><br><span class="line">	<span class="type">int</span> *p=&amp;a;</span><br><span class="line">    <span class="type">int</span> *p1=arr;<span class="comment">//效果与*p1=&amp;arr[0],*p1=&amp;arr相同，但*p1=&amp;arr不推荐使用,会有waring.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d  %p\n&quot;</span>, a, &amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d  %p  %p\n&quot;</span>, *p, p, &amp;p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>  <span class="number">000000000062F</span>E1C</span><br><span class="line"><span class="number">10</span>  <span class="number">000000000062F</span>E1C  <span class="number">000000000062F</span>E10 </span><br><span class="line"><span class="comment">//*p:指针p所指向的int变量的值，即a的值。</span></span><br><span class="line"><span class="comment">// p:指针p所存储的地址，即变量a的地址。</span></span><br><span class="line"><span class="comment">//&amp;p:指针p本身的地址。</span></span><br></pre></td></tr></table></figure>



<h3 id><a href="#" class="headerlink" title></a></h3><h4 id="指针算术"><a href="#指针算术" class="headerlink" title="指针算术"></a>指针算术</h4><p>数组名本身就是指向数组第一个指针与元素的指针  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr1 = numbers; <span class="comment">// 指向数组第一个元素的指针 </span></span><br><span class="line"><span class="type">int</span> *ptr2 = numbers + <span class="number">3</span>; <span class="comment">// 指向数组中的第四个元素的指针</span></span><br></pre></td></tr></table></figure>

<h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,arr[i],*(p+i),*(arr+i),p[i]);<span class="comment">//7 7 7 7以此法不会改变指针p指向的变量，但p++会指向下一个内存地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后缀是先使用后加加，后缀是先加加后使用</p>
<h4 id="p"><a href="#p" class="headerlink" title="*p++"></a>*p++</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;原*p的值: %d\n&quot;</span>, *p);  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">/// 后置++的优先级高于*,即 先p++ 后*p  但是后置++ 是先使用后++</span></span><br><span class="line"><span class="comment">/// 所以先使用 p 此时p为首元素地址 解引用p得到 1 赋给 a ,p使用完后++, p为第二个元素地址</span></span><br><span class="line"><span class="type">int</span> a = *p++; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, *p = %d\n&quot;</span>, a, *p); <span class="comment">// 1  4</span></span><br></pre></td></tr></table></figure>

<h4 id="p-1"><a href="#p-1" class="headerlink" title="*p++"></a>*p++</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;原*p的值: %d\n&quot;</span>, *p);  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">/// 和前面一样先 p++ 后 *p 但是后置++ 是先使用后++</span></span><br><span class="line"><span class="type">int</span> b = *(p++);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d: *p = %d\n&quot;</span>, b, *p); <span class="comment">// 1 4</span></span><br></pre></td></tr></table></figure>

<h4 id="p-2"><a href="#p-2" class="headerlink" title="(*p)++"></a>(*p)++</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;原*p的值: %d\n&quot;</span>, *p);  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 括号的优先级高于 后置++，所以先 *p 后++</span></span><br><span class="line"><span class="comment">// 后置++ 是先使用后++，*p 得到值 1 先使用赋给 c 然后++， *p变为 2，则arr[0]也变为2</span></span><br><span class="line"><span class="type">int</span> c = (*p)++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %d: *p = %d\n&quot;</span>, c, *p); <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<h4 id="p-3"><a href="#p-3" class="headerlink" title="*++p"></a>*++p</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="comment">// 前置++的优先级高于*，先++p 后 *p</span></span><br><span class="line"><span class="comment">// 与第一个不同的是  前置++ 是 先++ 后使用</span></span><br><span class="line"><span class="comment">// 所以 p加加后指向arr第二个元素，即p存放第二个元素地址，解引用得到 4 赋给 d</span></span><br><span class="line"><span class="type">int</span> d = *++p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d: %d   *p = %d\n&quot;</span>, d, *p); <span class="comment">// 4  4</span></span><br></pre></td></tr></table></figure>

<h4 id="p-4"><a href="#p-4" class="headerlink" title="++*p"></a>++*p</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"><span class="type">int</span> e = ++ * p;  <span class="comment">// 等价于 ++（*p）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;e = %d  *p = %d\n&quot;</span>, e, *p); <span class="comment">// 2 2</span></span><br></pre></td></tr></table></figure>

<h3 id="指针与二维数组："><a href="#指针与二维数组：" class="headerlink" title="指针与二维数组："></a>指针与二维数组：</h3><h4 id="指针二维数组初始化："><a href="#指针二维数组初始化：" class="headerlink" title="指针二维数组初始化："></a>指针二维数组初始化：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">	&#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">	<span class="type">int</span> (*p)[<span class="number">4</span>] = matrix;  <span class="comment">//指针初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">			sum += *(*(p+i)+j); <span class="comment">//访问第i行第j列， 二维数组指针访问格式 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(p + i)：这是一个指针运算，将指针 p 向后移动了 i 个元素的距离，使得它指向了二维数组中的第 i 行。</span></span><br><span class="line"><span class="comment">//*(p + i)：这是对指针进行解引用，即获取指针 p 移动后所指向的地址的值。在这里，它指向了二维数组中第 i 行的起始地址，也就是一个指向该行第一个元素的指针。</span></span><br><span class="line"><span class="comment">//*(p + i) + j：这一步再次进行指针运算，将指向第 i 行的指针偏移了 j 个元素的大小。这样就得到了指向第 i 行第 j 列元素的指针。</span></span><br><span class="line"><span class="comment">//*(*(p + i) + j)：最后，通过 * 解引用这个指针，就得到了第 i 行第 j 列元素的值。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,matrix, p, matrix[<span class="number">0</span>], &amp;matrix);<span class="comment">//62FDE0 62FDE0 62FDE0 62FDE0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p %p %p&quot;</span>,*matrix[<span class="number">1</span>], *(p+<span class="number">1</span>), matrix[<span class="number">1</span>]);<span class="comment">//5 62FDF0 62FDF0</span></span><br><span class="line"><span class="comment">//对于指针p可以p++改变指针P指向的方向</span></span><br><span class="line"><span class="comment">//对于数组matrix不可以使用递增/减操作符，matrix始终指向数组起始地址。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指针与二级指针，三级指针"><a href="#指针与二级指针，三级指针" class="headerlink" title="指针与二级指针，三级指针"></a>指针与二级指针，三级指针</h3><p>使用二级指针&amp;三级指针遍历二维数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Two_Ptr</span><span class="params">(<span class="type">int</span> **p)</span>;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">Three_Ptr</span><span class="params">(<span class="type">int</span> ***p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">		&#123;<span class="number">20</span>, <span class="number">24</span>, <span class="number">4</span>, <span class="number">9</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> *ptr = (<span class="type">int</span> *)arr;<span class="comment">//将二维数组的地址转化为int*，并将地址赋值给ptr，为二级指针传参做准备</span></span><br><span class="line">	<span class="type">int</span> **ptc = &amp;ptr;<span class="comment">//将int*类型的ptr地址赋值给二级指针ptc，为三级指针传参做准备</span></span><br><span class="line">	Two_Ptr(&amp;ptr);</span><br><span class="line">	Three_Ptr(&amp;ptc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Two_Ptr</span><span class="params">(<span class="type">int</span> **p)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(*p+i*<span class="number">4</span>+j));<span class="comment">//*p：首先解引用一级指针 p，得到一个指针，它指向一个一维数组。*(*p+i*4+j)：在第一级指针解引用的基础上，加上 i*4+j 个偏移量，得到所需元素的地址，然后再次解引用，得到该地址处的元素值。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">Three_Ptr</span><span class="params">(<span class="type">int</span> ***p)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(**p+i*<span class="number">4</span>+j));<span class="comment">//**p：首先解引用二级指针 p，得到一个一级指针，它指向一个一维数组。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组作为形参传递不同点："><a href="#数组作为形参传递不同点：" class="headerlink" title="数组作为形参传递不同点："></a>数组作为形参传递不同点：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="comment">// 地址传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *arr)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="int-salary-与-int-arr-作为形参传入函数的不同点："><a href="#int-salary-与-int-arr-作为形参传入函数的不同点：" class="headerlink" title="int salary 与 int arr[]作为形参传入函数的不同点："></a>int salary 与 int arr[]作为形参传入函数的不同点：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">demo</span><span class="params">(<span class="type">int</span> *num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> salary, arr[<span class="number">5</span>];</span><br><span class="line">    demo(&amp;salary); <span class="comment">//此时需要取地址</span></span><br><span class="line">    demo(arr);<span class="comment">//不需要取地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指针和函数的关系"><a href="#指针和函数的关系" class="headerlink" title="指针和函数的关系"></a>指针和函数的关系</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">inta;</span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line">a=fun(str);</span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;;)</span><br><span class="line">    &#123;</span><br><span class="line">        num+=*s;s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str首地址传递给了s，s 所指向的地址就和str 所指向的地址一致。</span></span><br></pre></td></tr></table></figure>

<h3 id="两数交换代码例子"><a href="#两数交换代码例子" class="headerlink" title="两数交换代码例子"></a>两数交换代码例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   data = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = data;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;swap函数中a = %d b = %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;           </span><br><span class="line">   <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line">   swap(a,b);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;main函数中a = %d b = %d\n&quot;</span>,a,b);</span><br><span class="line">   system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>​	从上面代码运行结果可以知道，在swap函数中将a、b的值已经交换了，但是在main函数中调用swap函数后a、b的值并没有交换。<br>这是因为swap函数的生存周期为调用swap函数那一刻到swap函数执行完这一时间段，swap函数中的a和b是在调用时临时开辟的空间swap执行完空间就释放了，什么都没有了，就算在swap函数中将形式参数a、b的值交换了，但是main函数中的值并没有交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   data = *a;</span><br><span class="line">   *a = *b;</span><br><span class="line">   *b = data;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;swap函数中a = %d b = %d\n&quot;</span>,*a,*b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;           </span><br><span class="line">   <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">30</span>;</span><br><span class="line">   swap(&amp;a,&amp;b);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;main函数中a = %d b = %d\n&quot;</span>,a,b);</span><br><span class="line">   system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>从运行结果可以看出main函数和swap函数的a和b的值都已经交换了，这是为什么呢？<br>从代码中可以看出调用swap函数时实际参数传递的是a和b的地址，形式参数为两个int型的指针变量a和b，分别指向实际参数a和b的地址,在swap函数中进行的交换操作是直接访问的main函数中的a和b的值，所以就算swap函数的空间释放了main函数中a和b的值已经通过swap函数进行交换了。<br>即通过指针可以在子函数中改变main函数的值</p>
<p>原文链接：<a href="https://blog.csdn.net/qq_48458789/article/details/112743244">https://blog.csdn.net/qq_48458789/article/details/112743244</a></p>
<h3 id="教学例子"><a href="#教学例子" class="headerlink" title="教学例子"></a>教学例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  THRESHOLD_FIRST *Salary-*Salary*0.2 -3500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  THRESHOLD_SECOND *Salary-7662*0.2-3500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  BOUNDARY 7662</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Tax</span><span class="params">(<span class="type">int</span> *Salary, <span class="type">int</span> *tax)</span>;<span class="comment">//此次主要是想求出个税tax，只传入已知的Salary那么只能通过Tax（）函数的return获取tax，再加一个变量传入tax的地址，函数Tax（）释放后，主函数内的tax值已被修改。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Salary, tax;  <span class="comment">//Salary税前薪资， tax个税</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入您的工资数额:&quot;</span>); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Salary);</span><br><span class="line">	Tax(&amp;Salary,&amp;tax); <span class="comment">//传入Salary,tax的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n您因缴纳的个税为%d&quot;</span>,tax);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Tax</span><span class="params">(<span class="type">int</span> *Salary,<span class="type">int</span> *tax)</span>&#123;</span><br><span class="line">	<span class="type">int</span> Five_One;	</span><br><span class="line">	Five_One = *Salary&lt;BOUNDARY ? THRESHOLD_FIRST : THRESHOLD_SECOND;</span><br><span class="line">	<span class="keyword">if</span>(Five_One&lt;=<span class="number">1500</span>)&#123;</span><br><span class="line">		*tax = Five_One*<span class="number">0.03</span> - <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Five_One&lt;=<span class="number">4500</span>)&#123;</span><br><span class="line">		*tax = Five_One*<span class="number">0.1</span> <span class="number">-105</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Five_One&lt;=<span class="number">9000</span>)&#123;</span><br><span class="line">		*tax = Five_One*<span class="number">0.2</span> <span class="number">-555</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *tax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Remove_Space</span><span class="params">(<span class="type">char</span> *arr)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(arr) ==<span class="number">0</span> || arr == <span class="literal">NULL</span>)&#123;   <span class="comment">//strlen()即便是在子函数传入的字符数组也能求出字符串长度，而sizeof（）只会把arr当做地址，求出长度为1</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;数据未初始化&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> *first_ptr = arr;</span><br><span class="line">	<span class="type">char</span> *second_ptr = arr;</span><br><span class="line">	<span class="keyword">while</span>(*first_ptr != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*first_ptr != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">			*second_ptr = *first_ptr;</span><br><span class="line">			 second_ptr++;</span><br><span class="line">		&#125;</span><br><span class="line">		first_ptr++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	*second_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Printf_Arr</span><span class="params">(<span class="type">char</span> *arr)</span>&#123;</span><br><span class="line">	<span class="comment">//while(*arr != &#x27;\0&#x27;)&#123;</span></span><br><span class="line">		<span class="comment">//printf(&quot;%c&quot;,*arr++);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,arr); <span class="comment">//跟strlen（）一样检测到终止符才结束</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Change_Arr</span><span class="params">(<span class="type">char</span> *arr)</span>&#123;</span><br><span class="line">	<span class="type">int</span> length = <span class="built_in">strlen</span>(arr);</span><br><span class="line">	<span class="type">char</span> *first_ptr = arr;</span><br><span class="line">	<span class="type">char</span> *end_ptr = &amp;arr[length<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">while</span>(end_ptr &gt;= first_ptr)&#123;</span><br><span class="line">		<span class="type">char</span> temp = *first_ptr;</span><br><span class="line">		*first_ptr = *end_ptr;</span><br><span class="line">		*end_ptr = temp;</span><br><span class="line">		first_ptr++;</span><br><span class="line">		end_ptr--;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		char *temp = first_ptr; </span></span><br><span class="line"><span class="comment">		*first_ptr = *end_ptr;</span></span><br><span class="line"><span class="comment">		*end_ptr = *temp;</span></span><br><span class="line"><span class="comment">		first_ptr++;</span></span><br><span class="line"><span class="comment">		end_ptr--;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"><span class="comment">//在上述注释代码中，运行结果为*first_ptr与*end_ptr值相等，引起此原因是定义了返回类型为char的temp指针并指向first_ptr所指向的地址,当*first_ptr = *end_ptr，同时改变了指向first_ptr的temp的值。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Data_Printf</span><span class="params">(<span class="keyword">struct</span> Person *Person_Data)</span>; <span class="comment">//这里需要加上struct,不然会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> year;</span><br><span class="line">	<span class="type">int</span> month;</span><br><span class="line">	<span class="type">int</span> day;</span><br><span class="line">&#125;Date;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>]; <span class="comment">//不能以char *name定义.</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    Date* birthday;</span><br><span class="line">&#125;Person;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	Date birth = &#123;<span class="number">2002</span>, <span class="number">04</span>, <span class="number">07</span>&#125;;</span><br><span class="line">	Person student = &#123;<span class="string">&quot;阿萨德&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;m&#x27;</span>, &amp;birth&#125;;<span class="comment">//不能&quot;m&quot;赋值，&quot;&quot;用于字符串，使用&quot;&quot;会是字符&#x27;m&#x27;转化为字符串. </span></span><br><span class="line">	Date other_birth = &#123;<span class="number">2001</span>, <span class="number">10</span>, <span class="number">29</span>&#125;;</span><br><span class="line">	Person other_student = &#123;<span class="string">&quot;苏德霞&quot;</span>, <span class="number">19</span>, <span class="string">&#x27;f&#x27;</span>, &amp;other_birth&#125;;</span><br><span class="line">   	Data_Printf(&amp;student);</span><br><span class="line">   	Data_Printf(&amp;other_student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Data_Printf</span><span class="params">(Person *Person_Data)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,Person_Data-&gt;name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Person_Data-&gt;age);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,Person_Data-&gt;sex==<span class="string">&#x27;m&#x27;</span>?<span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span>);<span class="comment">//想要输出汉字需要用%s输出，这种写法很新奇 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d\n&quot;</span>,Person_Data-&gt;birthday-&gt;year,Person_Data-&gt;birthday-&gt;month,Person_Data-&gt;birthday-&gt;day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH sizeof(Student)/sizeof(Student[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASCENDING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESCENDING 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">&#125;Person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Init</span><span class="params">(Person *Student, <span class="type">void</span> *arr[], <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Printf</span><span class="params">(<span class="type">void</span> *arr[], <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Sort</span><span class="params">(<span class="type">void</span> *arr[], <span class="type">int</span> length, <span class="type">int</span> option)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Message_Change_Height</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b, <span class="type">int</span> option)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Person Student[<span class="number">3</span>]=&#123;</span><br><span class="line">		&#123;<span class="string">&quot;发萨斯&quot;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">171.4</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;阿西尔&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">175.2</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;约旦&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">182</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">void</span> *arr[LENGTH];</span><br><span class="line">	Message_Init(Student, arr, LENGTH);</span><br><span class="line">	Message_Printf(arr, LENGTH);</span><br><span class="line">	Message_Sort(arr, LENGTH, ASCENDING);</span><br><span class="line">	Message_Printf(arr, LENGTH);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Init</span><span class="params">(Person *Student, <span class="type">void</span> *arr[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(length &lt;= <span class="number">0</span> || Student == <span class="literal">NULL</span> || arr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;结构体数组不能为空&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">		arr[i] = Student+i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Printf</span><span class="params">(<span class="type">void</span> *arr[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s %s %.1f\n&quot;</span>, ((Person *)arr[i])-&gt;name, ((Person *)arr[i])-&gt;sex==<span class="string">&#x27;f&#x27;</span> ? <span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span>,((Person *)arr[i])-&gt;height);<span class="comment">//不能写成(arr+i)-&gt;name;因为使用 (arr + i)-&gt;name 时，实际上是在尝试将整个 Person* 指针（arr[i]）视为一个结构体 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Message_Sort</span><span class="params">(<span class="type">void</span> *arr[], <span class="type">int</span> length, <span class="type">int</span> option)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(Message_Change_Height(arr[i],arr[i+<span class="number">1</span>],option) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="type">void</span> *temp = arr[i];</span><br><span class="line">			arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">			arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">		<span class="comment">//	arr[i]是一个地址，不能相加（四字节的地址相加可能会导致地址溢出，但可以进行指针算术相减（相减结果为步长）  </span></span><br><span class="line">		<span class="comment">/*	arr[i] = arr[i] + arr[i+1];  </span></span><br><span class="line"><span class="comment">			arr[i+1] = arr[i] - arr[i+1];</span></span><br><span class="line"><span class="comment">			arr[i] = arr[i] - arr[i+1];</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">Message_Change_Height</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b, <span class="type">int</span> option)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> option ? ((Person *)a)-&gt;height&lt;((Person *)b)-&gt;height : ((Person *)a)-&gt;height&gt;((Person *)b)-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译与GDB调试</title>
    <url>/2024/03/30/Gcc%E7%BC%96%E8%AF%91%E4%B8%8EGdb%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="GCC编译与GDB调试"><a href="#GCC编译与GDB调试" class="headerlink" title="GCC编译与GDB调试"></a>GCC编译与GDB调试</h1><h2 id="一-gcc"><a href="#一-gcc" class="headerlink" title="一.gcc"></a>一.gcc</h2><h3 id="1-gcc简介："><a href="#1-gcc简介：" class="headerlink" title="1.gcc简介："></a>1.gcc简介：</h3><p>​	gcc命令使用GNU推出的基于C&#x2F;C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。</p>
<p>​	gcc是GNU编译器套件（GNU Compiler Collection），它包括了C、C++、Objective-C、Fortran、Java、Ada、Go语言和D语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。</p>
<h3 id="2-gcc编译链接过程"><a href="#2-gcc编译链接过程" class="headerlink" title="2.gcc编译链接过程"></a>2.gcc编译链接过程</h3><p>（1）预编译：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`gcc -e main.c -o main.i <span class="comment">//-o选项用来指定输出文件的文件名 </span></span><br></pre></td></tr></table></figure>

<p>（2）编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -s main.i -o main.s</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc test001.c test002.c -o test  <span class="comment">//将test001.c和test002.c分别编译后连接成test可执行文件</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/20/LVGL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>基于ESP-S3的智能手环</title>
    <url>/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="资料准备："><a href="#资料准备：" class="headerlink" title="资料准备："></a>资料准备：</h1><h4 id="SPI-LCD详解："><a href="#SPI-LCD详解：" class="headerlink" title="SPI LCD详解："></a>SPI LCD详解：</h4><p><a href="https://docs.espressif.com/projects/esp-iot-solution/zh_CN/latest/display/lcd/spi_lcd.html">SPI LCD 详解 - - — ESP-IoT-Solution latest 文档 (espressif.com)</a></p>
<h4 id="ESP-IDF编程指南："><a href="#ESP-IDF编程指南：" class="headerlink" title="ESP-IDF编程指南："></a>ESP-IDF编程指南：</h4><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/index.html">ESP-IDF 编程指南 - ESP32 - — ESP-IDF 编程指南 latest 文档 (espressif.com)</a></p>
<h4 id="屏幕技术手册（P169H002-："><a href="#屏幕技术手册（P169H002-：" class="headerlink" title="屏幕技术手册（P169H002)："></a>屏幕技术手册（P169H002)：</h4><h4 id="屏幕驱动IC的技术手册-ST7789V-："><a href="#屏幕驱动IC的技术手册-ST7789V-：" class="headerlink" title="屏幕驱动IC的技术手册(ST7789V)："></a>屏幕驱动IC的技术手册(ST7789V)：</h4><h4 id="触摸IC的技术手册-CST816D-："><a href="#触摸IC的技术手册-CST816D-：" class="headerlink" title="触摸IC的技术手册(CST816D)："></a>触摸IC的技术手册(CST816D)：</h4><h4 id="屏幕原厂提供的配置设置："><a href="#屏幕原厂提供的配置设置：" class="headerlink" title="屏幕原厂提供的配置设置："></a>屏幕原厂提供的配置设置：</h4><h4 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h4><p>ESP-IDF –V5.1.1</p>
<p>LVGL –8.3.9</p>
<h4 id="硬件环境："><a href="#硬件环境：" class="headerlink" title="硬件环境："></a>硬件环境：</h4><p>ESP-S3-DevKitC-1WPOOM-1</p>
<p>FPC转接板</p>
<p>3.7V锂电池</p>
<p>P169H002电容触摸屏</p>
<h1 id="知识收获"><a href="#知识收获" class="headerlink" title="知识收获"></a>知识收获</h1><p>nvs非易失性存储  </p>
<p>ESP32是SPI  Flash</p>
<p>0x1000 &#x3D; 4K      0x100000 &#x3D; 1M</p>
<h1 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h1><p>当使用 <code>UART0</code> 管脚下载固件时，需要满足以下接线条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VDD     -&gt; 3V3</span><br><span class="line">GND     -&gt; GND   (与供电板“共地”)</span><br><span class="line">EN      -&gt; 拉高   (用于上电启动、不可浮空)</span><br><span class="line">GPIO0   -&gt; 拉低   (进入下载模式)</span><br><span class="line">GPIO46  -&gt; 拉低</span><br><span class="line">TXD0(GPIO43)    -&gt; RX</span><br><span class="line">RXD0(GPIO44)    -&gt; TX</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF" alt="image-20240411154614214"></p>
<h4 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h4><p>检测导通用万用表，红笔接地不动。</p>
<p><img src="/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF" alt="image-20240411193142332"></p>
<h4 id="SPI屏幕驱动IDF-组件注册表-—-IDF-Component-Registry-espressif-com"><a href="#SPI屏幕驱动IDF-组件注册表-—-IDF-Component-Registry-espressif-com" class="headerlink" title="SPI屏幕驱动IDF 组件注册表 — IDF Component Registry (espressif.com)"></a>SPI屏幕驱动<a href="https://components.espressif.com/components/espressif/esp_lcd_ili9341">IDF 组件注册表 — IDF Component Registry (espressif.com)</a></h4><p><img src="/2024/03/28/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF/%E5%9F%BA%E4%BA%8EESP-S3%E7%9A%84%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF" alt="image-20240411193536757"></p>
<p>3线spi和4线spi 的主要区别在于是否使用 D&#x2F;C 信号线。</p>
<h1 id="屏幕驱动"><a href="#屏幕驱动" class="headerlink" title="屏幕驱动"></a>屏幕驱动</h1><p>在main文件夹下的CMakeList.txt中修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Add sources from ui directory</span><br><span class="line">file(GLOB_RECURSE SRC_UI $&#123;CMAKE_SOURCE_DIR&#125; &quot;ui/*.c&quot;)</span><br><span class="line"></span><br><span class="line">idf_component_register(SRCS &quot;main.c&quot; $&#123;SRC_UI&#125;</span><br><span class="line">                    INCLUDE_DIRS &quot;.&quot; &quot;ui&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在main文件下创建idf_component.yml修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  lvgl/lvgl: &quot;==8.3.9&quot;</span><br><span class="line">  ## Required IDF version</span><br><span class="line">  idf:</span><br><span class="line">    version: &quot;&gt;=5.1.0&quot;</span><br><span class="line"></span><br><span class="line">  espressif/esp_lcd_ili9341: &quot;^1.2.0&quot;</span><br><span class="line"></span><br><span class="line">  espressif/esp_lcd_touch_cst816s: &quot;^1.0.3&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI"></a>WIFI</h1><p>在项目根目录下创建sdkconfig.defaults添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_EXAMPLE_WIFI_SSID=&quot;esp&quot;</span><br><span class="line">CONFIG_EXAMPLE_WIFI_PASSWORD=&quot;12345678&quot;</span><br></pre></td></tr></table></figure>

<p>在项目根目录下的CMakeLists.txt中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(EXTRA_COMPONENT_DIRS $ENV&#123;IDF_PATH&#125;/examples/common_components/protocol_examples_common)</span><br></pre></td></tr></table></figure>



<h4 id="天气信息与lvgl交互"><a href="#天气信息与lvgl交互" class="headerlink" title="天气信息与lvgl交互"></a>天气信息与lvgl交互</h4><p>1.lvgl任务只能使用被完全解析的天气信息</p>
<p>2.lvgl任务要在json数据被释放之前完成读取</p>
]]></content>
      <tags>
        <tag>ESP-S3</tag>
      </tags>
  </entry>
</search>
